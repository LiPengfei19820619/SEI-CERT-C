# C 语言安全编码规范（2016版）

[TOC]

## 1 前言

## 2 预处理器 (PRE)

### 2.1 PRE30-C 不要通过连接符创建通用字符名

C标准支持可用于标识符、字符常量和文本字符串的通用字符名，用以表示基本字符集中未能覆盖的字符。通用字符名\Unnnnnnnn*指定了其8位短标识符（由ISO/IEC
10646规定）是nnnnnnnn的字符,通用字符名\unnnn*指定了其4位短标识符为nnnn（*其8位短标识符为字符0000nnnn）。
C11标准的5.1.1.2章表示：
> 如果满足通用字符名语法的字符序列是由标记连接生成，则其行为是未定义的。

参见附录未定义行为3。
一般来说，除非绝对必要，应避免在标识符中使用通用字符名。

#### 2.1.1 不合规代码示例

此示例代码不合规，因为它通过标记级联生成通用字符名：

```cpp
#define assign(uc1, uc2, val) uc1##uc2 = val

void func(void) {
    int \u0401;
    /* ... */
    assign(\u04, 01, 4);
    /* ... */
}
```

#### 2.1.2 实现细节

这段代码使用Microsoft Visual Studio 2013编译和运行，能将整数4按预期赋给变量\u0401。

Linux的GCC 4.8.1版本拒绝编译此代码，它会抛出一个诊断信息：“程序中含有'\'，请查看assign宏中的通用字符代码片段”。

#### 2.1.3 合规解决方案

此合规解决方案使用通用了字符名，但不通过连接符创建：
```
#define assign(ucn, val) ucn = val

void func(void) {
    int \\u0401;
    /* ... */   assign(\\u0401, 4);
    /* ... */
}

```

#### 2.1.4 风险评估

通过连接符创建通用字符会导致未定义的行为。

| 规则    | 严重性  | 可能性   | 修补成本 | 优先级  | 级别   |
|--------|--------|-------- |----------|--------|------|
|PRE30-C |   低   | 不太可能  |    中    |   P2   |  L3  |

### 2.2 PRE31-C 避免不安全宏的参数出现副作用
一个不安全的函数宏会在展开时多次使用或根本不使用某个参数。绝对不要调用包含赋值、增量、减量、volatile访问、输入/输出等具有副作用（包括含有副作用的函数调用）参数的不安全宏。

若文档中涉及不安全宏的时候，应当对使用含有副作用的参数调用进行警告，但是责任根源在于程序员使用了某个不安全宏。由于在使用中会伴随风险，应避免定义不安全的函数宏。

#### 2.2.1 不合规代码示例

不安全宏的问题之一是其宏参数含有副作用，正如下面这段不合规代码示例：
```cpp
#define ABS(x) (((x) < 0) ? -(x) : (x))

void func(int n) {
    /* Validate that n is within the desired range */
    int m = ABS(++n);
    /* ... */
}
```



上面的ABS()宏调用展开后如下：
```cpp
m = (((++n) < 0)? -(++n):(++n));
```
生成的代码是明确的，但会导致n递增两次而不是一次。

#### 2.2.2 合规解决方案

在这个合规解决方案中，增量操作++n在宏调用之前得到执行。
```cpp
#define ABS(x) (((x) < 0) ? -(x) : (x))  /* UNSAFE */

void func(int n) {
    /* Validate that n is within the desired range */
    ++n;
    int m = ABS(n);
    /* ... */
}
```

注意上述代码在注释中警告了程序员该宏是不安全的，该宏也可以改名为ABS\_UNSAFE()以明确告知宏是不安全的。正如本规则的所有兼容解决方案，如果ABS()的参数等于最小的有符号整型值（最负值），那么这个解决方案也具有未定义的行为。

#### 2.2.3 合规解决方案

本合规解决方案遵守规范“PRE00-C 以内联函数或静态函数代替类函数的宏”。不像ABS()宏，在对任何类型的操作数进行操作时，iabs()函数将截断比int类型更宽的参数，这些参数的值范围不在int类型的范围内。

```cpp
#include <complex.h>
#include <math.h>

static  inline int iabs(int x)
{
    return (((x) < 0)?-(x):(x));
}

void  func(int n)
{
    /* Validate that n is within the desired range */
    int m = iabs(++n);
    /* ... */
}
```

#### 2.2.4 合规解决方案

更具有弹性的合规解决方案是让ABS()宏使用_Generic选项。为了支持所有的数据类型，此解决方案使用内联函数来计算整数绝对值。参见规则"PRE00-C，用内联函数或静态函数来实现宏"。

在本解决方案中，由于在通用选择中，表达式未参与运算，这就保证了宏参数v只被计算一次。
```cpp
#include <complex.h>
#include <math.h>

static inline long long llabs(long long v) {
  return v < 0 ? -v : v;
}
static inline long labs(long v) {
  return v < 0 ? -v : v;
}
static inline int iabs(int v) {
  return v < 0 ? -v : v;
}
static inline int sabs(short v) {
  return v < 0 ? -v : v;
}
static inline int scabs(signed char v) {
  return v < 0 ? -v : v;
}
#define ABS(v)  _Generic(v, signed char : scabs, \
             short : sabs, \
             int : iabs, \
             long : labs, \
             long long : llabs, \
             float : fabsf, \
             double : fabs, \
             long double : fabsl, \
             double complex : cabs, \
             float complex : cabsf, \
             long double complex : cabsl)(v)

void func(int n) {
  /* Validate that n is within the desired range */
  int m = ABS(++n);
  /* ... */
}
```
通用选择符在C11中引入，C99和更早版本的C标准不支持。

#### 2.2.5 合规解决方案（GCC）

GCC的__typeof扩展使得在一个宏中声明和并进行赋值操作变为可能，操作数的值赋给一个同类型的临时变量，并让临时变量执行计算，从而保证了操作数将只被使用一次。另一个GCC的扩展，称为[语句表达式]，它使用块语句的方式，代码如下：
```cpp
#define ABS(x) __extension__ ({ __typeof (x) tmp = x; \
                    tmp < 0 ? -tmp : tmp; })
```
需要注意的是，这样的扩展违反了规则“MSC14-C，不要引入不必要的平台依赖”。

#### 2.2.6 不合规代码示例(assert())

assert()宏是编码中整合诊断与测试的一种方便机制。assert()宏的行为依赖于类对象的宏定义NDEBUG，若宏NDEBUG没有定义，assert()宏就会计算参数表达式的值，若结果为0，则调用abort()函数。若宏NDEBUG已被定义，assert宏会将0扩展成(void)0，随后，这个入参表达式在断言中就不会被计算，也就是说对于非调试执行下的代码，assert不会有副作用。

以下这段不合规代码包含一个assert()宏，其入参是一个有副作用的表达式（index++）：

```cpp
#include <assert.h>
#include <stddef.h>

void  process(size_t index) {
assert(index++ > 0); /* Side effect */
  /* ... */
}
```


#### 2.2.7 合规解决方案(assert())

这个合规解决方案是将含有副作用的入参表达式移到assert()宏之外。

```cpp
#include <assert.h>
#include <stddef.h>

void process(size_t index) {
assert(index > 0); /* No side effect */
  ++index;
  /* ... */
}

```


#### 2.2.8 例外

**PRE31-C-EX1：**例外的情况是，若一个函数本身无副作用，并且把这个函数调用作为宏参数是允许的。但是，程序员很容易忽视函数可能具有的隐晦的副作用，尤其是对于源代码不可获取的库函数，有时甚至改变errno也是一种副作用。除非函数是用户自己编写的，且只执行计算，并直接返回结果而不调用其他函数，否则的话开发者很容易忽视一些副作用。因此，必须非常小心地应用这个例外。

#### 2.2.9 风险评估

对于非安全宏，若提供的入参含有副作用的话，可能会导致非预期的行为。

| 规则    | 严重性 | 可能性   | 修补成本 | 优先级 | 级别 |
|---------|--------|----------|----------|--------|------|
| PRE31-C | 低     | 不太可能 | 低       | P3     | L3   |


### 2.3 PRE32-C. 不要在类函数宏调用中使用预处理器指令

传递给宏的参数不能包含#define，#ifdef和#include等预处理指令，否则会导致未定义行为。

当不确定某个函数是否是以宏的方式实现的时候，也不能在函数的参数中使用预处理器指令，例如标准库函数 memcpy()、printf()、assert()等就可能是以宏的方式实现的。

#### 2.3.1 不合规代码示例

在这个不合规的代码示例中[GCC BUG]，程序员使用预处理指令对函数memcpy()进行基于平台的参数定制，但如果memcpy()是用宏实现的话，代码就会出现未定义行为。
```    cpp
#include <string.h>

void func(const char *src) {
/* Validate the source string; calculate size */
     char *dest;
     /* malloc() destination string */
     memcpy(dest, src,
      #ifdef PLATFORM1
           12
      #else
           24
      #endif
  );
 /* ... */
);
```


#### 2.3.2 合规解决方案

在这个合规解决方案[GCC BUG]中，调用memcpy()函数的合适方式是在函数外部就把入参确定好。
```cpp
#include <string.h>

void func(const char *src) {
  /* Validate the source string; calculate size */
  char *dest;
  /* malloc() destination string */
  #ifdef PLATFORM1
    memcpy(dest, src, 12);
  #else
    memcpy(dest, src, 24);
  #endif
  /* ... */
}
```
#### 2.3.3 风险评估

在宏参数中包含预处理器指令会导致未定义行为。

| 规则  | 严重性 | 可能性    | 修补成本 | 优先级 | 级别 |
|------|-------|----------|--------|-------|-----|
| PRE32-C | 低 | 不太可能   |  中    | P2    |  L3 |

## 3 声明和初始化(DCL)
### 3.1 DCL30-C 声明具有正确存储持续期的对象
每个对象都有一个确定其生命周期的存储持续期：static、thread、automatic或者allocated。
根据C标准6.2.4章节第2段【ISO/IEC 9899:2011】
>对象的生命周期就是能够保证存储持续有效的程序执行期间的部分时间，一个对象在它的生命周期内，具有一个常量地址，并且保留着最近一次所存储的值。如果对象在其生命周期之外被引用，则该行为是未定义的。当指针指向的对象生命周期结束时，指针的值变得不确定。
>访问超出生命周期之外的对象是未定义的行为，可导致产生可被利用的漏洞。见[未定义行为9]。

#### 3.1.1 不合规代码示例（不同的存储持续期）
在这个不合规代码示例中，变量 c_str 是 automatic 类型存储持续时间，被赋值给 static 类型存储持续时间变量 p ，赋值本身是有效的，但是 c_str 在超出`dont_do_this`函数之外就无效了，而 p 还保存着它的地址。
```cpp
 dont_do_this(void) {
  const char c_str[] = "This will change";
  p = c_str; /* Dangerous */
}
 
void innocuous(void) {
  printf("%s\n", p);
}
 
int main(void) {
  dont_do_this();
  innocuous();
  return 0;
}

```
#### 3.1.2 合规解决方案（相同的存储持续期）
在这个解决方案中，p 被声明为和 c_str 一样的存储持续期，这样就防止了 p 在`this_is_OK`函数之外值的不确定性。
```cpp
void this_is_OK(void) {
  const char c_str[] = "Everything OK";
  const char *p = c_str;
  /* ... */
}
/* p is inaccessible outside the scope of string c_str */

```
可替换方案，p和c_str都声明为static类型存储持续期。
#### 3.1.3 合规解决方案（不同的存储持续期）
如果 p 必须被声明为 static 类型存储持续期，而 c_str 为受限制的存储持续期，那么可以将 p 在 c_str 被销毁前设置为 NULL。这样可以防止 p 取不确定值，但是任何引用p的地方都需要检查 p 是否为空。
```cpp
const char *p;
void is_this_OK(void) {
  const char c_str[] = "Everything OK?";
  p = c_str;
  /* ... */
  p = NULL;
}
```
#### 3.1.4 不合规代码示例（返回值）
在这个示例中，函数`init_array()`返回了一个指向字符数组的 automatic 类型存储持续期的指针。
```cpp
char *init_array(void) {
  char array[10];
  /* Initialize array */
  return array;
}
```
当函数返回 automatic 类型存储持续期的指针时，一些编译器会产生告警，这个例子就是如此，程序员应当在高警告级别上编译代码，并解决所有告警。
#### 3.1.5 合规解决方案（返回值）
在这个例子中，这个解决方案取决于程序员的意图。如果程序员的意图是修改 array 的值，并且让这个修改在`init_array()`函数作用域之外仍然得以保持，可以通过在其他地方声明 array，并把它作为参数传递给`init_array()`来实现这个目的。
```cpp
#include <stddef.h>
void init_array(char *array, size_t len) {
  /* Initialize array */
  return;
}
 
int main(void) {
  char array[10];
  init_array(array, sizeof(array) / sizeof(array[0]));
  /* ... */
  return 0;
}
```
#### 3.1.6 不合规代码示例（输出参数）
在这个例子中，函数`squirrel_away()`存储了一个指向本地变量local的指针，并将该指针赋值给函数入参 ptr_param，在`squirrel_away()`返回后，ptr_param指向的变量已经超出了生命周期。
```cpp
void squirrel_away(char **ptr_param) {
  char local[10];
  /* Initialize array */
  *ptr_param = local;
}
 
void rodent(void) {
  char *ptr;
  squirrel_away(&ptr);
  /* ptr is live but invalid here */
}
```
#### 3.1.7 合规解决方案（输出参数）
在这个例子中，变量 local 具有 static 类型存储持续期，所以 ptr 可以在`rodent()`函数中引用 local 数组。
```cpp
char local[10];
 
void squirrel_away(char **ptr_param) {
  /* Initialize array */
  *ptr_param = local;
}
 
void rodent(void) {
  char *ptr;
  squirrel_away(&ptr);
  /* ptr is valid in this scope */
}
```
#### 3.1.8 风险评估
引用超出生命周期的对象可能导致攻击者运行任意代码。

|   规则    | 严重性  | 可能性  | 补救代价 | 优先级  |  级别  |
| :-----: | :--: | :--: | :--: | :--: | :--: |
| DCL30-C |  高   | 有可能  |  高   |  P6  |  L2  |

#### 3.1.9 相关指南
| 文献                                       | 条目                                       |
| ---------------------------------------- | ---------------------------------------- |
| [CERT C Secure Coding Standard][CERT C Secure Coding Standard] | [MSC00-C. Compile cleanly at high warning levels] [ MSC00-C] |
| [SEI CERT C++ Coding Standard][SEI CERT C++ Coding Standard] | [EXP54-CPP. Do not access an object outside of its lifetime][EXP54-CPP] |
| [ISO/IEC TR 24772:2013][ISO/IEC TR 24772:2013] | Dangling References to Stack Frames [DCM] |
| [ISO/IEC TS 17961][ISO/IEC TS 17961]     | Escaping of the address of an automatic object [addrescape] |
| [MISRA C:2012]                           | Rule 18.6 (required)                     |


### 3.2 DCL31-C 在使用标识符之前声明它们
C11 标准要求声明标识符的类型，禁止隐式函数声明，C90 标准允许隐式的确定变量和函数的类型。因此，一些现有的遗留代码使用隐式类型，一些C编译器为了支持遗留代码仍然允许隐式类型，但是新的代码不应该再使用。这样的实现可以选择使用隐式声明，并继续翻译，以支持使用这个特性的现有程序。
#### 3.2.1 不合规代码示例（隐式int）
C 不再允许不指定类型的声明，C11 标准 6.7.2 节表示：
>每个声明的声明指示符中至少应该有一个类型指示符。

这个不合规的例子省略了类型指示符。
```cpp
extern foo;
```
一些 C 翻译器并不会在遇到违反这个约束情况时产生诊断信息，这些不合格的 C 翻译器会继续处理这类声明，把类型隐式的当作 int。
#### 3.2.2 合规解决方案（隐式int）
这个例子显式的包含了一个类型指示符。
```cpp
extern int foo;
```
#### 3.2.3 不合规代码示例（隐式函数声明）
不允许隐式函数声明，每个函数必须在调用前被显式声明。在 C90 标准中，如果一个被调用的函数没有显式声明原型，编译器会为它提供一个隐式声明。
C90 标准包含了下面的需求：
>如果在一个函数调用中，带括号的实参列表前面的表达式只由一个标识符组成，并且看不到这个标识符的声明，这个标识符将被隐式的声明，就像在最内层的代码块中包含了这个函数调用时出现了`extern int identifier()`这个声明。

如果一个函数的声明在被调用的地方不可见，C90 兼容平台会为其假定一个隐式声明`extern int identifier();`
这个声明暗示这个函数可以取任何数量和类型的参数并返回一个 int 型数据。而如果遵守当前 C 标准，程序员必须在每个函数调用前显式的声明函数原型。符合 C 标准的应用可以遵守也可以不遵守隐式函数声明，但是如果遇到使用未声明的函数时，C 需要产生诊断信息。

在这个不合规示例中，如果`malloc()`函数没有被显式声明或被包含在`stdlib.h`中，只遵守C90 标准的编译器会隐式声明`malloc()`函数为`int malloc()`。如果系统平台的 int 长度是32位，但是指针长度是 64 位，那么本例中的结果就会导致返回的指针被截断，返回一个32位的整型。
```cpp
#include <stddef.h>
/* #include <stdlib.h> is missing */
  
int main(void) {
  for (size_t i = 0; i < 100; ++i) {
    /* int malloc() assumed */
    char *ptr = (char *)malloc(0x10000000);
    *ptr = 'a';
  }
  return 0;
}

```
##### 3.2.3.1 实现细节
如果使用微软 Visual Studio 2013 64 位编译平台，这个不合规代码例子最终会导致一个非法访问错误。
#### 3.2.4 合规解决方案（隐式函数声明）
在这个例子中，`malloc()`函数声明被包含在适当的头文件中。
```cpp
#include <stdlib.h>
  
int main(void) {
  for (size_t i = 0; i < 100; ++i) {
    char *ptr = (char *)malloc(0x10000000);
    *ptr = 'a';
  }
  return 0;
}
```
更多函数声明信息请参阅 [DCL07-C. Include the appropriate type information in function declarators][DCL07-C]. 

#### 3.2.5 不合规代码示例（隐式返回类型）
不要声明具有隐式返回类型的函数，如果一个函数返回一个有意义的整型值，就把它的返回类型声明为 int，如果返回无意义的值，就声明为 void。
```cpp
#include <limits.h>
#include <stdio.h>
 
foo(void) {
  return UINT_MAX;
}
 
int main(void) {
  long long int c = foo();
  printf("%lld\n", c);
  return 0;
}
```
因为编译器假设`foo()`返回一个 int 类型的值，因此`UINT_MAX`被不正确的转换为 -1。
#### 3.2.6 合规解决方案（隐式返回类型）
在这个例子中，`foo()`返回类型被定义为`unsigned int`，因此函数正确返回了`UINT_MAX`。
```cpp
#include <limits.h>
#include <stdio.h>
 
unsigned int foo(void) {
  return UINT_MAX;
}
 
int main(void) {
  long long int c = foo();
  printf("%lld\n", c);
  return 0;
}
```
#### 3.2.7 风险评估
因为隐式声明导致较不严格的类型检查，可能引入意想不到的和错误的行为。在现存代码中，省略类型指示符的情况较为少见，它的后果一般并不严重，可能会导致程序异常中止。

|   规则    | 严重性  | 可能性  | 补救代价 | 优先级  |  级别  |
| :-----: | :--: | :--: | :--: | :--: | :--: |
| DCL31-C |  低   | 不太可能 |  低   |  P3  |  L3  |

#### 3.2.8 相关指南

| 文献                                       | 条目                                       |
| ---------------------------------------- | ---------------------------------------- |
| [CERT C Secure Coding Standard][CERT C Secure Coding Standard] | [DCL07-C. Include the appropriate type information in function declarators] [DCL07-C] |
| [ISO/IEC TR 24772:2013][ISO/IEC TR 24772:2013] | Subprogram Signature Mismatch [OTR]      |
| [ISO/IEC TS 17961][ISO/IEC TS 17961]     | Escaping of the address of an automatic object [addrescape] |
| [MISRA C:2012]                           | Rule 8.1 (required)                      |

### 3.3 DCL36-C 不要声明具有冲突链接属性的标识符
在不同的作用域声明或同一个作用域中声明多次的标识符可以通过链接属性表示同一个对象或函数。标识符的链接属性可以分为外部链接、内部链接、无链接。这三种链接属性有以下特性：
- 外部链接：具有外部链接属性的标识符在整个程序空间（即在所有编译单元和库中）表示相同的对象或函数。标识符对链接器有效。当具有外部链接属性的相同标识符声明第二次出现时，链接器会把这个标识符与同一个对象或函数相关联。
- 内部链接：具有内部链接属性的标识符在一个给定的翻译单元中表示同一个对象或函数。链接器没有内部链接属性标识符相关的信息，因此，这类标识符是属于翻译单元内部的。
- 无链接：如果标识符的链接属性为无链接，则使用这个标识符的所有未来声明都是新的，如新变量或新类型。

根据C11标准6.2.2节，链接属性是按照下面方式确定的：
>如果一个具有文件作用域的表示对象或函数的标识符声明中包含了存储类指示符static，这个标识符就具有内部链接属性。
>如果一个标识符在声明时使用了存储类型指示符 extern，并且在它的作用域中已经有了这个标识符的以前声明，如果以前声明指定了内部或外部链接属性，这个标识符后来的声明的链接属性就与之前声明的相同。如果作用域中没有这个标识符的以前声明，或者它以前声明的链接属性为无链接，这个标识符就具有外部链接属性。
>如果一个表示函数的标识符声明没有使用存储类型指示符 extern，它的链接属性就像使用了存储类型指示符 extern 声明的一样，如果一个表示对象的标识符具有文件作用域，并且没有存储类型指示符，它的链接属性就是外部链接。
>下面这类标识符的链接属性为无链接：被声明为不是函数或对象的标识符、被声明为函数形参的标识符、被声明为对象但没有使用存储类型指示符 extern 的代码块作用域中的标识符。

在一个翻译单元内部，一个标识符既具有内部链接属性又具有外部链接属性将会导致未定义的行为。 (见[未定义行为8][未定义行为8]) 翻译单元包括通过预处理指令`#include`包含的所有头文件和源文件。
下面这个表说明了在一个翻译单元内一个对象在被第二次声明时的链接属性。列代表第一次声明，行代表重复声明。
![][id]
[id]:3/3.3.1.png

#### 3.3.1 不合规代码示例
在这个不合规例子中，i2 和 i5 被定义为同时具有内部和外部链接属性，使用这两个标识符将会导致未定义的行为。
```cpp
int i1 = 10;         /* Definition, external linkage */
static int i2 = 20;  /* Definition, internal linkage */
extern int i3 = 30;  /* Definition, external linkage */
int i4;              /* Tentative definition, external linkage */
static int i5;       /* Tentative definition, internal linkage */
 
int i1;  /* Valid tentative definition */
int i2;  /* Undefined, linkage disagreement with previous */
int i3;  /* Valid tentative definition */
int i4;  /* Valid tentative definition */
int i5;  /* Undefined, linkage disagreement with previous */
 
int main(void) {
  /* ... */
  return 0;
}
```
##### 3.3.1.1 实施细节
微软 Visual Studio 2013 对上述情况不会产生告警，即便是设置了最高告警级别。
GCC 编译器会为 i2 和 i5 定义冲突产生一个致命诊断信息。
#### 3.3.2 合规解决方案
```cpp
int i1 = 10;         /* Definition, external linkage */
static int i2 = 20;  /* Definition, internal linkage */
extern int i3 = 30;  /* Definition, external linkage */
int i4;              /* Tentative definition, external linkage */
static int i5;       /* Tentative definition, internal linkage */
 
int main(void) {
  /* ... */
  return 0;
}
```
#### 3.3.3 风险评估
使用同时具有内部和外部链接属性的标识符会导致未定义的行为。

|   规则    | 严重性  | 可能性  | 补救代价 | 优先级  |  级别  |
| :-----: | :--: | :--: | :--: | :--: | :--: |
| DCL36-C |  中   | 有可能  |  中   |  P8  |  L2  |

#### 3.3.4 相关指南

| 文献             | 条目                                       |
| -------------- | ---------------------------------------- |
| [MISRA C:2012] | Rule 8.2 (required) <br>Rule 8.4 (required)<br>Rule 8.8 (required)<br>Rule 17.3 (mandatory) |

### 3.4 DCL37-C 不要声明或定义保留的标识符
根据C11标准7.1.3节：
>所有以下划线开头，后面紧接着大写字母或下划线的标识符总是保留的，可以用于任何用途。
>所有以下划线开头的标识符始终保留用作文件作用域内普通或标签名空间标识符。
>除非另有明确说明，如果相关头文件被包含，以下任何子条款（包括将来的库说明）中的每个宏名称都被保留用作指定用途。
>所有具有外部链接属性（包括将来的库说明）和errno的标识符始终被保留用作外部链接标识符。
>如果相关头文件被包含，以下任何子条款中（包括将来的库说明）列出的文件作用域的每个标识符被保留作为宏名称，并且作为在同一名称空间的具有文件作用域的标识符。
>另外，子条款7.31定义了许多其他将来库说明保留的标识符。
>除上述描述之外，没有其他标识符被保留了。（POSIX标准扩展了由C标准保留的标识符集合以包括其自己的开放式集合）。在程序上下文中声明或定义保留的标识符或定义保留的标识符作为宏名称，其程序行为是未定义的。(参见[未定义行为106][未定义行为106])

#### 3.4.1 不合规代码示例（头保护）
一个常见但不合规的做法是在预处理器中使用的宏选择了保留名称，以防止头文件被重复包含。(见[PRE06-C ][PRE06-C]) 该名称可能与 C 标准库中的保留名称冲突，或者即使不包含 C 标准库也有可能与编译器隐式预定义的名称相冲突。
```cpp
#ifndef _MY_HEADER_H_
#define _MY_HEADER_H_

/* Contents of <my_header.h> */

#endif /* _MY_HEADER_H_ */
```
#### 3.4.2 合规解决方案（头保护）
这个解决方案避免了在头保护名称中使用前导下划线。
```cpp
#ifndef MY_HEADER_H
#define MY_HEADER_H

/* Contents of <my_header.h> */

#endif /* MY_HEADER_H */
```
#### 3.4.3 不合规代码示例（文件作用域对象）
在这个不合规示例中，文件作用域对象名称`_max_limit`和`_limit`都以下划线开头，因为`_max_limit`是 static 类型，这个声明看起来是不会与实现中定义的名称冲突。但是，由于类型定义`size_t`包含了头文件`<stddef.h>`，仍然存在名称冲突的可能性。（注意，编译器可能隐式声明保留名称而不管是否显示包含 C 标准库头文件。）
另外，由于`_limit`具有外部链接属性，其可能与语言运行库的符号名称相冲突，即使那个符号没有在头文件中声明。因此，即使其链接属性将其可见性限制为单个翻译单元，以下划线开头定义任何文件作用域的标识符名称也不安全。
```cpp
#include <stddef.h>
 
static const size_t _max_limit = 1024;
size_t _limit = 100;
 
unsigned int getValue(unsigned int count) {
  return count < _limit ? count : _limit;
}
```
#### 3.4.4 合规解决方案（文件作用域对象）
在这个合规解决方案中，文件作用域对象的名称不以下划线开头。
```cpp
#include <stddef.h>
 
static const size_t max_limit = 1024;
size_t limit = 100;
 
unsigned int getValue(unsigned int count) {
  return count < limit ? count : limit;
}
```
#### 3.4.5 不合规代码示例（保留宏）
在这个不合规代码示例中，因为 C 标准库头文件`<inttypes.h>`包括了`<stdint.h> `，名称`SIZE_MAX`与同样名称的标准宏冲突，它是用来表示`size_t`上限的。另外，虽然名字`INTFAST16_LIMIT_MAX`没在 C 标准库中定义，但它是一个保留的标识符，因为它始于 INT 前缀和 _MAX 结束后缀。（见C标准，7.31.10。）
```cpp
#include <inttypes.h>
#include <stdio.h>
 
static const int_fast16_t INTFAST16_LIMIT_MAX = 12000;
 
void print_fast16(int_fast16_t val) { 
  enum { SIZE_MAX = 80 };
  char buf[SIZE_MAX];
  if (INTFAST16_LIMIT_MAX < val) {
    sprintf(buf, "The value is too large");
  } else {
    snprintf(buf, SIZE_MAX, "The value is %" PRIdFAST16, val);
  }
}
```

#### 3.4.6 合规解决方案（保留宏）
此合规解决方案避免了重定义保留名称和使用保留前缀和后缀。
```cpp
#include <inttypes.h>
#include <stdio.h>
 
static const int_fast16_t MY_INTFAST16_UPPER_LIMIT = 12000;
 
void print_fast16(int_fast16_t val) {
  enum { BUFSIZE = 80 };
  char buf[BUFSIZE];
  if (MY_INTFAST16_UPPER_LIMIT < val) {
    sprintf(buf, "The value is too large");
  } else {
    snprintf(buf, BUFSIZE, "The value is %" PRIdFAST16, val);
  }
}
```
#### 3.4.7 不合规代码示例（具有外部链接的标识符）
除了在每个 C 标准库头文件中定义的函数符号，具有外部链接属性的标识符还包括`errno`和`math_errhandling`等等，而无论它们是否被相同的宏名称屏蔽。
这不合规例子重定义了 C 标准库函数`malloc()`和`free()`，虽然这种做法是在许多 UNIX 传统实现中被允许（例如，`Dmalloc`库），但根据 C 标准这是未定义的行为，即使是在允许更换`malloc()`的系统中，这样做不会同时更换`aligned_alloc()`、`calloc()`、`realloc()`，可能会导致一些问题。
```cpp
#include <stddef.h>
 
void *malloc(size_t nbytes) {
  void *ptr;
  /* Allocate storage from own pool and set ptr */
  return ptr;
}
 
void free(void *ptr) {
  /* Return storage to own pool */
}
```
#### 3.4.8 合规解决方案（具有外部链接的标识符）
这个合规解决方案，避免了重定义 C 标准库中任何具有外部链接属性的标识符，另外，它还提供了所有内存分配的功能。
```cpp
#include <stddef.h>
 
void *my_malloc(size_t nbytes) {
  void *ptr;
  /* Allocate storage from own pool and set ptr */
  return ptr;
}
 
void *my_aligned_alloc(size_t alignment, size_t size) {
  void *ptr;
  /* Allocate storage from own pool, align properly, set ptr */
  return ptr;
}
 
void *my_calloc(size_t nelems, size_t elsize) {
  void *ptr;
  /* Allocate storage from own pool, zero memory, and set ptr */
  return ptr;
}
 
void *my_realloc(void *ptr, size_t nbytes) {
  /* Reallocate storage from own pool and set ptr */
  return ptr;
}
 
void my_free(void *ptr) {
  /* Return storage to own pool */
}
```

#### 3.4.9 不合规代码示例（errno）
根据 C11 标准7.5节第2段，当`errno`宏定义被抑制或程序定义了一个名称为`errno`的标识符时，程序的行为是未定义的（见[未定义行为114][未定义行为114]）。
`errno`标识符经过扩展，左值类型可以被修改，不一定是一个对象的标识符，但必须是 int 型。它可以扩展为一个函数调用的值，如`*errno()`，`errno`不确定是一个宏还是具有外部链接声明的标识符。如果为了访问实际的宏而被抑制，或者如果一个程序定义了标识符为`errno`，那么该行为是未定义的。 
遗留代码容易包含不正确的声明，例如： 
```cpp
extern int errno;
```

#### 3.4.10 合规解决方案（errno）
正确声明`errno`的方式是包含头文件`<errno.h>`
```cpp
#include <errno.h>
```
符合 C 标准的实现应该在`<errno.h>`中声明`errno`，但也有一些历史应用没有这么做。
#### 3.4.11 例外
**DCL37-C-EX1**：如果库函数可以声明而不引用头中定义的任何类型，则可以声明该函数而不包含其头，前提是该声明与标准声明兼容。
```cpp
/* Not including stdlib.h */
void free(void *);
 
void func(void *ptr) {
  free(ptr);
}
```
这样的代码是兼容的，因为该声明匹配什么类型`stdlib.h`会提供，并不会重新定义保留的标识符。而如果在本例中定义一个`free()`函数则是不可以的。
**DCL37-C-EX2**：为了与其他编译器厂商或语言的标准模式兼容，只要行为是幂等的，创建与保留标识符相同的宏标识符是可以接受的，如本例： 
```cpp
/* Sometimes generated by configuration tools such as autoconf */
#define const const
  
/* Allowed compilers with semantically equivalent extension behavior */
#define inline __inline
```
**DCL37-C-EX3**：作为一个编译器供应商或标准库的开发者，使用预留标识符是可以接受的。保留的标识符可以由编译器在标准库头文件或标准库头文件包含的头文件中定义，如下面这个`glibc`标准 C 库实现声明所示：
```cpp
/*
  The following declarations of reserved identifiers exist in the glibc implementation of
  <stdio.h>. The original source code may be found at:
  https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=include/stdio.h;hb=HEAD
*/
  
#  define __need_size_t
#  include <stddef.h>
/* Generate a unique file name (and possibly open it).  */
extern int __path_search (char *__tmpl, size_t __tmpl_len,
              const char *__dir, const char *__pfx,
              int __try_tempdir);
```
#### 3.4.12 风险评估
使用保留的标识符可能导致错误的程序操作。

|   规则    | 严重性  | 可能性  | 补救代价 | 优先级  |  级别  |
| :-----: | :--: | :--: | :--: | :--: | :--: |
| DCL37-C |  低   | 不太可能 |  低   |  P3  |  L3  |

#### 3.4.13 相关指南

| 文献                                       | 条目                                       |
| ---------------------------------------- | ---------------------------------------- |
| [CERT C Secure Coding Standard][CERT C Secure Coding Standard] | [PRE00-C. Prefer inline or static functions to function-like macros] [PRE00-C]<br>[PRE06-C. Enclose header files in an inclusion guard][PRE06-C]<br>[PRE31-C. Avoid side effects in arguments to unsafe macros][PRE31-C] |
| [SEI CERT C++ Coding Standard][SEI CERT C++ Coding Standard] | [DCL51-CPP. Do not declare or define a reserved identifier][DCL51-CPP] |
| [ISO/IEC TS 17961][ISO/IEC TS 17961]     | Using identifiers that are reserved for the implementation [resident] |
| [MISRA C:2012]                           | Rule 21.1 (required)<br>Rule 21.2 (required) |

### 3.5 DCL38-C 声明弹性数组成员时使用正确的语法
弹性数组成员是一种特殊类型的数组，位于结构体最后一个元素，该结构体必须多于一个命名的成员，具有不完全的数组类型，也就是说，数组的大小未在结构体中明确指定。这个“struct hack”在实践中被广泛使用，并由各种编译器支持。因此，各种不同的语法来被用来声明弹性数组成员。对于符合 C 的实现，使用 C 标准保证有效的语法。 
弹性数组成员在 C11 标准 6.7.2.1 节第 18 段定义，具体如下：
>作为一个特例，具有多个命名成员的结构体的最后一个元素可以具有不完全的数组类型，这就是所谓的弹性数组成员。在大多数情况下，将忽略弹性数组成员。特别地，计算结构体的大小时将忽略弹性数组成员，就像其不存在一样，除非为了字节对齐进行后端填充。然而，当一个 “.”（或-> ）运算符具有左操作数是具有弹性数组成员的结构体，右操作数是成员名称时，它的行为就好像是该成员被不大于被访问对象的最长的数组（具有相同的元素类型）代替一样，数组的偏移将保持为弹性数组成员的偏移，即使这将与替换的数组偏移不同。如果这个数组没有元素，它的行为就好像它有一个元素，任何尝试访问该元素或生成指向该元素的指针行为都是未定义的。

具有弹性数组成员的结构体可用于产生具有定义行为的代码。但是，有一些限制： 
0. 弹性数组类型必须是在结构中的最后一个元素。 
1. 不能有包含弹性数组成员的结构体数组。 
2. 包含弹性数组成员的结构体不能用作另一个结构体的成员。 
3. 除了弹性数组成员之外，结构体必须至少包含一个命名成员。 

#### 3.5.1 不合规代码示例
在 C 标准中引入弹性数组成员之前，使用一元数组作为最终成员的结构体来实现类似的功能。 这个不合规代码示例演示了`struct flexArrayStruct`在这种情况下是如何声明的。 
这个不合规的代码示例尝试分配一个具有一个元素数组作为最后成员的类似弹性类数组成员。当该结构体被实例化时，为`malloc()`函数计算出的大小被修改为动态数组的实际大小。 
```cpp
#include <stdlib.h>

struct flexArrayStruct {
  int num;
  int data[1];
};
 
void func(size_t array_size) {
  /* Space is allocated for the struct */
  struct flexArrayStruct *structP
    = (struct flexArrayStruct *)
     malloc(sizeof(struct flexArrayStruct)
          + sizeof(int) * (array_size - 1));
  if (structP == NULL) {
    /* Handle malloc failure */
  }
   
  structP->num = array_size;
 
  /*
   * Access data[] as if it had been allocated
   * as data[array_size].
   */
  for (size_t i = 0; i < array_size; ++i) {
    structP->data[i] = 1;
  }
}
```
这个例子访问 data 数组第一个成员之后的其他元素会导致未定义的行为。（参见C标准，6.5.6章节）因此，在访问 data 数组第二个数据元素时，编译器可能生成返回非期望值的代码。 
对编译器来说，这种方法可能是尚未实现标准 C 语法的唯一替代方法。
#### 3.5.2 合规解决方案
这个合规解决方案使用弹性的阵列成员来实现动态大小的结构体：
```cpp
#include <stdlib.h>
 
struct flexArrayStruct{
  int num;
  int data[];
};
 
void func(size_t array_size) {
  /* Space is allocated for the struct */
  struct flexArrayStruct *structP 
    = (struct flexArrayStruct *)
    malloc(sizeof(struct flexArrayStruct) 
         + sizeof(int) * array_size);
  if (structP == NULL) {
    /* Handle malloc failure */
  }
 
  structP->num = array_size;
 
  /*
   * Access data[] as if it had been allocated
   * as data[array_size].
   */
  for (size_t i = 0; i < array_size; ++i) {
    structP->data[i] = 1;
  }
}
```
这个解决方案允许该结构体对待`data[]`像对待`data[array_size]`一样，都是符合 C 标准的方式。

#### 3.5.3 风险评估
声明弹性数组成员时如果使用了错误的语法会导致未定义的行为，但是不正确的语法仍可在大多数应用中工作。

|   规则    | 严重性  | 可能性  | 补救代价 | 优先级  |  级别  |
| :-----: | :--: | :--: | :--: | :--: | :--: |
| DCL38-C |  低   | 不太可能 |  低   |  P3  |  L3  |

#### 3.5.4 相关指南

| 文献                                       | 条目                                       |
| ---------------------------------------- | ---------------------------------------- |
| [CERT C Secure Coding Standard][CERT C Secure Coding Standard] | [MEM33-C Allocate and copy structures containing flexible array members dynamically][MEM33-C] |

### 3.6 DCL39-C 跨结构跨越信任边界时避免信息泄漏
C11 标准6.7.2.1讨论了结构体字段的布局，非位域成员以实现定义的方式对齐，可能在结构体内或尾部有填充字段。此外，初始化结构体的成员不保证也初始化填充字节。在 C11 标准6.2.6.1节第6段描述如下：
>当值存储在结构体或联合类型的对象（包括成员对象）中时，任何填充字节的对象取未指定的值。

另外，位字段所在的存储单元也可以具有填充位。对于具有自动存储持续时间的对象，这些填充位不采用特定值，并且可能导致泄露敏感信息。 
当指向结构体的指针跨越信任边界到不同的信任域时，程序员必须确保这种结构的填充字节和位字段存储单元填充位不包含敏感信息。

#### 3.6.1 不合规代码示例
这个不合规代码示例运行在内核空间，从 arg 拷贝数据到用户空间。结构体内可能会有填充字节，来确保结构体成员的正确对齐。这些填充字节可能包含敏感信息，然后当数据被拷贝到用户空间时可能泄漏该敏感信息。
```cpp
#include <stddef.h>
 
struct test {
  int a;
  char b;
  int c;
};
 
/* Safely copy bytes to user space */
extern int copy_to_user(void *dest, void *src, size_t size);
 
void do_stuff(void *usr_buf) {
  struct test arg = {.a = 1, .b = 2, .c = 3};
  copy_to_user(usr_buf, &arg, sizeof(arg));
}
```
#### 3.6.2 不合规代码示例（memset）
填充字节可能通过调用`memset()`被显式初始化。
```cpp
#include <string.h>
 
struct test {
  int a;
  char b;
  int c;
};
 
/* Safely copy bytes to user space */
extern int copy_to_user(void *dest, void *src, size_t size);
 
void do_stuff(void *usr_buf) {
  struct test arg;
 
  /* Set all bytes (including padding bytes) to zero */
  memset(&arg, 0, sizeof(arg));
 
  arg.a = 1;
  arg.b = 2;
  arg.c = 3;
 
  copy_to_user(usr_buf, &arg, sizeof(arg));
}
```
然而，编译器可以通过设置 32 位寄存器的低字节为 2 来实现`arg.b = 2`，而使高字节不变，然后将寄存器的所有 32 位存储到内存中。这种实现可能将寄存器中驻留的高阶字节信息泄漏给用户。

#### 3.6.3 合规解决方案
此合规解决方案在将结构体数据复制到不可信上下文之前对其序列化：
```cpp
#include <stddef.h>
#include <string.h>
 
struct test {
  int a;
  char b;
  int c;
};
 
/* Safely copy bytes to user space */
extern int copy_to_user(void *dest, void *src, size_t size);
 
void do_stuff(void *usr_buf) {
  struct test arg = {.a = 1, .b = 2, .c = 3};
  /* May be larger than strictly needed */
  unsigned char buf[sizeof(arg)];
  size_t offset = 0;
  
  memcpy(buf + offset, &arg.a, sizeof(arg.a));
  offset += sizeof(arg.a);
  memcpy(buf + offset, &arg.b, sizeof(arg.b));
  offset += sizeof(arg.b);
  memcpy(buf + offset, &arg.c, sizeof(arg.c));
  offset += sizeof(arg.c);
 
  copy_to_user(usr_buf, buf, offset /* size of info copied */);
} 
```

此代码确保没有未初始化的填充字节被复制到非特权用户空间。拷贝到用户空间的结构体是压缩结构，`copy_to_user()`函数需要将数据解压出来并重建原始的填充结构。

#### 3.6.4 合规解决方案（填充字节）
填充字节可以在结构体中显式声明为字段。这种解决方案是不可移植的，因为它依赖于实现和目标体系内存结构。 以下解决方案适用于 x86-32 体系结构：
```cpp
#include <assert.h>
#include <stddef.h>
 
struct test {
  int a;
  char b;
  char padding_1, padding_2, padding_3;
  int c;
};
 
/* Safely copy bytes to user space */
extern int copy_to_user(void *dest, void *src, size_t size);
 
void do_stuff(void *usr_buf) {
  /* Ensure c is the next byte after the last padding byte */
  static_assert(offsetof(struct test, c) ==
                offsetof(struct test, padding_3) + 1,
                "Structure contains intermediate padding");
  /* Ensure there is no trailing padding */
  static_assert(sizeof(struct test) ==
                offsetof(struct test, c) + sizeof(int),
                "Structure contains trailing padding");
  struct test arg = {.a = 1, .b = 2, .c = 3};
  arg.padding_1 = 0;
  arg.padding_2 = 0;
  arg.padding_3 = 0;
  copy_to_user(usr_buf, &arg, sizeof(arg));
}
```
C 标准`static_assert()`宏接受一个常量表达式和错误信息 。表达式将在编译时评估，如果为 false，则终止编译并输出错误消息。填充字节显式插入到 struct 中应确保编译器不会再填充额外字节，因此这两个静态断言应该为 true。然而，有必要验证这些假设以确保该解决方案对于特定实现是正确的。

#### 3.6.5 合规解决方案（结构打包 - GCC）
GCC 允许使用关键字`__attribute__((__packed__))`指定声明属性，当使用这个属性时，编译器不会为内存对齐添加填充字节，除非另有要求指定`_Alignas`对齐方式，那么编译器将尝试把字段放置在相邻的内存偏移位置。
```cpp
#include <stddef.h>
 
struct test {
  int a;
  char b;
  int c;
} __attribute__((__packed__));
 
/* Safely copy bytes to user space */
extern int copy_to_user(void *dest, void *src, size_t size);
 
void do_stuff(void *usr_buf) {
  struct test arg = {.a = 1, .b = 2, .c = 3};
  copy_to_user(usr_buf, &arg, sizeof(arg));
}
```

#### 3.6.6 合规解决方案（结构打包 - Microsoft Visual Studio）
微软的 Visual Studio 支持`#pragma pack()`来抑制填充字节。编译器根据当前的打包模式添加填充字节，但仍然支持由`__declspec(align())`指定的对齐方式。在此兼容解决方案中，打包模式设置为 1，以确保所有字段都具有相邻的偏移量：
```cpp
#include <stddef.h>
 
#pragma pack(push, 1) /* 1 byte */
struct test {
  int a;
  char b;
  int c;
};
#pragma pack(pop)
 
/* Safely copy bytes to user space */
extern int copy_to_user(void *dest, void *src, size_t size);
 
void do_stuff(void *usr_buf) {
  struct test arg = {1, 2, 3};
  copy_to_user(usr_buf, &arg, sizeof(arg));
}
```

`pack pragma`在`pragma`后第一个结构体声明时生效。

#### 3.6.7 不合规代码示例
这不合规代码示例也运行在内核空间，从`struct test`复制数据到用户空间。而这个结构体由于位字段长度加起来不到一个无符号对象长度，所以将使用填充位填充。另外，由于有一个未命名的位字段，使得不能有其他的位字段被填充到该存储单元中。这些填充位可能包含敏感信息，当数据被复制到用户空间时可能泄漏该敏感信息。例如，未初始化的位可能包含敏感的内核空间指针值，其可以由用户空间中的攻击者轻易地重构。
```cpp
#include <stddef.h>
 
struct test {
  unsigned a : 1;
  unsigned : 0;
  unsigned b : 4;
};
 
/* Safely copy bytes to user space */
extern int copy_to_user(void *dest, void *src, size_t size);
 
void do_stuff(void *usr_buf) {
  struct test arg = { .a = 1, .b = 10 };
  copy_to_user(usr_buf, &arg, sizeof(arg));
}
```
然而，编译器可以自由地通过设置一个 32 位寄存器的低字节实现初始化`arg.a`和`arg.b`，使高字节不变，然后将寄存器的所有 32 位存储到内存中。这种实现可能将寄存器中驻留的高阶字节信息泄漏给用户。

#### 3.6.8 合规解决方案
填充位可以被显式声明，允许程序员指定这些位的值。当显式声明所有的填充位时，必须从结构体中删除任何未命名长度为 0 的位字段，因为显式填充位确保了不再有额外位字段被打包进同一存储单元中。
```cpp
#include <assert.h>
#include <limits.h>
#include <stddef.h>
 
struct test {
  unsigned a : 1;
  unsigned padding1 : sizeof(unsigned) * CHAR_BIT - 1;
  unsigned b : 4;
  unsigned padding2 : sizeof(unsigned) * CHAR_BIT - 4;
};
/* Ensure that we have added the correct number of padding bits. */
static_assert(sizeof(struct test) == sizeof(unsigned) * 2,
              "Incorrect number of padding bits for type: unsigned");
 
/* Safely copy bytes to user space */
extern int copy_to_user(void *dest, void *src, size_t size);
 
void do_stuff(void *usr_buf) {
  struct test arg = { .a = 1, .padding1 = 0, .b = 10, .padding2 = 0 };
  copy_to_user(usr_buf, &arg, sizeof(arg));
}
```
这种解决方案是不可移植的，因为它取决于应用和目标存储器架构。显式插入填充位到结构体中必须确保编译器不会再插入额外的填充位。因此，仍然有必要进行检查，以确保解决方案对于特定实现是正确的。例如，DEC Alpha 是具有 32 位整数的 64 位架构的例子，其将分配 64 位给存储单元。 
此外，这种解决方案假定在一个无符号整型数里没有整数填充位。不能使用[INT35-C]规则中可移植的宽度计算版本，因为位字段宽度必须为整型常量表达式。
从上述情况可以看出，必须特别小心，因为没有位字段填充问题解决方案是 100％ 可移植的。 
#### 3.6.9 风险评估
填充单元可能包含敏感数据，因为 C 标准允许使用未指定的值填充。指向这种结构体的指针可能传递给其他函数，从而导致信息泄露。

|   规则    | 严重性  | 可能性  | 补救代价 | 优先级  |  级别  |
| :-----: | :--: | :--: | :--: | :--: | :--: |
| DCL39-C |  低   | 不太可能 |  高   |  P1  |  L3  |

##### 3.6.9.1 相关漏洞
Linux内核中的许多漏洞都是由于违反了这个规则。CVE-2010-4083 漏洞是由于 semctl() 系统调用允许非特权用户读取未初始化的内核栈内存，本地用户可以通过读取该结构体的拷贝从内核栈内存中获取潜在敏感信息。
CVE-2010-3881漏洞是由于 QEMU-KVM 中的某个数据结构体中的填充字段和保留字段在拷贝到用户空间前没有正确初始化，导致可以访问 /dev/kvm 的特权主机用户可以利用这个漏洞将内核栈内存信息泄露到用户空间。
 CVE-2010-3477 漏洞描述了 act_police 中的内核信息泄露，流量控制转储代码中没有正确初始化的结构体可能使得内核存储泄露给用户空间应用程序。
#### 3.6.10 相关指南

| 文献                                       | 条目                                       |
| ---------------------------------------- | ---------------------------------------- |
| [CERT C Secure Coding Standard][CERT C Secure Coding Standard] | [DCL03-C Use a static assertion to test the value of a constant expression] [DCL03-C] |

### 3.7 DCL40-C 不要创建与同一个函数或对象不兼容的声明
同一个函数或对象的两个或多个不兼容的声明不能出现在同一程序中，因为可能导致未定义的行为。在 C 标准6.2.7节中提到了两种类型可能不同但是是兼容的，这种情况可以被准确处理。
C标准确定，由于相同函数或对象的不兼容声明，可能导致四种情况未定义行为出现： 

| 未定义行为 | 描述                      | 示例代码                                     |
| ----- | ----------------------- | ---------------------------------------- |
| 15    | 同一对象或函数的两个声明类型是不兼容的     | 本指南中的所有不合规的示例代码                          |
| 31    | 两个标识符仅在无效字符中不同          | [超长标识符](#### 不合规代码示例（超长标识符）)             |
| 37    | 使用除了被允许的类型之外的其他类型获取对象数据 | [不兼容的对象声明](#### 不合规代码示例（不兼容的对象声明）)<br>[不兼容的数组声明](#### 不合规代码示例（不兼容的数组声明）) |
|41    |函数定义的类型与调用函数的表达式所指向的类型（表达式）不兼容。|    [不兼容的函数声明](#### 不合规代码示例（不兼容的函数声明）) <br>[超长标识符](#### 不合规代码示例（超长标识符）)

虽然出现在同一程序里两个不兼容的声明在大多数应用里可能是良性的，但是通过与函数定义类型不兼容的表达式调用函数会产生灾难性的后果。同样，用与对象类型不兼容的类型访问对象可能导信息泄露、内存覆盖或硬件陷阱。

#### 3.7.1 不合规代码示例（不兼容的对象声明）
在这个不合规的代码示例中，变量 i 在文件 a.c 中声明为 int 类型，但在文件 b.c 中却定义为 short 类型。这两个声明是不兼容的，会导致[未定义行为15][未定义行为15]。此外，在函数`f()`，使用不兼容的左值类型获取对象数据，会导致[未定义行为37][未定义行为37]，有可能导致信息暴露、内存覆盖或硬件陷阱。
```cpp
/* In a.c */
extern int i;   /* UB 15 */
 
int f(void) {
  return ++i;   /* UB 37 */
}
 
/* In b.c */
short i;   /* UB 15 */
```
#### 3.7.2 合规解决方案（不兼容的对象声明）
```cpp
/* In a.c */
extern int i;   
 
int f(void) {
  return ++i;   
}
 
/* In b.c */
int i;
```
#### 3.7.3 不合规代码示例（不兼容的数组声明）
在这个不合规的代码示例中，变量 a 在文件 a.c 中被声明为指针类型，但在文件 b.c 中却定义为数组类型。这两个声明是不兼容的，导致了[未定义行为15]。像之前一样，在函数`f()`中访问对象会导致[未定义行为37]，有可能导致信息暴露、内存覆盖或硬件陷阱。
```cpp
/* In a.c */
extern int *a;   /* UB 15 */
 
int f(unsigned int i, int x) {
  int tmp = a[i];   /* UB 37: read access */
  a[i] = x;         /* UB 37: write access */
  return tmp;
}
 
/* In b.c */
int a[] = { 1, 2, 3, 4 };   /* UB 15 */
```
#### 3.7.4 合规解决方案（不兼容的数组声明）
```cpp
/* In a.c */
extern int a[];   
 
int f(unsigned int i, int x) {
  int tmp = a[i];   
  a[i] = x;         
  return tmp;
}
 
/* In b.c */
int a[] = { 1, 2, 3, 4 };
```
#### 3.7.5 不合规代码示例（不兼容的函数声明）
在这个不合规代码示例中，函数`f()`在文件 a.c 中声明的原型与在 b.c 中定义的类型不一致。这两个原型是不兼容的，导致[未定义行为15]。此外，调用该函数是[未定义行为41]，通常具有灾难性的后果。

```cpp
/* In a.c */
extern int f(int a);   /* UB 15 */
 
int g(int a) {
  return f(a);   /* UB 41 */
}
 
/* In b.c */
long f(long a) {   /* UB 15 */
  return a * 2;
}
```
#### 3.7.6 合规解决方案（不兼容的函数声明）
```cpp
/* In a.c */
extern int f(int a);   
 
int g(int a) {
  return f(a);   
}
 
/* In b.c */
int f(int a) {   
  return a * 2;
}
```
#### 3.7.7 不合规代码示例（不兼容的可变函数声明）
在这个不合规代码示例中，函数`buginf()`被定义为含有可变数量的参数，并期望它们都是有符号整数，并以 -1 结尾。
```cpp
/* In a.c */
void buginf(const char *fmt, ...) {
   /* ... */
}
 
/* In b.c */
void buginf();
```
虽然这段代码中`buginf()`函数定义好像没有问题，只是函数原型声明中缺少了些信息，但按照 C11 标准6.7.6.3节第15段该代码会表现出未定义行为。
两个函数类型如果是兼容的，两者应指定兼容的返回类型。此外，如果两者都有参数列表，应该在参数个数和省略终止符上一致，对应参数类型应该互相兼容。 
#### 3.7.8 合规解决方案（不兼容的可变函数声明）
```cpp
/* In a.c */
void buginf(const char *fmt, ...) {
   /* ... */
}
 
/* In b.c */
void buginf(const char *fmt, ...);
```

#### 3.7.9 不合规代码示例（超长标识符）

在这个不合规代码示例中，在文件`bashline.h`中声明函数指针的标识符`bash_groupname_completion_function()`长度超过了外部标识符最长为31的限制。这引入了与在 b.c 中定义的整型变量`bash_groupname_completion_funct`碰撞的可能性，它的长度恰好是31个字符。对于恰好满足此限制的应用，这属于[未定义行为31]。这是同一个函数的两个不兼容的声明。此外，调用该函数将导致[未定义行为41]，产生典型的灾难性结果。
```cpp
/* In bashline.h */
/* UB 15, UB 31 */
extern char * bash_groupname_completion_function(const char *, int);
 
/* In a.c */
#include "bashline.h"
 
void f(const char *s, int i) {
  bash_groupname_completion_function(s, i);  /* UB 41 */
}
 
/* In b.c */
int bash_groupname_completion_funct;  /* UB 15, UB 31 */
```
注：标识符`bash_groupname_completion_function`是从 GNU Bash 3.2 版本中引用的。

#### 3.7.10 合规解决方案（超长标识符）
在这个合规解决方案中，在`bashline.h`中声明的函数指针标识符`bash_groupname_completion()`长度少于32个字符。因此，它不会与`bash_groupname_completion_funct`在任何兼容平台上产生冲突。
```cpp
/* In bashline.h */
extern char * bash_groupname_completion(const char *, int);   
 
/* In a.c */
#include "bashline.h"
 
void f(const char *s, int i) {
  bash_groupname_completion(s, i);  
}
 
/* In b.c */
int bash_groupname_completion_funct;
```
#### 3.7.11 风险评估
|   规则    | 严重性  | 可能性  | 修补成本 | 优先级  |  级别  |
| :-----: | :--: | :--: | :--: | :--: | :--: |
| DCL40-C |  低   | 不太可能 |  中   |  P2  |  L3  |

#### 3.7.12 相关指南

| 文献                                   | 条目                                       |
| ------------------------------------ | ---------------------------------------- |
| [ISO/IEC TS 17961][ISO/IEC TS 17961] | Declaring the same function or object in incompatible ways [funcdecl] |
| [MISRA C:2012]                       | Rule 8.4 (required)                      |

### 3.8 DCL41-C 不要在 switch 语句中第一个 case 标签之前声明变量
根据 C11 标准6.8.4.2节第4段：
>switch 语句根据控制表达式的值控制流程的跳转，可以跳转到、跳入或跳出有默认标签和其他标签值的主体语句。

如果程序员在第一个 case 语句之前声明变量并进行初始化，然后在 case 语句中使用，这些变量的作用域范围是在 switch 块内，但初始化语句不会被执行，因此变量将包含不确定的值。

#### 3.8.1 不合规代码示例
这个不合规代码示例在 switch 语句中第一个 case 之前声明变量并包含可执行语句。
```cpp
#include <stdio.h>
 
extern void f(int i);
 
void func(int expr) {
  switch (expr) {
    int i = 4;
    f(i);
  case 0:
    i = 17;
    /* Falls through into default code */
  default:
    printf("%d\n", i);
  }
}
```
##### 3.8.1.1 实施细节 
当这个例子在 GCC 4.8.1 上执行时，变量 i 被实例化为块内自动存储值，但没有被未初始化。因此，如果控制表达式 expr 具有非零值，则会调用`printf()`，其中 i 会是一个不确定的值。 同样地，函数`f()`也不会执行。

| Expr值 |  输出  |
| :---: | :--: |
|   0   |  17  |
|  非0   | 不确定  |

#### 3.8.2 合规解决方案
在这个合规解决方案中，将第一个 case 标签之前的语句放到 switch 语句之前。
```cpp
#include <stdio.h>
 
extern void f(int i);
 
int func(int expr) {
  /*
   * Move the code outside the switch block; now the statements
   * will get executed.
   */
  int i = 4;
  f(i);
 
  switch (expr) {
    case 0:
      i = 17;
      /* Falls through into default code */
    default:
      printf("%d\n", i);
  }
  return 0;
}
```

#### 3.8.3 风险评估
在 switch 第一个 case 语句之前使用测试条件或初始化变量可能会导致意外的行为和未定义的行为。

|   规则    | 严重性  | 可能性  | 修补成本 | 优先级  |  级别  |
| :-----: | :--: | :--: | :--: | :--: | :--: |
| DCL41-C |  中   | 不太可能 |  中   |  P4  |  L3  |

#### 3.8.4 相关指南

| 文献             | 条目                   |
| -------------- | -------------------- |
| [MISRA C:2012] | Rule 16.1 (required) |




引用链接部分，以后统一补充
[未定义行为8]: http://www.google.com/
[未定义行为9]: http://www.google.com/
[未定义行为15]: http://www.google.com/
[未定义行为37]: http://www.google.com/
[未定义行为41]: http://www.google.com/
[未定义行为106]: http://www.google.com/
[未定义行为114]: http://www.google.com/

[DCL07-C]: http://www.google.com/
[DCL51-CPP]:http://
[DCL03-C]:http://
[PRE06-C]: http://www.google.com/
[PRE00-C]:http://
[PRE31-C]:http://
[INT35-C]: http://www.google.com/
[ MSC00-C]:https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=555
[EXP54-CPP]:https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=18940064
[MEM33-C]:http://

[CERT C Secure Coding Standard]: https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=285
[SEI CERT C++ Coding Standard]:https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637
[ISO/IEC TR 24772:2013]:http://
[ISO/IEC TS 17961]:http://
[MISRA C:2012]:http://

## 4 表达式（EXP）

### 4.1 EXP30-C 不要依赖序列点之间的求值顺序
表达式的求值可能会产生副作用([side effects][])。在执行期间，前一次求值的所有副作用都已经完成，而下一个求值的所有副作用都还没有发生，这个特定位置称为序列点([sequence points][])。除非存在中间序列点，否则不要依赖表达式的求值顺序。

C 标准 6.5 节第 2 段 [[ISO/IEC 9899:2011][]]，规定：

>如果一个对象上的副作用相对于该对象上的另一副作用，或者使用该对象进行计算来讲，是无序的，其行为是未定义的。如果一个表达式的子表达式允许多种排序，在任一排序中出现了这种副作用，其行为就是未定义的。

一个完整表达式的各个子表达式必须都满足这个要求，否则，其行为就是未定义的（见[undefined behavior 35][])。

C 标准附录 C[[ISO/IEC 9899:2011][]]中定义了下面的序列点：

  - 函数指示项、函数调用实参、函数实际调用之间
  - 如下运算符的两个操作数之间：
    - 逻辑与：`&&`
    - 逻辑或：`||`
    - 逗号：`,`
  - 条件运算符`?:`的第1个操作数和后面的第2或第3个操作数之间（无论哪个会被求值）
  - 一个完整声明符的末尾
  - 一个完整表达式和下一个完整表达式之间，完整表达式如下：
      - 不是作为复合语句一部分的初始化
      - 表达式语句中的表达式
      - 选择语句中的控制表达式（`if`或`switch`）
      - `while`或`do`语句中的控制表达式
      - `for`语句中的每一个表达式（可选）
      - `return`语句中的表达式（可选）
  - 库函数返回之前
  - 每个格式化输入/输出函数转换符的操作后
  - 每次调用比较函数的之前和之后，以及将参数传递给比较函数和函数调用之间

这个规则意味着像下面这样的语句是允许的：

```cpp
i = i + 1;
a[i] = i;
```

但是，像下面这样的语句却是不允许的：

```cpp
/* i is modified twice between sequence points */
i = ++i + 1;

/* i is read other than to determine the value to be stored */
a[i++] = i;
```

在 C 代码中不是所有的逗号都代表逗号运算符。例如，调用函数时参数间的逗号并不是序列点，但是，根据 C 标准 6.5.2.2，第 10 d段[[ISO/IEC 9899:2011][]]：

>在调用函数（包括其他函数调用）时，每个没有明确在被调用函数体执行前后的求值，从被调用函数执行的角度来看，其顺序都不确定。

这个规则意味着函数调用时，参数的求值顺序是不确定的，可以是任意顺序。

#### 4.1.1 不合规代码示例

程序无法安全地依赖序列点之间操作数的求值顺序。在这个不合规代码示例中，由于没有中间序列点，`i`被求值了两次，所以表达式的行为是未定义的。

```cpp
#include <stdio.h>

void func(int i, int *b) {
  int a = i + b[++i];
  printf("%d, %d", a, i);
}
```

#### 4.1.2 合规解决方案

这些例子中，操作数的求值顺序是独立的，所以只能按照一种方式解释：

```cpp
#include <stdio.h>

void func(int i, int *b) {
  int a;
  ++i;
  a = i + b[i];
  printf("%d, %d", a, i);
}
```

或者：

```cpp
#include <stdio.h>

void func(int i, int *b) {
  int a = i + b[i + 1];
  ++i;
  printf("%d, %d", a, i);
}
```

#### 4.1.3 不合规代码示例

在该不合规代码示例中，调用`func()`具有未定义行为，因为两个参数表达式之间没有序列点:

```cpp
extern void func(int i, int j);

void f(int i) {
  func(i++, i);
}
```

第 1 个实参表达式（左）读取`i`的值（用于确定需要存储的值），并修改了`i`。第 2 个实参表达式（右）和第 1 个实参位于同一序列点之间，它也读取了`i`的值，但并不用于确定需要存储在`i`中的值。对`i`的这次额外的读取具有未定义行为。

#### 4.1.4 合规解决方案

如果程序员的意图是让`func()`的两个实参相等，则这个解决方案是适合的：

```cpp
extern void func(int i, int j);

void f(int i) {
  i++;
  func(i, i);
}
```

当程序员的意图是让`func()`的第 2 个实参比第 1 个实参大 1 时，这个解决方案是非常适合的：

```cpp
extern void func(int i, int j);

void f(int i) {
  int j = i++;
  func(j, i);
}
```

#### 4.1.5 不合规代码示例

函数参数的求值顺序是不确定的。该不合规代码示例中表现出未指定行为（[unspecified behavior][])，但不是未定义行为（ [undefined behavior][]）：

```cpp
extern void c(int i, int j);
int glob;

int a(void) {
  return glob + 10;
}

int b(void) {
  glob = 42;
  return glob;
}

void func(void) {
  c(a(), b());
}
```

`a()`和`b()`的调用顺序是不确定的，唯一能保证的是`a()`和`b()`在`c()`之前调用。像该例中，如果`a()`和`b()`在计算各自返回值时依赖于共享的状态，那么传递给`c()`的参数结果在不同的编译器或架构中将存在差异。

#### 4.1.6 合规解决方案

在该合规解决方案中，`a()`和`b()`的求值顺序是固定的，所以不会发生未指定行为：

```cpp
extern void c(int i, int j);
int glob;

int a(void) {
  return glob + 10;
}
int b(void) {
  glob = 42;
  return glob;
}

void func(void) {
  int a_val, b_val;

  a_val = a();
  b_val = b();

  c(a_val, b_val);
}
```

#### 4.1.7 风险评估

试图在序列点之间多次修改一个对象可能会导致这个对象的值出乎意料。这可能导致意外的程序行为。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP30-C | 中    | 有可能  | 中    | P8   | L2   |

#### 4.1.8 相关指南

| 标准                                       | 条目                                       |
| ---------------------------------------- | ---------------------------------------- |
| SEI CERT C++ Coding Standard             | EXP50-CPP. Do not depend on the order of evaluation for side effects |
| CERT Oracle Secure Coding Standard for Java | EXP05-J. Do not follow a write by a subsequent write or read of the same object within an expression |
| ISO/IEC TR 24772:2013                    | Operator Precedence/Order of Evaluation [JCW]<br>Side-effects and Order of Evaluation [SAM] |
| MISRA C:2012                             | Rule 12.1 (advisory)                     |

#### 4.1.9 参考文献

| 文献                      | 条目                                       |
| ----------------------- | ---------------------------------------- |
| [[ISO/IEC 9899:2011][]] | 6.5, "Expressions"<br>6.5.2.2, "Function Calls"<br>Annex C, "Sequence Points" |
| [Saks 2007]             |                                          |
| [Summit 2005]           | Questions 3.1, 3.2, 3.3, 3.3b, 3.7, 3.8, 3.9, 3.10a, 3.10b, and 3.11 |


### 4.2 EXP32-C 不要通过非 volatile 的引用来访问 volatile 对象

一个 volatile 对象在执行时可能会以多种未知的方式被修改，或者含有未知的副作用。所以，使用非 volatile 限定的左值来引用一个 volatile 对象是未定义行为。C 标准 6.7.3 [[ISO/IEC 9899:2011][]]，规定：

>如果试图使用非 volatile 限定的左值访问 volatile 对象，则该行为是未定义的。

参见未定义行为65（[undefined behavior 65][]）。

#### 4.2.1 不合规代码示例
在该不合规代码示例中，通过一个非 volatile 限定的引用访问一个 volatile 对象，导致了未定义行为：

```cpp
#include <stdio.h>

void func(void) {
  static volatile int **ipp;
  static int *ip;
  static volatile int i = 0;

  printf("i = %d.\n", i);

  ipp = &ip; /* May produce a warning diagnostic */
  ipp = (int**) &ip; /* Constraint violation; may produce a warning diagnostic */
  *ipp = &i; /* Valid */
  if (*ip != 0) { /* Valid */
    /* ... */
  }
}
```

`ipp = &ip`这个赋值是不安全的，因为它允许接下来的有效代码通过非 volatile 限定的`ip`访问 volatile 对象 i 的值。在这个例子中，编译器可能会优化掉整个 if 代码块，因为如果 ip 指向的 i 不是 volatile 的，`ip != 0`是不可能的。

#### 4.2.2 实现细节

这个例子在 Microsoft Visual Studio 2013 环境下以 C 模式（/TC）编译没有告警，但是以 C++ 模式（\TP)编译产生错误。
GCC 4.8.1 编译成功但是有告警。

#### 4.2.3 合规解决方案
在该合规解决方案中，`ip`声明为`volatile`的：

```cpp
#include <stdio.h>

void func(void) {
  static volatile int **ipp;
  static volatile int *ip;
  static volatile int i = 0;

  printf("i = %d.\n", i);

  ipp = &ip;
  *ipp = &i;
  if (*ip != 0) {
    /* ... */
  }

}
```

#### 4.2.4 风险评估

转换掉 volatile 允许通过非 volatile 引用访问一个 volatile 对象，会导致未定义行为。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP32-C | 低    | 很可能  | 中    | P6   | L2   |

#### 4.2.5 相关指南

| 标准                           | 条目                                       |
| ---------------------------- | ---------------------------------------- |
| ISO/IEC TR 24772:2013        | Pointer Casting and Pointer Type Changes [HFC]<br>Type System [IHN] |
| MISRA C:2012                 | Rule 11.8 (required)                     |
| SEI CERT C++ Coding Standard | EXP55-CPP. Do not access a cv-qualified object through a cv-unqualified type |

#### 4.2.6 参考文献

| 文献                      | 条目                       |
| ----------------------- | ------------------------ |
| [[ISO/IEC 9899:2011][]] | 6.7.3, "Type Qualifiers" |


### 4.3 EXP33-C 不要访问未初始化的内存

局部自动变量如果未初始化就使用，变量的值是不可预料的。C 标准 6.7.9 节第 10 段 [[ISO/IEC 9899:2011][]]表示：

>如果一个具有自动存储持续期的对象没有显式地进行初始化，其值是不确定的。

参见未定义行为11（[undefined behavior 11][]）。

例如，当局部自动变量保存在程序堆栈上时，它们的值默认是当前存储在堆栈内存中的值。

另外，有些负责分配动态内存的函数没有对所分配的内存进行初始化，其内容也是不确定的。

| 函数              | 初始化                  |
| --------------- | -------------------- |
| aligned_alloc() | 不执行初始化               |
| calloc()        | 初始化为0                |
| malloc()        | 不执行初始化               |
| realloc( )      | 从原始指针复制内容，可能不初始化所有内存 |

变量或动态分配的内存未经初始化，值是不确定的，对于某些类型而言，有可能是个陷阱。访问这样的陷阱就会产生不确定的行为，可能会导致程序行为不可预料，甚至导致被攻击的行为 （参见 [undefined behavior 10][] 和 [undefined behavior 12][]）。在多数情况下，编译器会对未初始化的变量产生告警（更多内容见[MSC00-C. Compile cleanly at high warning levels][] ）。

#### 4.3.1 不合规代码示例（Return-by-Reference）

在该不合规代码示例中，函数`set_flag()`的意图是根据`number`的正负情况设置参数`sign_flag`。但是，程序员忽略了`number`为`0`的情况。当调用函数`set_flag()`时，如果`number`为 0，则`sign`没有被初始化，访问`sign`可能导致不可预料的行为。

```cpp
void set_flag(int number, int *sign_flag) {
  if (NULL == sign_flag) {
    return;
  }

  if (number > 0) {
    *sign_flag = 1;
  } else if (number < 0) {
    *sign_flag = -1;
  }
}

int is_negative(int number) {
  int sign;
  set_flag(number, &sign);
  return sign < 0;
}
```

某些编译器假定，当一个未初始化的变量的地址被传递给一个函数时，这个变量会在该函数中被初始化。由于编译器常常无法诊断由于未对变量进行初始化导致的错误，因此为了保证代码的正确性，程序员必须进行额外的检查。

#### 4.3.2 合规解决方案（Return-by-Reference）

在该合规解决方案中，通过考虑`number`为 0 的情况来修正这个问题。
尽管编译器和静态分析工具经常能够检测出访问未初始化变量的代码，但是当变量初始化和使用代码不可见时，检测就变得困难或不可行。除非有某些不能接受的性能因素，声明完局部变量后立即就初始化是非常有价值的防御手段。

```cpp
void set_flag(int number, int *sign_flag) {
  if (NULL == sign_flag) {
    return;
  }

  /* Account for number being 0 */
  if (number >= 0) {
    *sign_flag = 1;
  } else {
    *sign_flag = -1;
  }
}

int is_negative(int number) {
  int sign = 0; /* Initialize for defense-in-depth */
  set_flag(number, &sign);
  return sign < 0;
}
```

#### 4.3.3 不合规代码示例（Uninitialized Local）

在该不合规代码示例中，程序员忘记在`report_error()`函数中将局部变量`error_log`设置为参数`msg`。由于`error_log`没有被初始化，值是不确定的。`sprintf()`函数从变量`error_log`（值不确定）指向的位置开始拷贝数据直到遇到一个 null byte，这就会可能导致缓冲区溢出。

```cpp
#include <stdio.h>

/* Get username and password from user, return -1 on error */
extern int do_auth(void);
enum { BUFFERSIZE = 24 };
void report_error(const char *msg) {
  const char *error_log;
  char buffer[BUFFERSIZE];

  sprintf(buffer, "Error: %s", error_log);
  printf("%s\n", buffer);
}

int main(void) {
  if (do_auth() == -1) {
    report_error("Unable to login");
  }
  return 0;
}
```

#### 4.3.4 不合规代码示例（Uninitialized Local）

在该不合规代码示例中，`report_error()`函数进行了修改，使`error_log`正确地被初始化。

```cpp
#include <stdio.h>
enum { BUFFERSIZE = 24 };
void report_error(const char *msg) {
  const char *error_log = msg;
  char buffer[BUFFERSIZE];

  sprintf(buffer, "Error: %s", error_log);
  printf("%s\n", buffer);
}
```

这个解决方案仍然存在问题，因为如果`msg`所引用的以`null`结尾的字符串长度大于 17 个字节（包括`null`结束符），仍然会发生缓冲区溢出。

#### 4.3.5 合规解决方案（Uninitialized Local）

在该合规解决方案中，通过调用`snprintf()`函数消除了缓冲区溢出。

```cpp
#include <stdio.h>
enum { BUFFERSIZE = 24 };
void report_error(const char *msg) {
  char buffer[BUFFERSIZE];

  if (0 < snprintf(buffer, BUFFERSIZE, "Error: %s", msg))
    printf("%s\n", buffer);
  else
    puts("Unknown error");
}
```

#### 4.3.6 合规解决方案（Uninitialized Local）

下面给出了一种更简单、更不容易出错，并且执行效率更高的解决方案：

```cpp
#include <stdio.h>

void report_error(const char *msg) {
  printf("Error: %s\n", msg);
}
```

#### 4.3.7 不合规代码示例（`mbstate_t`）

在该不合规代码示例中，一个`mbstate_t`对象未被适当初始化，其地址作为参数传递给函数`mbrlen()`。由于`mbrlen()`间接引用并读取了第 3 个参数，导致未定义行为200（[undefined behavior 200][]）。

```cpp
#include <string.h>
#include <wchar.h>

void func(const char *mbs) {
  size_t len;
  mbstate_t state;

  len = mbrlen(mbs, strlen(mbs), &state);
}
```

#### 4.3.8 合规解决方案（`mbstate_t`）

在作为参数传递给多字节转换函数之前，`mbstate_t`类型的对象必须被初始化为初始转换状态或者设为对应前一次多字节转换函数调用的最近转移状态（Shift State）的一个值。在该例中，`mbstate_t`对象设置为初始转换状态（全置为 0 ）：

```cpp
#include <string.h>
#include <wchar.h>

void func(const char *mbs) {
  size_t len;
  mbstate_t state;

  memset(&state, 0, sizeof(state));
  len = mbrlen(mbs, strlen(mbs), &state);
}
```

#### 4.3.9 不合规代码示例（POSIX, Entropy）

该例子（见 "[More Randomness or Less][]" [[Wang 2012][]]）中，使用进程 ID，时间，和未初始化的`junk`作为随机数生成器的种子。这种行为在某些分布式系统中（比如Debian Linux）是比较典型的，因为`junk`的值是不确定的，可以使用未初始化的内存作为熵的来源。但是，因为访问不确定的值是未定义行为，编译器可能会将未初始化变量的访问优化掉，只剩下时间和进程 ID，导致期望熵的损失。

```cpp
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/time.h>

void func(void) {
  struct timeval tv;
  unsigned long junk;

  gettimeofday(&tv, NULL);
  srandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ junk);
}
```

在依赖不可预测性的安全协议（比如 RSA）中，熵的损失会降低系统的安全性。

#### 4.3.10 合规解决方案（POSIX, Entropy）

该解决方案是使用 CPU 时钟和实时时钟来代替读取未初始化内存来生成随机数：

```cpp
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/time.h>

void func(void) {
  double cpu_time;
  struct timeval tv;

  cpu_time = ((double) clock()) / CLOCKS_PER_SEC;
  gettimeofday(&tv, NULL);
  srandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ cpu_time);
}
```

#### 4.3.11 不合规代码示例（`realloc()`）

`realloc()`函数改变动态分配内存的大小。返回内存对象最初的 size 个字节没有变化，但是新添加的空间没有初始化，其值不确定。与`malloc()`的情况类似，访问超过其原始 size 的内存是未定义行为181（ [undefined behavior 181][]）。

保证`malloc()`和`realloc()`分配的内存在使用之前被初始化是程序员的责任。

在该不合规代码示例中，使用`malloc()`分配的数组被正确地初始化。但是，数组变大时增加的内存没有被初始化，随后访问新数组未初始化部分的字节就是未定义行为。

```cpp
#include <stdlib.h>
#include <stdio.h>
enum { OLD_SIZE = 10, NEW_SIZE = 20 };

int *resize_array(int *array, size_t count) {
  if (0 == count) {
    return 0;
  }

  int *ret = (int *)realloc(array, count * sizeof(int));
  if (!ret) {
    free(array);
    return 0;
  }

  return ret;
}

void func(void) {

  int *array = (int *)malloc(OLD_SIZE * sizeof(int));
  if (0 == array) {
    /* Handle error */
  }

  for (size_t i = 0; i < OLD_SIZE; ++i) {
    array[i] = i;
  }

  array = resize_array(array, NEW_SIZE);
  if (0 == array) {
    /* Handle error */
  }

  for (size_t i = 0; i < NEW_SIZE; ++i) {
    printf("%d ", array[i]);
  }
}
```

#### 4.3.12 合规解决方案（`realloc()`）

在该合规解决方案中，`resize_array()`函数使用第 2 个参数作为数组的旧的 size，因此能够初始化任何新分配的元素：

```cpp
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

enum { OLD_SIZE = 10, NEW_SIZE = 20 };

int *resize_array(int *array, size_t old_count, size_t new_count) {
  if (0 == new_count) {
    return 0;
  }

  int *ret = (int *)realloc(array, new_count * sizeof(int));
  if (!ret) {
    free(array);
    return 0;
  }

  if (new_count > old_count) {
    memset(ret + old_count, 0, (new_count – old_count) * sizeof(int));
  }

  return ret;
}

void func(void) {

  int *array = (int *)malloc(OLD_SIZE * sizeof(int));
  if (0 == array) {
    /* Handle error */
  }

  for (size_t i = 0; i < OLD_SIZE; ++i) {
    array[i] = i;
  }

  array = resize_array(array, OLD_SIZE, NEW_SIZE);
  if (0 == array) {
    /* Handle error */
  }

  for (size_t i = 0; i < NEW_SIZE; ++i) {
    printf("%d ", array[i]);
  }
}
```

#### 4.3.13 例外

***EXP33-C-EX1:*** 通过`unsigned char`类型的左值来读取未初始化的内存不会触发未定义行为。`unsigned char`类型定义为没有陷阱，允许在不知道是否初始化的情况下移动字节（见 C 标准 6.2.6.1，第 3 段）。但是，在某些架构中，例如 Intel Itanium，寄存器专门有一个 bit 表示是否被初始化。C 标准 6.3.2.1 小节第 2 段允许这些实现对地址从未使用且存储在某个寄存器的对象，在以任何方式引用时产生一个陷阱。

#### 4.3.14 风险评估

读取未初始化的变量是未定义行为，会导致出乎意料的程序行为。在某些情况下，这些安全漏洞可能允许执行任意代码。

为了创建熵而读取未初始化变量是有疑问的做法，因为这些内存访问可能被编译器优化去除。VU#925211 是这种编码错误导致的漏洞的一个例子。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP33-C | 高    | 有可能  | 中    | P12  | L1   |


#### 4.3.15 相关指南

| 标准                            | 条目                                       |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | MSC00-C. Compile cleanly at high warning levels<br>MSC01-C. Strive for logical completeness |
| SEI CERT C++ Coding Standard  | EXP53-CPP. Do not read uninitialized memory |
| ISO/IEC TR 24772:2013         | Initialization of Variables [LAV]        |
| ISO/IEC TS 17961              | Referencing uninitialized memory [uninitref] |
| MITRE CWE                     | CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer<br>CWE-123, Write-what-where Condition<br>CWE-125, Out-of-bounds Read<br>CWE-665, Improper Initialization |


#### 4.3.16 参考文献

| 文献                    | 条目                                       |
| --------------------- | ---------------------------------------- |
| [Flake 2006]          |                                          |
| [[ISO/IEC 9899:2011]] | Subclause 6.7.9, "Initialization"<br>Subclause 6.2.6.1, "General"<br>Subclause 6.3.2.1, "Lvalues, Arrays, and Function Designators" |
| [Mercy 2006]          |                                          |
| [VU#925211]           |                                          |
| [[Wang 2012][]]       | "More Randomness or Less"                |
| [xorl 2009]           | "CVE-2009-1888: SAMBA ACLs Uninitialized Memory Read" |


### 4.4 EXP34-C 不要对null指针进行解引用

对 null 指针进行解引用是未定义行为（[undefined behavior][]）。

在许多平台上，解引用 null 指针会导致程序异常终止，但是标准中没有明确要求这一点。见 "[Clever Attack Exploits Fully-Patched Linux Kernel][]" [[Goodin 2009][]]。

#### 4.4.1 不合规代码示例

该不合规代码示例来自于一个真实的例子，原为部署于某种 ARM 手机上的`libping`库漏洞版本。`libpng`库允许应用读取、创建和操作 PNG 图片文件。该库使用自己封装的`malloc()`函数，当遇到长度为 0 或者其他错误时返回 null 指针。

该代码同时也违反了[ERR33-C 检查和处理标准库错误][]。

```cpp
#include <png.h> /* From libpng */
#include <string.h>

void func(png_structp png_ptr, int length, const void *user_data) {
  png_charp chunkdata;
  chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
  /* ... */
  memcpy(chunkdata, user_data, length);
  /* ... */
 }
```

如果`length`的值为 -1，加法的得数为 0，`png_malloc()`将返回 null 指针并赋值给`chunkdata`。随后`chunkdata`作为`memcpy()`的目的参数，导致用户定义的数据覆盖地址 0 开始的内存。在 ARM 和 XScale 的架构中，0x0 地址映射到内存中并作为异常向量表，因此，解引用 0x0 不会导致[程序异常终止][]。

#### 4.4.2 合规解决方案

该例中的解决方案是确保`png_malloc()`返回的指针不为 null，同时还通过使用无符号`size_t`来传递`length`参数，确保不会向`func()`传递负值。。

```cpp
#include <png.h> /* From libpng */
#include <string.h>

 void func(png_structp png_ptr, size_t length, const void *user_data) {
  png_charp chunkdata;
  if (length == SIZE_MAX) {
    /* Handle error */
  }
  chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
  if (NULL == chunkdata) {
    /* Handle error */
  }
  /* ... */
  memcpy(chunkdata, user_data, length);
  /* ... */

 }
```

#### 4.4.3 不合规代码示例

在该不合规代码示例中，`input_str`被拷贝到`c_str`指向的动态分配内存。如果`malloc()`失败，那`c_str`被赋值为null指针。当`memcpy()`解引用`c_str`时，程序出现未定义行为。另外，如果`input_str`是null指针，调用`strlen()`解引用null指针，也会导致未定义行为。这段代码同时还违反了[ERR33-C 检查和处理标准库错误][]。

```cpp
#include <string.h>
#include <stdlib.h>

void f(const char *input_str) {
  size_t size = strlen(input_str) + 1;
  char *c_str = (char *)malloc(size);
  memcpy(c_str, input_str, size);
  /* ... */
  free(c_str);
  c_str = NULL;
  /* ... */
}
```

#### 4.4.4 合规解决方案

该合规解决方案是要确保`input_str`和`malloc()`返回的指针不是 null：

```cpp
#include <string.h>
#include <stdlib.h>

void f(const char *input_str) {
  size_t size;
  char *c_str;

  if (NULL == input_str) {
    /* Handle error */
  }

  size = strlen(input_str) + 1;
  c_str = (char *)malloc(size);
  if (NULL == c_str) {
    /* Handle error */
  }
  memcpy(c_str, input_str, size);
  /* ... */
  free(c_str);
  c_str = NULL;
  /* ... */
}
```

#### 4.4.5 不合规代码示例

该不合规代码示例来自于 drivers/net/tun.c 的某个版本，并且对 Linux Kernel 2.6.30 造成了影响。

```cpp
static unsigned int tun_chr_poll(struct file *file, poll_table *wait)  {
  struct tun_file *tfile = file->private_data;
  struct tun_struct *tun = __tun_get(tfile);
  struct sock *sk = tun->sk;
  unsigned int mask = 0;

  if (!tun)
    return POLLERR;

  DBG(KERN_INFO "%s: tun_chr_poll\n", tun->dev->name);

  poll_wait(file, &tun->socket.wait, wait);

  if (!skb_queue_empty(&tun->readq))
    mask |= POLLIN | POLLRDNORM;

  if (sock_writeable(sk) ||
     (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&
     sock_writeable(sk)))
    mask |= POLLOUT | POLLWRNORM;

  if (tun->dev->reg_state != NETREG_REGISTERED)
    mask = POLLERR;

  tun_put(tun);
  return mask;
}
```

指针`sk`在检查`tun`是否为空之前就被初始化为`tun->sk`。由于解引用 null 指针是未定义行为，编译器（在该场景下为 GCC）可能在优化中去掉`if (!tun)`检查，因为它在`tun->sk`之后才执行，这也就意味着`tun`是非空的。因此，这段代码示例容易遭到null指针解引用攻击，因为在多个平台上可能允许 null 解引用，例如在 Linux 和 Mac OS X 上使用带有`MAP_FIXED`标志的`mmap(2)`，或者使用带有`SHM_RND`标志的`_shmat() `POSIX函数。

#### 4.4.6 合规解决方案

该合规解决方案中将`sk`的初始化放在 null 指针检查之后。

```cpp
static unsigned int tun_chr_poll(struct file *file, poll_table *wait)  {
  struct tun_file *tfile = file->private_data;
  struct tun_struct *tun = __tun_get(tfile);
  struct sock *sk;
  unsigned int mask = 0;

  if (!tun)
    return POLLERR;

  sk = tun->sk;

  /* The remaining code is omitted because it is unchanged... */

}
```

#### 4.4.7 风险评估

解引用 null 指针会导致未定义行为，通常会导致程序异常终止。在某些情况下，解引用 null 指针可能会导致任意代码的执行。这里所提示的严重性是指较严重的上述情况。在无法利用 null 指针解引用来执行任意代码的平台中，实际的严重性是较低的。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP34-C | 高    | 很可能  | 中    | P18  | L1   |


#### 4.4.8 相关指南

| 标准  | 条目 |
| -- | -- |
| CERT Oracle Secure Coding Standard for Java    | EXP01-J. Do not use a null in a case where an object is required
|ISO/IEC TR 24772:2013    | Pointer Casting and Pointer Type Changes [HFC]<br> Null Pointer Dereference [XYH] |
| ISO/IEC TS 17961 |    Dereferencing an out-of-domain pointer [nullref] |
| MITRE CWE    | CWE-476, NULL Pointer Dereference |

#### 4.4.9 参考文献

| 文献                  | 条目   |
| ------------------- | ---- |
| [[Goodin 2009][]]   |      |
| [Jack 2007]         |      |
| [Liu 2009]          |      |
| [van Sprundel 2006] |      |
| [Viega 2005]    | Section 5.2.18, "Null-Pointer Dereference"

### 4.5 EXP35-C 不要修改具有临时生命期的对象

C11 标准[[ISO/IEC 9899:2011][]]引入了一个新术语：临时生命期（temporary lifetime）。修改临时生命期的对象是未定义行为（[undefined behavior][]）。根据 6.2.4 节第 8 段：

>结构体或者联合体类型的非左值表达式中，结构体或者联合体类型包含一个引用自动存储持续期和临时生命期对象的数组类型（递归包含所有内含结构体和联合体类型成员）。它的生命期始于表达式求值，其初始值为表达式的值，生命期结束于包含的整个表达式求值或者整个声明符结束时。修改具有临时生命期的对象的任何企图都会造成未定义行为。

这个定义与 C99 标准（该标准定义，修改函数调用结果或者在下一个序列点之后访问该结果是未定义行为）不同，因为临时对象生命期在完整表达式或者完整声明符求值结束时结束，所以函数调用的结果可以访问。对临时生命期的扩展还消除了对 C90 的一个大更改，改进了与 C++ 的兼容。

C 函数可能不会返回数组；但是，函数可以返回执向数组的指针，或者包含数组的`struct`或`union`变量。因此，如果函数返回包含数组的`struct`或者`union`值，不要在包含函数调用的表达式内修改这些数组。不要在下一序列点之后，或者包含的完整表达式、完整声明符求值结束之后访问函数返回的数组。

#### 4.5.1 不合规代码示例（C99）

该不合规代码示例遵守了 C11 标准，但是不符合 C99 标准。如果以 C99 标准编译，因为`printf()`调用之前的序列点出现在参数的求值和`printf()`对返回对象中字符串的访问之间，所以当`printf()`被调用时，返回对象已经无效，导致未定义行为。

```cpp
#include <stdio.h>

struct X { char a[8]; };

struct X salutation(void) {
  struct X result = { "Hello" };
  return result;
}

struct X addressee(void) {
  struct X result = { "world" };
  return result;
}

int main(void) {
  printf("%s, %s!\n", salutation().a, addressee().a);
  return 0;
}
```

#### 4.5.2 合规解决方案

该解决方案是在调用`printf()`之前将`addressee()`返回的结构体存储下来，程序同时遵守了 C99 和 C11。

```cpp
#include <stdio.h>

struct X { char a[8]; };

struct X salutation(void) {
  struct X result = { "Hello" };
  return result;
}

struct X addressee(void) {
  struct X result = { "world" };
  return result;
}

int main(void) {
  struct X my_salutation = salutation();
  struct X my_addressee = addressee();

  printf("%s, %s!\n", my_salutation.a, my_addressee.a);
  return 0;
}
```

#### 4.5.3 不合规代码示例

该不合规代码示例中试图读取数组并递增数组的第一个元素。该数组作为函数返回的结构体中的一部分，具有临时生命期，所以修改该数组是未定义行为。

```cpp
#include <stdio.h>

struct X { int a[6]; };

struct X addressee(void) {
  struct X result = { { 1, 2, 3, 4, 5, 6 } };
  return result;
}

int main(void) {
  printf("%x", ++(addressee().a[0]));
  return 0;
}
```

#### 4.5.4 合规解决方案

解决方案是在调用`printf()`函数之前将`addressee()`返回的结构体存储在`my_x`中，当修改数组时，数组的生命期不是临时的，而是和`main()`代码块相匹配。

```cpp
#include <stdio.h>

struct X { int a[6]; };

struct X addressee(void) {
  struct X result = { { 1, 2, 3, 4, 5, 6 } };
  return result;
}

int main(void) {
  struct X my_x = addressee();
  printf("%x", ++(my_x.a[0]));
  return 0;
}
```

#### 4.5.5 风险评估

试图在数组的生命期过期后修改或访问它，会导致错误的程序行为。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP35-C | 低    | 有可能  | 中    | P4   | L3   |

#### 4.5.6 相关指南

| 标准                    | 条目                                       |
| --------------------- | ---------------------------------------- |
| ISO/IEC TR 24772:2013 | Dangling References to Stack Frames [DCM]<br>Side-effects and Order of Evaluation [SAM] |

#### 4.5.7 参考文献

| 文献                      | 条目                                    |
| ----------------------- | ------------------------------------- |
| [[ISO/IEC 9899:2011][]] | 6.2.4, "Storage Durations of Objects" |

### 4.6 EXP36-C 不要将指针转换为对齐要求更严格的指针类型

不要将指针转换为对齐要求更严格的指针类型。不同的对象类型可能具有不同的对齐要求。如果类型检查系统被明确的类型转换所覆盖，或者指针被转换为`void`指针（`void *`），然后又转换为不同的类型，对象的对齐可能改变。

C 标准 6.3.2.3 节第 7 段[[ISO/IEC 9899:2011][]]规定：

>指向对象或不完整类型的指针可以被转换为指向不同对象或不完整类型的指针。如果结果指针与所引用的类型没有正确对齐，则该行为是未定义的。

见未定义行为25（[undefined behavior 25][]）。

解引用这种未对齐的指针，程序可能会异常终止。在某些架构中，如果涉及到的类型有不同的对齐要求，即使转换后的值没有被解析，也可能会造成丢失信息。

#### 4.6.1 不合规代码示例

在该不合规代码示例中，指针`&c`被转换为对齐更严格的`int`型指针`ip`。在某些场景下，`ip`与`&c`并不匹配。所以，如果指向某种类型的指针被转换成指向另一种类型的指针，第二种类型的对齐要求不能比第一种类型更严格。

```cpp
#include <assert.h>

void func(void) {
  char c = 'x';
  int *ip = (int *)&c; /* This can lose information */
  char *cp = (char *)ip;

  /* Will fail on some conforming implementations */
  assert(cp == &c);
}
```

#### 4.6.2 合规解决方案

在该合规解决方案中，`char`类型的值存储在`int`类型的变量中，所以指针指向的值能正确地对齐：

```cpp
#include <assert.h>

void func(void) {
  char c = 'x';
  int i = c;
  int *ip = &i;

  assert(ip == &i);
}
```

#### 4.6.3 不合规代码示例

C 标准允许任意对象指针与`void*`互换。因此，有可能把一种类型的指针存储或转换为`void*`，然后再存储或转换为另一种类型的指针，而编译器并不能诊断出其中的问题。在该不合规代码示例中，传给`loop_function()`的是`char`类型指针`loop_ptr`，但是返回了一个`int`类型的指针：

```cpp
int *loop_function(void *v_pointer) {
  /* ... */
  return v_pointer;
}
 
void func(char *loop_ptr) {
  int *int_ptr = loop_function(loop_ptr);

  /* ... */
}
```

该例在 Ubuntu Linux 中使用 GCC 4.8 编译没有产生告警，但是，`v_pointer`可能比`int *`类型的对象对齐要更加严格。

#### 4.6.4 合规解决方案

由于输入参数直接影响返回值，并且`loop_function()`返回一个`int *`，因此重新声明形式参数`v_pointer`只接受`int *`类型的对象。

```cpp
int *loop_function(int *v_pointer) {
  /* ... */
  return v_pointer;
}

void func(int *loop_ptr) {
  int *int_ptr = loop_function(loop_ptr);

  /* ... */
}
```

#### 4.6.5 不合规代码示例

有些架构要求访问大于一个字节的对象时指针要正确地对齐。但是，在系统代码中将未对齐的数据（例如网络栈）拷贝到正常对齐的内存位置是很常见的，例如下面的代码：

```cpp
#include <string.h>

struct foo_header {
  int len;
  /* ... */
};

void func(char *data, size_t offset) {
  struct foo_header *tmp;
  struct foo_header header;

  tmp = (struct foo_header *)(data + offset);
  memcpy(&header, tmp, sizeof(header));

  /* ... */
}
```

将未对齐的值对齐到引用需要对齐类型的指针，是未定义行为。例如，实现可能注意到`tmp`和`header`必须对齐，于是使用内联的`memcpy()`，在该函数中使用假定已对齐数据的指令。

#### 4.6.6 合规解决方案

在合规解决方案中避免使用`foo_header`指针。

```cpp
#include <string.h>
 
struct foo_header {
  int len;
  /* ... */
};
  
void func(char *data, size_t offset) {
  struct foo_header header; 
  memcpy(&header, data + offset, sizeof(header));

  /* ... */
}
```

#### 4.6.7 例外

**EXP36-C-EX1:** 有些硬件架构对指针对齐要求比较宽松。没有正确对齐的指针可以由架构正确处理，但是可能会造成性能的损失。因此，这样的架构虽然允许指针未对齐，但是会存在效率问题。

**EXP36-C-EX2**: 如果一个指针已与目标类型正确对齐，那到目的类型的转换就是被允许的。我们知道的有几种场景中指针是被正确对齐的，比如一个指向有对齐限定符修饰的对象的指针。按照 C 标准 7.22.3 第 1 段[[ISO/IEC 9899:2011][]]，它可以指向`aligned_alloc()`，`calloc()`，`malloc()`或`realloc()`返回的对象。

该例中使用了对齐限定符，声明`char`对象和`int`类型的对象对齐方式一样。所以，两个指针引用了对齐等价的指针类型：

```cpp
#include <stdalign.h>
#include <assert.h>

void func(void) {
  /* Align c to the alignment of an int */
  alignas(int) char c = 'x';
  int *ip = (int *)&c;
  char *cp = (char *)ip;
  /* Both cp and &c point to equally aligned objects */
  assert(cp == &c);
}
```

#### 4.6.8 风险评估

访问没有正常对齐的指针或者对象，可能造成程序崩溃或者提供错误的信息，或者导致指针的访问变慢（如果计算机架构允许错误对齐的访问）。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP36-C | 低    | 有可能  | 中    | P4   | L3   |

#### 4.6.9 相关指南

| 标准                           | 条目                                       |
| ---------------------------- | ---------------------------------------- |
| SEI CERT C++ Coding Standard | VOID EXP56-CPP. Do not cast pointers into more strictly aligned pointer types |
| ISO/IEC TR 24772:2013        | Pointer Casting and Pointer Type Changes [HFC] |
| ISO/IEC TS 17961             | Converting pointer values to more strictly aligned pointer types [alignconv] |
| MISRA C:2012                 | Rule 11.1 (required)<br>Rule 11.2 (required)<br>Rule 11.5 (advisory)<br>Rule 11.7 (required) |

#### 4.6.10 参考文献

| 文献                    | 条目                                  |
| --------------------- | ----------------------------------- |
| [Bryant 2003]         |                                     |
| [[ISO/IEC 9899:2011]] | 6.3.2.3, "Pointers"                 |
| [Walfridsson 2003]    | Aliasing, Pointer Casts and GCC 3.3 |


### 4.7 EXP37-C 调用函数时使用正确的参数数目和类型

不要用错误的参数数目或类型来调用函数。

C 语言标准确定了 5 种不同情况，在这 5 种情况中，调用函数声明与其定义不符、提供参数类型或者数量错误可能造成未定义行为（[undefined behavior][]，UB）：

| UB   | 描述                                       |
| ---- | ---------------------------------------- |
| 26   | *使用指针调用类型与指针引用类型不兼容的函数（6.3.2.3）*         |
| 38   | *调用函数时没有使用作用域中的原型，实参数量不等于形参数量（6.5.2.2）*  |
| 39   | *调用函数时，没有使用定义函数原型的作用域中的函数原型，原型以括号结束或者提升之后的实参类型与形参类型不兼容* |
| 40   | *调用函数时，没有使用函数未定义原型的作用域中的函数原型，提升后的实参类型与提升后的形参类型不兼容，有某些例外情况* |
| 41   | *函数定义类型与表示被调用函数的表达式指向的（表达式）类型不兼容*        |

正常声明的函数如果得到错误数量或者类型的参数，通常会产生一条编译程序诊断消息。然而，有些情况下向函数提供不正确的参数最多只会产生编译程序警告。尽管这些警告应该得到解决，但是它们不会阻止程序编译。（参见“ [MSC00-C. Compile cleanly at high warning levels][]”）

#### 4.7.1 不合规代码示例

`<tgmath.h>`头文件为数学函数提供泛型宏。尽管头文件`<math.h>`中的大部分函数在`<complex.h>`中有等价的复数版本，但是仍有部分函数没有。使用复数来调用下表中的泛型函数就是未定义行为。

**Functions That Should Not Be Called with Complex Values**

| atan2()    | erf()   | fdim()  | fmin()  | ilogb()  | llround() | logb()      | nextafter()  | rint()    | tgamma() |
| ---------- | ------- | ------- | ------- | -------- | --------- | ----------- | ------------ | --------- | -------- |
| cbrt()     | erfc()  | floor() | fmod()  | ldexp()  | log10()   | lrint()     | nexttoward() | round()   | trunc()  |
| ceil()     | exp2()  | fma()   | frexp() | lgamma() | log1p()   | lround()    | remainder()  | scalbn()  |          |
| copysign() | expm1() | fmax()  | hypot() | llrint() | log2()    | nearbyint() | remquo()     | scalbln() |          |

该示例中试图用`log2()`函数对复数进行计算，导致了未定义行为：

```cpp
#include <tgmath.h>

void func(void) {
  double complex c = 2.0 + 4.0 * I;
  double complex result = log2(c);
}
```

#### 4.7.2 合规解决方案（Complex Number）

如果函数`clog2()`不能扩展到复数，程序员可以使用`log()`来代替`log2()`实现对复数求对数，因为`log()`可以使用复数作为参数，例如下面的代码：

```cpp
#include <tgmath.h>

void func(void) {
  double complex c = 2.0 + 4.0 * I;
  double complex result = log(c)/log(2);
}
```

#### 4.7.3 合规解决方案（Real Number）

如果程序员的意图是对复数的实数部分求以 2 为底的对数，可以使用下面的方案：

```cpp
#include <tgmath.h>

void func(void) {
  double complex c = 2.0 + 4.0 * I;
  double complex result = log2(creal(c));
}
```

#### 4.7.4 不合规代码示例

在该不合格示例中，通过函数指针 fp 来调用 C 语言标准库函数`strchr()`，但是 fp 声明的原型中参数类型不正确。根据 C 标准 6.3.2.3 第 8 段 [[ISO/IEC 9899:2011][]]：

> 指向某个类型的函数的指针可能转换为指向另一个类型函数的指针，然后复原，其结果应该与原始指针相同。如果转换后的指针用来调用与引用类型不符的函数，其行为就是未定义的。

见未定义行为26（[undefined behavior 26][]）。

```cpp
#include <stdio.h>
#include <string.h>

char *(*fp)();

int main(void) {
  const char *c;
  fp = strchr;
  c = fp('e', "Hello");
  printf("%s\n", c);
  return 0;
}
```

#### 4.7.5 合规解决方案

在该合规解决方案中，函数指针`fp`指向 C 语言标准库函数`strchr()`，声明了正确的参数，并且用正确数量和类型的实际参数调用：：

```cpp
#include <stdio.h>
#include <string.h>

char *(*fp)(const char *, int);

int main(void) {
  const char *c;
  fp = strchr;
  c = fp("Hello",'e');
  printf("%s\n", c);
  return 0;
}
```

#### 4.7.6 不合规代码示例

在该示例中，函数`f()`定义为使用`long`类型的参数，但是在另一文件中调用`f()`时使用了`int`类型的参数：

```cpp
/* In another source file */
long f(long x) {
  return x < 0 ? -x : x;
}

/* In this source file, no f prototype in scope */
long f();

long g(int x) {
  return f(x);
}
```

#### 4.7.7 合规解决方案

在该合规解决方案中，函数`f()`的原型包含在被调用的作用域的源文件中，而且用`long`类型的参数正确调用函数：

```cpp
/* In another source file */

long f(long x) {
  return x < 0 ? -x : x;
}

/* f prototype in scope in this source file */

long f(long x);

long g(int x) {
  return f((long)x);
}
```

#### 4.7.8 不合规代码示例（POSIX）

POSIX 函数`open()` [[IEEE Std 1003.1:2013][]]是可变参数函数，原型如下：

```cpp
int open(const char *path, int oflag, ... );
```

`open()`函数接受的第三个参数，用来确定新创建文件的访问模式。如果`open()`用于创建新文件，且第三个参数被忽略，则创建的文件可能具有意外的访问权限。（参见 [FIO06-C. Create files with appropriate access permissions][]）

该示例来自 [CVE-2006-1174 shadow-utils][] 包的`useradd()`函数中的一个漏洞，`open()`的第三个参数被意外地忽略了：

```cpp
fd = open(ms, O_CREAT | O_EXCL | O_WRONLY | O_TRUNC);
```

注意，从技术上说，在不创建新文件时（也就是不设置`O_CREAT`标志），向`open()`传递第三个参数是不正确的。

#### 4.7.9 合规解决方案（POSIX）

在该解决方案中，调`open()`时指定第三个参数：

```cpp
#include <fcntl.h>

void func(const char *ms, mode_t perms) {
  /* ... */
  int fd;
  fd = open(ms, O_CREAT | O_EXCL | O_WRONLY | O_TRUNC, perms);
  if (fd == -1) {
    /* Handle error */
  }
}
```

#### 4.7.10 风险评估

以不正确的参数调用函数可能造成意外的程序行为。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP37-C | 中    | 有可能  | 高    | P4   | L3   |

#### 4.7.11 相关指南

| 标准                            | 条目                                       |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | DCL07-C. Include the appropriate type information in function declarators<br>MSC00-C. Compile cleanly at high warning levels<br>FIO06-C. Create files with appropriate access permissions |
| ISO/IEC TR 24772:2013         | Subprogram Signature Mismatch [OTR]      |
| ISO/IEC TS 17961              | Calling functions with incorrect arguments [argcomp] |
| MISRA C:2012                  | Rule 8.2 (required)<br>Rule 17.3 (mandatory) |
| MITRE CWE                     | CWE-628, Function Call with Incorrectly Specified Arguments<br>CWE-686, Function Call with Incorrect Argument Type |

#### 4.7.12 参考文献

| 文献                       | 条目                                       |
| ------------------------ | ---------------------------------------- |
| [CVE]    CVE-2006-1174      |                                          |
| [[ISO/IEC 9899:2011]]    | 6.3.2.3, "Pointers"<br>6.5.2.2, "Function Calls" |
| [[IEEE Std 1003.1:2013]] | open()                                   |
| [Spinellis 2006]         | Section 2.6.1, "Incorrect Routine or Arguments" |


### 4.8 EXP39-C 不要通过不兼容类型的指针访问变量

通过不兼容类型的指针（除`unsigned char`之外）修改一个变量，可能导致不可预测的结果。C 语言标准的 6.2.7 小节规定，两个类型可以完全不同但是兼容，当两个截然不同的类型相互兼容时可以准确地处理。

这个问题往往是由违反别名规则造成的。C 语言标准 6.5 第 7 段[[ISO/IEC 9899:2011][]]规定了如下情况，对象可能使用别名，也可能不使用别名：

>对象的存储值只能由具有如下类型之一的左值表达式访问：
  * 与对象有效类型兼容的类型
  * 与对象有效类型兼容的类型的限定版本
  * 对应对象有效类型的有符号或者无符号类型
  * 对应对象有效类型限定版本的有符号或者无符号类型
  * 成员包含前述类型之一的聚合或者联合体类型（包含各级子聚合或者所包含各级联合体类型的某个成员）
  * 字符类型

通过任何左值（[lvalue][]）表达式（除了`unsigned char`之外）访问对象是未定义行为37（[undefined behavior 37][]）。

#### 4.8.1 不合规代码示例

在该不合规代码示例中，`float`类型对象通过`int *`来实现递增。程序员可以在最后使用该单元获取浮点类型的下一个可表示值。但是，通过不兼容类型的指针访问对象是未定义行为。

```cpp
#include <stdio.h>

void f(void) {
  if (sizeof(int) == sizeof(float)) {
    float f = 0.0f;
    int *ip = (int *)&f;
    (*ip)++;
    printf("float is %f\n", f);
  }
}
```

#### 4.8.2 合规解决方案

在该合规解决方案中，标准 C 函数`nextafterf()`用于返回下一个可表示的浮点值（最大为 FLT_MAX）：

```cpp
#include <float.h>
#include <math.h>
#include <stdio.h>

void f(void) {
  float f = 0.0f;
  f = nextafterf(f, FLT_MAX);
  printf("float is %f\n", f);
}
```

#### 4.8.3 不合规代码示例

在该不合规示例中，一个由两个`short`类型值组成的数组被当作一个整数，并赋予一个整数值。结果值不确定。

```cpp
#include <stdio.h>

void func(void) {
  short a[2];
  a[0]=0x1111;
  a[1]=0x1111;

  *(int *)a = 0x22222222;

  printf("%x %x\n", a[0], a[1]);
}
```

翻译这段代码时，C 语言实现可能假定通过整数指针访问不会改变包含短整数的数组`a`。因此，`printf()`可能以`a[0]`和`a[1]`的原始值调用。

#### 4.8.4 实现细节

最新的 GCC 版本打开了`-fstrict-aliasing`选项，`-O2`默认允许基于别名的优化。一些架构中打印的结果是"1111 1111"。当没有优化时，可执行文件生成预期的输出“2222 2222”。`-Wall`中的选项`-Wstrict-aliasing`，在`-fstrict-aliasing`激活时可以产生部分警告，但不是全部。

对于遗留的错误错误代码，可以使用`-fno-strict-aliasing`选项来去使能基于别名的优化。

使用 GCC 3.4.6 优化编译这段代码，能有效消除通过指针别名的赋值。

#### 4.8.5 合规解决方案

该解决方案使用一个`union`类型，包含与对象有效类型兼容的类型：

```cpp
#include <stdio.h>

void func(void) {
  union {
    short a[2];
    int i;
  } u;

  u.a[0]=0x1111;
  u.a[1]=0x1111;
  u.i = 0x22222222;

  printf("%x %x\n", u.a[0], u.a[1]);

  /* ... */
}
```

上述合规解决方案中`printf()`的行为没有指定，但是作为实现的扩展这常常是可以接受的（见[unspecified behavior 11][]）。

这个函数一般会输出`“2222 2222”`。但是，不能保证能得到这个结果，即使在定义了这种未指定行为的实现上也是如此；`short`值的表现形式不需要和`int`类型值相同。

#### 4.8.6 不合规代码示例

在该不合规示例中，分配一个`gadget`对象，然后调用`realloc()`，使用`gadget`对象中的内存创建`widget`对象。尽管重用内存以改变类型是可以接受的，但是访问从原始对象复制的内存是未定义行为：

```cpp
#include <stdlib.h>

struct gadget {
  int i;
  double d;
  char *p;
};

struct widget {
  char *q;
  int j;
  double e;
};

void func(void) {
  struct gadget *gp;
  struct widget *wp;

  gp = (struct gadget *)malloc(sizeof(struct gadget));
  if (!gp) {
    /* Handle error */
  }
  /* ... Initialize gadget ... */
  wp = (struct widget *)realloc(gp, sizeof(struct widget));
  if (!wp) {
    free(gp);
    /* Handle error */
  }
  if (wp->j == 12) {
    /* ... */
  }
}
```

#### 4.8.7 合规解决方案

该合规解决方案重用来自`gadget`对象的内存，但是在读取之前将内存重新初始化为一致状态：

```cpp
#include <stdlib.h>
#include <string.h>

struct gadget {
  int i;
  double d;
  char *p;
};

struct widget {
  char *q;
  int j;
  double e;
};

void func(void) {
  struct gadget *gp;
  struct widget *wp;

  gp = (struct gadget *)malloc(sizeof (struct gadget));
  if (!gp) {
    /* Handle error */
  }
  /* ... */
  wp = (struct widget *)realloc(gp, sizeof(struct widget));
  if (!wp) {
    free(gp);
    /* Handle error */
  }
  memset(wp, 0, sizeof(struct widget));
  /* ... Initialize widget ... */

  if (wp->j == 12) {
    /* ... */
  }
}
```

#### 4.8.8 不合规代码示例

根据 C 语言标准 6.7.6.2 小节 [[ISO/IEC 9899:2011][]]，在一个表达式中使用两个或者更多不兼容的数组是[未定义行为][]。（见[undefined behavior 76][]）

两个类型兼容的数组应该有兼容的底层元素类型，两者的大小指示符应该有相同的常数值。违反这两个中的任何一个，都会造成未定义行为。

在不合规代码示例中，数组`a`和`b`不满足数组兼容性的相同大小指示符条件。因为`a`和`b`不相等，对`a`中应该为有效成员的元素进行写入操作，可能超出定义的内存边界，造成任意内存覆盖：

```cpp
enum { ROWS = 10, COLS = 15 };

void func(void) {
  int a[ROWS][COLS];
  int (*b)[ROWS] = a;
}
```

大多数编译器在一个表达式中出现两个不兼容数组的时候会产生告警。

#### 4.8.9 合规解决方案

在该合规解决方案中，`b`声明为一个指针，指向和`a`有相同数量元素的一个数组，满足数组兼容性的大小指示符条件：

```cpp
enum { ROWS = 10, COLS = 15 };

void func(void) {
  int a[ROWS][COLS];
  int (*b)[COLS] = a;
}
```

#### 4.8.10 风险评估

性能优化可能造成难以检测的别名错误。而且，正如前一个例子中那样，不可预期的结果可能造成缓冲区溢出攻击、绕过安全性检查或者不可预期的执行。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP39-C | 中    | 不太可能 | 高    | P2   | L3   |

#### 4.8.11 相关指南

| 标准               | 条目                                       |
| ---------------- | ---------------------------------------- |
| ISO/IEC TS 17961 | Accessing an object through a pointer to an incompatible type [ptrcomp] |
| MITRE CWE        | CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer<br>CWE-123, Write-what-where Condition<br>CWE-125, Out-of-bounds Read |

#### 4.8.12 参考文献

| 文献           | 条目                              |
| ------------ | ------------------------------- |
| [Acton 2006] | "Understanding Strict Aliasing" |
| GCC Known Bugs    | "C Bugs, Aliasing Issues while Casting to Incompatible Types"
| [[ISO/IEC 9899:2011]]    | 6.5, "Expressions"<br>6.7.6.2, "Array Declarators" |
| [Walfridsson 2003]    | Aliasing, Pointer Casts and GCC 3.3 |


### 4.9 EXP40-C 不要修改常量对象

C 标准 6.7.3 第 6 段[[ISO/IEC 9899:2011][]]，规定：

>如果试图通过非 const 限定的左值来修改 const 限定的对象，其行为就是未定义的。

见未定义行为64（[undefined behavior 64][]）。

有些编译器允许修改 const 限定的对象，而不会产生告警。

要避免转换掉 const 限定符，因为这会导致修改 const 限定的对象而不产生诊断告警。（更多细节见 [EXP05-C. Do not cast away a const qualification][]，以及 [STR30-C. Do not attempt to modify string literals][] ）

#### 4.9.1 不合规代码示例

该不合规代码示例允许修改常量对象：

```cpp
const int **ipp;
int *ip;
const int i = 42;

void func(void) {
  ipp = &ip; /* Constraint violation */
  *ipp = &i; /* Valid */
  *ip = 0;   /* Modifies constant i (was 42) */
}
```

第一条赋值语句是不安全的，因为它允许后续的代码尝试修改常量对象`i`的值。

#### 4.9.2 实现细节

如果`ipp`，`ip`和`i`声明为自动变量，该例在 Microsoft Visual Studio 2013 环境下以 C 模式编译不产生告警，且程序结果是修改了`i`的值。GCC 4.8.1 编译时产生了告警，但程序结果还是修改了`i`的值。

如果`ipp`，`ip`和`i`声明为静态存储变量，该程序在 Microsoft Visual Studio 2013 环境中不会产生告警并异常终止，在 GCC 4.8.1 中编译产生告警并异常终止。

#### 4.9.3 合规解决方案

合规解决方案取决于程序员的意图。如果认为`i`是可修改的，则解决方案是不应把`i`声明为常量：

```cpp
int **ipp;
int *ip;
int i = 42;

void func(void) {
  ipp = &ip; /* Valid */
  *ipp = &i; /* Valid */
  *ip = 0; /* Valid */
}
```

如果认为i不能被修改，则就不应该编写试图修改`i`的代码。

#### 4.9.4 风险评估

通过非常量引用来修改常量对象是未定义行为。

| 规则      | 安全性  | 可能性  | 修补成本 | 优先级  | 级别   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP40-C | 低    | 不太可能 | 中    | P2   | L3   |

#### 4.9.5 相关指南

| 标准                            | 条目                                       |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | EXP05-C. Do not cast away a const qualification<br>STR30-C. Do not attempt to modify string literals |

#### 4.9.6 参考文献

| 文献                      | 条目                                 |
| ----------------------- | ---------------------------------- |
| [[ISO/IEC 9899:2011][]] | Subclause 6.7.3, "Type Qualifiers" |

### 4.10 EXP42-C 不要比较填充数据

C 标准 6.7.2.1 [[ISO/IEC 9899:2011][]]规定：

>在结构体对象中可能存在未命名的填充字段，但其并不位于结构体的起始处...在结构体或联合体的尾部可能存在未命名的填充字段。

6.7.9 小节，第 9 段规定：

>结构体和联合体中的未命名成员不参与初始化。未命名成员即使在初始化之后，值也是不确定的。

唯一的例外是当静态或线程局部对象被隐式初始化时，填充位被置为零（第 10 段）：

>如果一个自动存储期的对象没有被显式地初始化，其值是不确定的。如果一个静态或线程存储期的对象没有被显式初始化，则：
   - 如果是聚合类型，则各个成员根据这些规则初始化（递归），并且将任意填充位初始化为零；
   - 如果是联合体，则第一个命名成员根据这些规则初始化（递归），并且将任意填充位初始化为零；

因为这些填充值是不确定的，试图按逐字节比较结构体会导致不正确的结果。

#### 4.10.1 不合规代码示例

在该不合规代码示例中，`memcmp()`用来比较两个结构体的内容，其中包括填充字节：

```cpp
#include <string.h>

struct s {
  char c;
  int i;
  char buffer[13];
};

void compare(const struct s *left, const struct s *right) {
  if (0 == memcmp(left, right, sizeof(struct s))) {
    /* ... */
  }
}
```

#### 4.10.2 合规解决方案

在该合规解决方案中，人工比较各个字段，避免了填充字节的比较：

```cpp
#include <string.h>

struct s {
  char c;
  int i;
  char buffer[13];
};

void compare(const struct s *left, const struct s *right) {
  if ((left && right) &&
      (left->c == right->c) &&
      (left->i == right->i) &&
      (0 == memcmp(left->buffer, right->buffer, 13))) {
    /* ... */
  }
}
```

#### 4.10.3 例外

**EXP42-C-EX1**: 结构体可以被定义成各个成员正确对齐，或者使用特定的 packing 指令来保证对齐。但是这只有在成员数据类型本身不含填充位且它们的对象表示和值表示相同的情况下才成立。对于`_Bool`或浮点类型，往往不成立，对于指针类型也不一定成立。在这种情况下，编译器不会插入填充位，使用类似`memcmp()`之类的函数是可以接受的。

该例中使用来自 Microsoft Visual Studio 的`#pragma pack`编译程序扩展，保证结构体成员尽可能排列紧凑：

```cpp
#include <string.h>

#pragma pack(push, 1)
struct s {
  char c;
  int i;
  char buffer[13];
};
#pragma pack(pop)

void compare(const struct s *left, const struct s *right) {
  if (0 == memcmp(left, right, sizeof(struct s))) {
    /* ... */
  }
}
```

#### 4.10.4 风险评估

比较填充字节会导致不可预料的程序行为。

| 规则      | 安全性  | 可能性  | 修补成本 | 优先级  | 级别   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP42-C | 中    | 有可能  | 中    | P8   | L2   |

#### 4.10.5 相关指南

| 标准                           | 条目                                       |
| ---------------------------- | ---------------------------------------- |
| ISO/IEC TS 17961             | Comparison of padding data [padcomp]     |
| SEI CERT C++ Coding Standard | EXP62-CPP. Do not access the bits of an object representation that are not part of the object's value representation |

#### 4.10.6 参考文献

| 文献                      | 条目                                       |
| ----------------------- | ---------------------------------------- |
| [[ISO/IEC 9899:2011][]] | 6.7.2.1, "Structure and Union Specifiers"<br>6.7.9, "Initialization" |
| [Summit 1995]           | Question 2.8 <br>Question 2.12           |


### 4.11 EXP43-C 使用restrict限定的指针时避免未定义行为

通过`restrict`限定指针访问的对象和指针有特殊的关联。这种关联要求对该对象的所有访问（直接或者间接）使用这个特殊指针的值。使用`restrict`限定符的意图是促进优化，从某个程序中删除所有该限定符的实例不会改变其意义（也就是可观测行为）。不使用该限定符时，其他指针可以作为该对象的别名。在指针声明所在块的开始处通过`restrict`限定指针缓存对象的值是安全的，因为没有预先存在的别名用于引用该对象。缓存的值必须在块结束时恢复到对象上，此时预先存在的别名再次变为可用。在块中可能形成新的别名，但是这些别名都必须依赖于`restrict`限定的指针值，所以它们可以被识别出并调整为引用缓存值。对于文件作用域的`restrict`限定指针，该块是文件中每个函数的主体[[Walls 2006][]]。开发人员应该知道，`C++`不支持`restrict`限定符，但是某些`C++`编译器实现作为扩展支持等价的限定符。

C  标准 [[ISO/IEC 9899:2011][]]规定了如下未定义行为（[undefined behavior][]）：

> `restrict`限定的指针根据另一个限定指针赋值，后者的相关块没有在与前者关联的块之前执行，也没有在赋值之前结束（6.7.3.1）

标准的定义太过简单，所以一定要回顾 C 语言标准 6.7.3.1 小节中`restrict`的正式定义，正确地理解`restrict`限定指针使用时的未定义行为。

#### 4.11.1 重叠对象

`restrict`限定符要求指针不引用重叠对象。如果函数参数引用的对象重叠（即对象共享一些共同的内存地址），则该行为是未定义的。

##### 4.11.1.1 不合规代码示例

该段代码由于在相同的作用域内，进行了两个`restrict`限定的指针间的赋值，是不正确的。

```cpp
int *restrict a;
int *restrict b;

extern int c[];

int main(void) {
  c[0] = 17;
  c[1] = 18;
  a = &c[0];
  b = &c[1];
  a = b; /* Undefined behavior */
  /* ... */
}
```

注意，未定义行为只发生在将`b`的值赋予`a`时。如果通过一个指针访问的元素与通过另一个指针访问的元素范围不重叠，`a`和`b`指向相同数组对象是有效的。

##### 4.11.1.2 合规解决方案

消除未定义行为的方法之一是直接将受影响的指针删除`restrict`限定符。

```cpp
int *a;
int *b;

extern int c[];

int main(void) {
  c[0] = 17;
  c[1] = 18;
  a = &c[0];
  b = &c[1];
  a = b; /* Defined behavior */
  /* ... */
}
```

#### 4.11.2 带`restrict`限定符的函数参数

调用具有`restrict`限定参数的函数时，如果使用一个或多个指针修改内存，要注意指针参数不能引用重叠的对象，这一点很重要。因此，了解被调用函数的语义很重要。

##### 4.11.2.1 不合规代码示例

在该不合规代码示例中，函数`f()`接受 3 个参数。该函数从`restrict`限定的指针`p`指向的数组拷贝`n`个整数到`restrict`限定指针`q`引用的`int`数组中。因为每次函数执行时目的数组都被修改（`n`是非 0 的），如果数组是通过其中一个指针参数来访问的，那么它就不能再通过另一个指针访问。将这些函数的参数声明为`restrict`限定的指针，可以促进编译器进行优化，但是如果这些指针引用重叠的对象就会导致未定义行为。

```cpp
#include <stddef.h>
void f(size_t n, int *restrict p, const int *restrict q) {
  while (n-- > 0) {
    *p++ = *q++;
  }
}

void g(void) {
  extern int d[100];
  /* ... */
  f(50, d + 1, d); /* Undefined behavior */
}
```

函数`g()`声明了一个含 100 个 int 值的数组`d`，并且调用函数`f()`将数组的一个区域拷贝到另一区域。由于该调用中`p`和`q`都访问了`d[1]`到`d[49]`，所以是未定义行为。

##### 4.11.2.2 合规解决方案

在该合规解决方案中，函数`f()`没有变化，但程序员要保证调用`f()`时不会导致未定义行为。由于将数组分割成两个不相交的部分，所以`f()`和`g()`的调用都是合法的。

```cpp
#include <stddef.h>
void f(size_t n, int *restrict p, const int *restrict q) {
  while (n-- > 0) {
    *p++ = *q++;
  }
}

void g(void) {
  extern int d[100];
  /* ... */
  f(50, d + 50, d); /* Defined behavior  */
}
```

##### 4.11.2.3 不合规代码示例

在该例中，函数`add()`将分别由指针`lhs`和`rhs`指向的两个整数数组相加，并将结果保存到指针`res`指向的数组中，`lhs`、`rhs`和`res`都用`restrict`限定。函数`f()`声明了一个含 100 个 int 值的数组，调用`add()`将数组的一个区域拷贝到另一区域。`add(100, a, a, a)`调用时`lhs`和`rhs`都访问了`res`修改的对象，导致未定义行为。

```cpp
#include <stddef.h>

void add(size_t n, int *restrict res, const int *restrict lhs,
       const int *restrict rhs) {
  for (size_t i = 0; i < n; ++i) {
    res[i] = lhs[i] + rhs[i];
  }
}

void f(void) {
  int a[100];
  add(100, a, a, a); /* Undefined behavior */
}
```

##### 4.11.2.4 合规解决方案

在该合规解决方案中，通过两个`restrict`指针对一个未修改对象进行别名化。因为数组`a`和`b`是不相交的，调用`add(100, a, b, b)`时数组`b`不会被修改，所以不会产生未定义行为。

```cpp
#include <stddef.h>
void add(size_t n, int *restrict res, const int *restrict lhs,
         const int *restrict rhs) {
  for (size_t i = 0; i < n; ++i) {
    res[i] = lhs[i] + rhs[i];
  }
}

void f(void) {
   int a[100];
   int b[100];
   add(100, a, b, b); /* Defined behavior  */
}
```
#### 4.11.3 调用含`restrict`限定指针的库函数

当调用库函数时，要保证`restrict`限定的源指针和目的指针不引用重叠对象。例如，下面表中列出的 C 标准库函数，都是把源对象的内存拷贝到目的对象中，源和目的都是由`restirct`限定的指针引用的。

| Standard C | Annex K     |
| ---------- | ----------- |
| strcpy()   | strcpy_s()  |
| strncpy()  | strncpy_s() |
| strcat()   | strcat_s()  |
| strncat()  | strncat_s() |
| memcpy()   | memcpy_s()  |
|            | strtok_s()  |

如果函数实参引用的对象有重叠（即对象共享某些共同的内存地址），其行为就是未定义的（见[未定义行为68][]）。函数的结果是未知的，数据可能被损坏。因此，不能将指向重叠对象的指针传递给这些参数。如果必须在共享的内存地址间拷贝数据，拷贝函数要保证允许在重叠内存上正常工作，比如应该使用函数`memove()`。

##### 4.11.3.1 不合规代码示例

在该不合规代码示例中，由于存在内存重叠，在调用`memcpy()`之后，`ptr1`和`ptr2`指向的对象值将不可预料。

```cpp
#include <string.h>

void func(void) {
  char c_str[]= "test string";
  char *ptr1 = c_str;
  char *ptr2;

  ptr2 = ptr1 + 3;
  /* Undefined behavior because of overlapping objects */
  memcpy(ptr2, ptr1, 6);
  /* ... */
}
```

##### 4.11.3.2 合规解决方案

在该合规解决方案中，调用时用`memmove()`来代替`memcpy()`。函数`memmove()`在内存区域没有重叠时执行与`memcpy()`相同的操作。当内存区域由重叠时，先将源指针（`ptr1`）指向的对象的n个字符拷贝到一个临时数组，临时数组对象与目的（`ptr2`）对象或源对象都没有重叠。然后再将临时数组的 n 个字符拷贝到目的对象。

```cpp
#include <string.h>

void func(void) {
  char c_str[]= "test string";
  char *ptr1 = c_str;
  char *ptr2;

  ptr2 = ptr1 + 3;
  memmove(ptr2, ptr1, 6);  /* Replace call to memcpy() */
  /* ... */
}
```

使用`memmove()`的类似解决方案可以代替字符串函数，只是要小心字符的字节大小和被复制字符串的 null 结束符是否正确。

#### 4.11.4 以指向`const`限定类型的`restrict`限定指针调用函数

一定要确保接受指向`const`限定类型的`restrict`限定指针作为参数的函数不修改该指针引用的对象。格式化输入和输出标准库函数常常符合这个描述。下表中列出了一下常见的函数，其格式化参数是指向`const`限定类型的`restrict`限定指针。

| Standard C | Annex K      |
| ---------- | ------------ |
| printf()   | printf_s()   |
| scanf()    | scanf_s()    |
| sprintf()  | sprintf_s()  |
| snprintf() | snprintf_s() |

像`printf()`这样的格式化输出函数，程序员不太可能想要修改格式化字符串。但是，如果程序违反了[FIO30-C  排除格式字符串中的用户输入][]，且传递污染值作为格式字符串的一部分，攻击者可能试图这样做。

##### 4.11.4.1 不合规代码示例

在该不合规代码示例中，程序员试图用从`stdin`读入的字符串（比如"%d%f 1 3.3"）来覆盖格式化字符串，并使用修改过的字符串"%s%d%f"输入后续的值 1 和 3.3：

```cpp
#include <stdio.h>

void func(void) {
  int i;
  float x;
  char format[100] = "%s";
  /* Undefined behavior */
  int n = scanf(format, format + 2, &i, &x);
  /* ... */
}
```

##### 4.11.4.2 合规解决方案

该例中实现了预想的结果：

```cpp
#include <stdio.h>

void func(void) {
  int i;
  float x
  int n = scanf("%d%f", &i, &x); /* Defined behavior  */
  /* ... */
}
```

#### 4.11.5 `restrict`限定的指针间由外到内赋值

从外层代码块到在内部嵌套块内声明的`restrict`限定指针的赋值是已定义行为。

##### 4.11.5.1 不合规代码示例

将`restrict`限定指针赋值给同一代码块中的其他`restrict`限定指针是未定义行为：

```cpp
void func(void) {
  int *restrict p1;
  int *restrict q1;

  int *restrict p2 = p1; /* Undefined behavior */
  int *restrict q2 = q1; /* Undefined behavior */
 }
```

##### 4.11.5.2 合规解决方案

使用内部嵌套代码块可以实现预想的结果，如下：

```cpp
void func(void) {
  int *restrict p1;
  int *restrict q1;
  {  /* Added inner block */
    int *restrict p2 = p1; /* Valid, well-defined behavior */
    int *restrict q2 = q1; /* Valid, well-defined behavior */
  }
}
```

#### 4.11.6 风险评估

不正确的使用`restrict`限定的指针会导致未定义行为，造成数据完整性的破坏。

| 规则      | 安全性  | 可能性  | 修补成本 | 优先级  | 级别   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP43-C | 中    | 有可能  | 高    | P4   | L3   |

#### 4.11.7 相关指南

| 标准                            | 条目                                       |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | FIO30-C. Exclude user input from format strings |
| ISO/IEC TR 24772:2013         | Passing Parameters and Return Values [CSJ] |
| ISO/IEC TS 17961              | Passing pointers into the same object as arguments to different restrict-qualified parameters [restrict] |
| MISRA C:2012                  | Rule 8.14 (required)1                    |

#### 4.11.8 参考文献

| 文献                      | 条目                                       |
| ----------------------- | ---------------------------------------- |
| [[ISO/IEC 9899:2011][]] | 6.7.3.1, "Formal Definition of restrict" |
| [[Walls 2006][]]        |                                          |


### 4.12 EXP44-C 不要向sizeof、_Alignof或者_Generic传递有副作用的操作数

有些运算符在操作数提供的类型信息之外，不会对其操作数进行求值。在使用这类运算符时，不要传递看上去可能会造成副作用的操作数，因为在这里副作用实际上是不会出现的。

`sizeof`运算符用来求取操作数的大小（以字节计算），操作数可能是一个表达式或者带有括号的类型名称。在大部分情况下，操作数没有被求值。可能的例外是操作数类型为可变长度数组（Variable Length Array，VLA），在这种情况下需要求取表达式的值。当`sizeof`运算符的操作数有一部分是 VLA 类型，且更改 VLA 大小表达式的值不会影响运算符结果时，不管是否对大小表达式求值，都是未指定行为（参见未指定行为22（[unspecified behavior 22][]））。

传递给`_Alignof`的操作数无论是否是表达式，永远不会被求值。例如，如果操作数是 VLA 类型并且其大小表达式具有副作用，永远不会对该副作用进行求值。

`_Generic`选择表达式的操作数也不会被求值。

提供一个可能会产生副作用的表达式会对程序员造成误导，他们不知道这些表达式没有被求值，在`sizeof`中使用VLA的情况下会产生未指定行为。因此，程序员可能会对程序状态做出不正确的判断，导致错误和可能的软件漏洞。

这条规则与[PRE31-C 避免不安全宏的参数出现副作用][]类似。

#### 4.12.1 不合规代码示例（`sizeof`）

在该示例中，表达式`a++`没有被求值：

```cpp
#include <stdio.h>

void func(void) {
  int a = 14;
  int b = sizeof(a++);
  printf("%d, %d\n", a, b);
}
```

因此，`b`之后的`a`值初始化为 14。

#### 4.12.2 合规解决方案（`sizeof`）

在该解决方案中，变量`a`在`sizeof`运算符之后实现递增：

```cpp
#include <stdio.h>

void func(void) {
  int a = 14;
  int b = sizeof(a);
  ++a;
  printf("%d, %d\n", a, b);
}
```

#### 4.12.3 不合规代码示例（`sizeof`，`VLA`）

在该不合规代码示例中，初始化`a`时，表达式`++n`必须被求值，因为它的值影响`sizeof`运算符中 VLA 操作数的大小。但是，在初始化`b`时，表达式`++n % 1`被求值为 0。这意味着`n`的值不影响`sizeof`运算符的结果。因此，不管初始化`b`时`n`是否递增，这都是未定义行为。

```cpp
#include <stddef.h>
#include <stdio.h>

void f(size_t n) {
  /* n must be incremented */
  size_t a = sizeof(int[++n]);

  /* n need not be incremented */
  size_t b = sizeof(int[++n % 1 + 1]);

  printf("%zu, %zu, %zu\n", a, b, n);
  /* ... */
}
```

#### 4.12.4 合规解决方案（`sizeof`，`VLA`）

该解决方案避免在每一个`sizeof`表达式中修改变量`n`的值，而是在之后再安全地递增`n`：

```cpp
#include <stddef.h>
#include <stdio.h>

void f(size_t n) {
  size_t a = sizeof(int[n + 1]);
  ++n;

  size_t b = sizeof(int[n % 1 + 1]);
  ++n;
  printf("%zu, %zu, %zu\n", a, b, n);
  /* ... */
}
```

#### 4.12.5 不合规代码示例（`_Generic`）

该例中试图修改`_Generic`选择控制表达式中的一个变量值。程序员可能期望`a`递增，但是因为`_Generic`不对表达式进行求值，`a`的值没有被修改。

```cpp
#include <stdio.h>

#define S(val) _Generic(val, int : 2, \
                             short : 3, \
                             default : 1)
void func(void) {
  int a = 0;
  int b = S(a++);
  printf("%d, %d\n", a, b);
}
```

#### 4.12.6 合规解决方案（`_Generic`）

在该解决方案中，`a`在`_Generic`选择控制表达式之外递增：

```cpp
#include <stdio.h>

#define S(val) _Generic(val, int : 2, \
                             short : 3, \
                             default : 1)
void func(void) {
  int a = 0;
  int b = S(a);
  ++a;
  printf("%d, %d\n", a, b);
}
```

#### 4.12.7 不合规代码示例（`_Alignof`）

该示例试图在获取某个变量的默认对齐值时修改它。用户可能预期`_Alignof`表达式中的`val`递增，但是`_Alignof`不求取其操作数，所以`val`没有变化。

```cpp
#include <stdio.h>

void func(void) {
  int val = 0;
  /* ... */
  size_t align = _Alignof(int[++val]);
  printf("%zu, %d\n", align, val);
  /* ... */
}
```

#### 4.12.8 合规解决方案（`_Alignof`）

该解决方案将表达式移出`_Alignof`运算符：

```cpp
#include <stdio.h>
void func(void) {
  int val = 0;
  /* ... */
  ++val;
  size_t align = _Alignof(int[val]);
  printf("%zu, %d\n, align, val);
  /* ... */
}
```

#### 4.12.9 例外

**EXP44-C-EX1**：读取`volatile`限定的值是有副作用的操作。但是，通过一个`volatile`限定的类型来访问某个值，并不保证一定会产生副作用，除非被访问的对象也是`volatile`限定的。比如下面的例子，惯用地读取`volatile`限定的对象来作为`sizeof()`，`_Alignof()`或`_Generic`的操作数是允许的。

```cpp
void f(void) {
  int * volatile v;
  (void)sizeof(*v);
}
```

#### 4.12.10 风险评估

向不求取操作数值的运算符提供可能会产生副作用的表达式，结果可能不同于预期。使用这样的结果可能造成意外的程序行为。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP44-C | 低    | 不太可能 | 低    | P3   | L3   |

#### 4.12.11 相关指南

| 标准                           | 条目                                       |
| ---------------------------- | ---------------------------------------- |
| SEI CERT C++ Coding Standard | EXP52-CPP. Do not rely on side effects in unevaluated operands |


### 4.13 EXP45-C 不要在选择语句中执行赋值

不要在下表列出的上下文中使用赋值运算符，因为这样做通常是程序员的错误，可能造成意外的行为（ [unexpected behavior][]）。

| Operator     | Context                       |
| ------------ | ----------------------------- |
| if           | 控制表达式                         |
| while        | 控制表达式                         |
| do ... while | 控制表达式                         |
| for          | 第二个操作数                        |
| ?:           | 第一个操作数                        |
| ?:           | 第二个或者第三个操作数（任意这些上下文中使用三元表达式时） |
| &&           | 任何一个操作数                       |
| &#124;&#124; | 任何一个操作数                       |
| ,            | 第二个操作数，（任意这些上下文中使用逗号表达式时）     |

#### 4.13.1 不合规代码示例

在该示例中，`if`语句中最外层的表达式是一个赋值表达式：

```cpp
if (a = b) {
  /* ... */
}
```

这段代码的意图可能是将`b`赋值给`a`，并测试结果的值是否等于 0，但是程序员常常错误地使用赋值运算符`=`代替相等运算符`==`。结果是，许多编译器对此情况提出警告，坚持“[MSC00-C. Compile cleanly at high warning levels][]”可以检测出这种编码错误。

#### 4.13.2 合规解决方案（无意的赋值）

当 b 赋值给 a 不是程序员的意图时，下面的条件代码块会在 a 等于 b 时执行：

```cpp
if (a == b) {
  /* ... */
}
```

#### 4.13.3 合规解决方案（有意的赋值）

当赋值是程序员的意图时，如下的解决方案明确地使用不等式作为最外层的表达式，同时在内层表达式中执行赋值：

```cpp
if ((a = b) != 0) {
  /* ... */
}
```
考虑到程序员的意图，这种做法通常不太可取，因为它在条件中混入了赋值，但是很明显，在这里程序员的意图就是进行赋值。

#### 4.13.4 不合规代码示例

在该示例中，表达式`x=y`用作`while`语句的控制表达式：

```cpp
 do { /* ... */ } while (foo(), x = y);
```

使用`for`语句可以得到相同的结果，`for`语句专门设计用于在每次迭代时在执行判断之前对表达式求值：

```cpp
 for (; x; foo(), x = y) { /* ... */ }
```

#### 4.13.5 合规解决方案（无意的赋值）

当`y`的值赋给`x`不是程序员的意图时，条件代码块应该只在`x=y`时执行，正如以下的解决方案：

```c
do { /* ... */ } while (foo(), x == y);
```

#### 4.13.6 合规解决方案（有意的赋值）

当赋值是程序员的意图时，可以使用如下解决方案：

```cpp
do { /* ... */ } while (foo(), (x = y) != 0);
```

#### 4.13.7 不合规代码示例

在这个示例中，表达式`p=q`用作`while`语句的控制表达式：

```cpp
 do { /* ... */ } while (x = y, p = q);
```

#### 4.13.8 合规解决方案

在这个解决方案中，不使用表达式`x=y`作为`while`语句的控制表达式：

```cpp
do { /* ... */ } while (x = y, p == q);
```

#### 4.13.9 不合规代码示例

该示例中有个打字错误，应该是比较而非赋值。

```cpp
while (ch = '\t' && ch == ' ' && ch == '\n') {
  /* ... */
}
```

多数编译器会给出警告。如果坚持 [MSC00-C. Compile cleanly at high warning levels][] 会消除这个错误。编译这段代码对无防备的程序员来说，会导致不可预料的行为。如果程序员的意图是验证字符串的值（比如密码，用户名或者组用户ID），将会导致严重的漏洞。

#### 4.13.10 合规解决方案（RHS变量）

当一个变量和常量进行比较时，把变量放在比较操作符的右侧能够防止赋值错误。

在该例中，常量字符串放在每个比较操作的左侧。如果程序员不小心误用了赋值操作符，即将`ch`赋值给`'\t'`，将会不合法并产生诊断消息。

```cpp
while ('\t' = ch && ' ' == ch && '\n' == ch) {
  /* ... */
}
```

由于产生了诊断错误，程序员将很容易发现和修正类似的打字错误。 

```cpp
while ('\t' == ch && ' ' == ch && '\n' == ch) {
  /* ... */
}
```

因此，无论何种编译器，警告级别或执行环境，赋值运算符的任何错误使用都可能造成诸如字符串验证之类的操作漏洞，导致编译器产生诊断消息。

#### 4.13.11 例外

**EXP45-C-EX1**：赋值可以用于赋值结果本身是比较表达式或者条件表达式操作数的情况。如下的例子中，表达式`x=y`本身是比较运算的操作数：

```cpp
if ((x = y) != 0) { /* ... */ }
```

**EXP45-C-EX2**：赋值可以用在表达式由单个基本表达式组成的情况。下面的代码是合规的，因为表达式`x=y`是一个基本表达式：

```cpp
if ((x = y)) { /* ... */ }
```

下面的表达式是不合规的，因为`&&`不是比较或者关系运算符，整个表达式不是基本表达式：

```cpp
if ((v = w) && flag) { /* ... */ }
```

当程序员无意将`v`的值赋值给`w`时，下面的控制表达式可以用于在`v`等于`w`时执行条件块：

```cpp
if ((v == w) && flag) { /* ... */ };
```

当赋值是程序员的意图时，可以使用下面的控制表达式：

```cpp
if (((v = w) != 0) && flag) { /* ... */ };
```

**EXP45-C-EX3**：赋值可以用于函数参数或者数组下标。在下面的解决方案中，表达式`x=y`用于函数参数：

```cpp
if (foo(x = y)) { /* ... */ }
```

#### 4.13.12 风险评估

忽略错误可能造成意外的程序流向。

| 建议      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP45-C | 低    | 很可能  | 中    | P6   | L2   |

#### 4.13.13 相关指南

| 标准                                       | 条目                                       |
| ---------------------------------------- | ---------------------------------------- |
| SEI CERT C++ Coding Standard             | EXP19-CPP. Do not perform assignments in conditional expressions |
| CERT Oracle Secure Coding Standard for Java | EXP51-J. Do not perform assignments in conditional expressions |
| ISO/IEC TR 24772:2013                    | Likely Incorrect Expression [KOA]        |
| ISO/IEC TS 17961                         | No assignment in conditional expressions [boolasgn] |
| MITRE CWE                                | CWE-480, Use of Incorrect Operator       |

#### 4.13.14 参考文献

| 文献            | 条目                                       |
| ------------- | ---------------------------------------- |
| [Dutta 03]    | "Best Practices for Programming in C"    |
| [Hatton 1995] | Section 2.7.2, "Errors of Omission and Addition" |


### 4.14 EXP46-C 不要在布尔类的操作数上使用位运算符

在一个完整表达式中混用位运算符和关系运算符，可能是表达式逻辑错误的标志，其中逻辑运算符通常是有意的运算符。不要在`_Bool`类型，或者关系表达式、相等表达式的结果上使用位运算符AND（&），OR（|），或XOR（^）。如果位运算符是有意的，就应该用括号来表示出来。

#### 4.14.1 不合规代码示例

在该示例中，在相等表达式的结果上使用位运算符`&`：

```cpp
if (!(getuid() & geteuid() == 0)) {
  /* ... */
}
```

#### 4.14.2 合规解决方案

该解决方案在条件表达式中使用`&&`运算符来进行逻辑操作：

```cpp
if (!(getuid() && geteuid() == 0)) {
  /* ... */
}
```

#### 4.14.3 风险评估

| 建议      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP46-C | 低    | 很可能  | 低    | P9   | L2   |

#### 4.14.4 相关指南

| 标准                    | 条目                                 |
| --------------------- | ---------------------------------- |
| ISO/IEC TR 24772:2013 | Likely Incorrect Expression [KOA]  |
| MITRE CWE             | CWE-480, Use of incorrect operator |

#### 4.14.5 参考文献

| 文献            | 条目                                       |
| ------------- | ---------------------------------------- |
| [Hatton 1995] | Section 2.7.2, "Errors of Omission and Addition" |


### 4.15 EXP47-C 不要用类型不正确的参数来调用`va_arg`

使用`va_arg()`宏来访问变参函数中的参数。这个宏接受`va_list`，`va_list`表示调用函数时使用的可变参数。通常在循环中调用这个宏，对于每个参数都调用一次。但是，传递给`va_arg`的类型和用户调用时传递的类型不一定保证能够匹配，另外编译时通常不会检查调用该宏时函数是否有可用的参数。C 标准 7.16.1.1 规定：

> 如果没有下一个实参，或者类型和实参的类型（调整到默认参数）不符，则行为是未定义，下列情况除外：
>   — 一种是有符号整数类型，另一种是对应的无符号整数类型，并且值由两种类型来表示；
>   — 一种是指向`void`的指针，另一种是指向字符类型的指针；

要保证调用`va_arg()`宏时不要试图访问没有传递的参数。另外，传递给`va_arg()`的参数类型要和变参函数默认参数的类型匹配。如果违反以上任一情况，都会都会导致未定义行为（[undefined behavior][]）。

#### 4.15.1 不合规代码示例

该示例中试图用`va_arg()`来读取一个`unsigned char`类型的变长参数。但是，将`unsigned char`类型的值传递给变参函数时，该值被提升到默认参数类型，即实际上传递的是`int`类型的值。

```cpp
#include <stdarg.h>
#include <stddef.h>

void func(size_t count, ...) {
  va_list ap;
  va_start(ap, count);
  if (count > 0) {
    unsigned char c = va_arg(ap, unsigned char);
    // ...
  }
  va_end(ap);
}

void f(void) {
  unsigned char c = 0x12;
  func(1, c);
}
```

#### 4.15.2 合规解决方案

该解决方案中使用`int`类型来访问变长参数，然后再转换成`unsigned char`类型。

```cpp
#include <stdarg.h>
#include <stddef.h>

void func(size_t count, ...) {
  va_list ap;
  va_start(ap, count);
  if (count > 0) {
    unsigned char c = (unsigned char)va_arg(ap, int);
    // ...
  }
  va_end(ap);
}

void f(void) {
  unsigned char c = 0x12;
  func(1, c);
}
```

#### 4.15.3 不合规代码示例

该示例中假定至少传递一个可变参数给函数，并且试图用`va_arg()`宏来读取它。
这种模式经常出现在变参函数使用一个哨兵值来表示参数列表的结束。但是，调用者如果不传递额外的参数，就会导致未定义行为。

```cpp
#include <stdarg.h>

void func(const char *cp, ...) {
  va_list ap;
  va_start(ap, cp);
  int val = va_arg(ap, int);
  // ...
  va_end(ap);
}
 
void f(void) {
  func("The only argument");
}
```

#### 4.15.4 合规解决方案

变参函数不可能确定调用者实际提供多少个参数；这些信息必须由外部传递进来。这往往导致需要将这些信息放到初始参数中，例如下面的解决方案：

```cpp
#include <stdarg.h>
#include <stddef.h>

void func(const char *cp, size_t numArgs, ...) {
  va_list ap;
  va_start(ap, cp);
  if (numArgs > 0) {
    int val = va_arg(ap, int);
    // ...
  }
  va_end(ap);
}

void f(void) {
  func("The only argument", 0);
}
```

#### 4.15.5 风险评估

不正确的使用`va_arg()`会导致未定义行为，其中还包括栈内存的访问。

| 建议      | 严重性  | 可能性  | 修补成本 | 优先级  | 等级   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| EXP47-C | 中    | 很可能  | 高    | P6   | L2   |

#### 4.15.6 参考文献

| 文献                      | 条目                                       |
| ----------------------- | ---------------------------------------- |
| [[ISO/IEC 9899:2011][]] | Subclause 7.16, "Variable Arguments <stdarg.h>" <br>Subclause 6.5.2.2, "Function calls" |

<!-- 链接定义 -->
[undefined behavior]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-undefinedbehavior

[unexpected behavior]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-unexpectedbehavior

[MSC00-C. Compile cleanly at high warning levels]: https://www.securecoding.cert.org/confluence/display/c/MSC00-C.+Compile+cleanly+at+high+warning+levels

[unspecified behavior 22]: https://www.securecoding.cert.org/confluence/display/c/DD.+Unspecified+Behavior#DD.UnspecifiedBehavior-usb_22

[PRE31-C 避免不安全宏的参数出现副作用]: https://www.securecoding.cert.org/confluence/display/c/PRE31-C.+Avoid+side+effects+in+arguments+to+unsafe+macros

[Walls 2006]: https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography


[未定义行为68]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_68

[FIO30-C 排除格式字符串中的用户输入]: https://www.securecoding.cert.org/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings

[ISO/IEC 9899:2011]: https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-ISO-IEC9899-2011


[undefined behavior 64]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_64

[EXP05-C. Do not cast away a const qualification]: https://www.securecoding.cert.org/confluence/display/c/EXP05-C.+Do+not+cast+away+a+const+qualification

[STR30-C. Do not attempt to modify string literals]: https://www.securecoding.cert.org/confluence/display/c/STR30-C.+Do+not+attempt+to+modify+string+literals

[lvalue]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-lvalue

[undefined behavior 37]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_37

[unspecified behavior 11]: https://www.securecoding.cert.org/confluence/display/c/DD.+Unspecified+Behavior#DD.UnspecifiedBehavior-unspecifiedbehavior11

[未定义行为]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-undefinedbehavior

[undefined behavior 76]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_76

[undefined behavior 26]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_26

[IEEE Std 1003.1:2013]: https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-IEEEStd1003.1-2013

[FIO06-C. Create files with appropriate access permissions]: https://www.securecoding.cert.org/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions

[CVE-2006-1174 shadow-utils]: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-1174

[undefined behavior 25]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_25

[Clever Attack Exploits Fully-Patched Linux Kernel]: http://www.theregister.co.uk/2009/07/17/linux_kernel_exploit/

[Goodin 2009]: https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-Goodin2009

[ERR33-C 检查和处理标准库错误]: https://www.securecoding.cert.org/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors

[程序异常终止]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-abnormaltermination

[undefined behavior 11]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_11

[undefined behavior 10]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_10

[undefined behavior 12]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_12


[undefined behavior 200]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_200

[More Randomness or Less]: http://kqueue.org/blog/2012/06/25/more-randomness-or-less/

[Wang 2012]: https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-Wang12

[undefined behavior 181]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_171

[undefined behavior 65]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_65

[side effects]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-sideeffect

[sequence points]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-sequencepoint

[undefined behavior 35]: https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_35

[unspecified behavior]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-unspecifiedbehavior

## 5 整数（INT）
### 5.1 INT30-C 保证无符号整型数操作不会出现回绕

根据 C 语言标准 6.2.5 节第 9 段 [ISO/IEC 9899:2011] 所述：
> 涉及无符号整数的计算不会溢出，因为无法由最终的无符号整数类型表示的结果将会根据这种最终类型可以表示的最大值加1执行求模操作。

以上行为更为正式的名称是无符号整数回绕（unsigned interger wrapping）。如果结果值无法由整数的底层表示形式表示，就会产生回绕。下表中给出了哪些操作符可能会产生回绕。

| Operator | Wrap | Operator | Wrap | Operator | Wrap | Operator | Wrap |
| -- | --- | -- | --- | -- | --- | -- | --- |
| + | Yes | -= | Yes | << | Yes | < | No |
| - | Yes | *= | Yes | >> | No | > | No |
| * | Yes | /= | No | & | No | >= | No |
| / | No | %= | No | &#124; | No | <= | No |
| % | No | <<= | Yes | ^ | No | == | No |
| ++ | Yes | >>= | No | ~ | No | != | No |
| -- | Yes | &= | No | ! | No | && | No |
| = | No | &#124;= | No | un + | No | &#124;&#124; | No |
| += | Yes | ^= | No | un - | Yes | ?: | No |

下面各节讨论了可能会产生无符号整数回绕的特定操作。对小整数类型（小于`int`）进行操作时，会发生整型提升。另外，在执行运算之前，也可能会发生算术转换，即将操作数（隐式的）转换为相同的类型。因此，在实现安全的算术运算之前，要确保理解整数转换规则（参见 *INT02-C. Understand integer conversion rules*）。

以下列方式使用整数时，尤其不应该出现整数回绕的情况：

- 在任何指针运算中，包括作为数组索引
- 用于声明变长数组时
- 通过自增或自减运算得到数组起始地址，或用于指定数组下标的表达式
- 作为`size_t`或`rsize_t`类型的实参（比如内存分配函数的参数）
- 在安全关键的代码中

C语言标准对于原子整数类型的算术运算，定义了与普通整数类型同样的表示方式。因此，对于原子整数类型，也应该如同普通整数类型一样对回绕的情况进行检查和预防。

#### 5.1.1 加法
加法是在两个算术类型的操作数之间或一个指向对象的指针和一个整数类型之间执行的。本规则只应用于两个算术类型相加的情况（指针加法的规则参见 *ARR37-C. Do not add or subtract an integer to a pointer to a non-array object* 及 *ARR30-C. Do not form or use out-of-bounds pointers or array subscripts*）。

此外，自增运算等同于加 1 运算。

##### 5.1.1.1 不合规代码示例
在以下的不合规代码示例中，无符号的算子`ui_a`和`ui_b`相加时可能会产生无符号整型回绕。如果回绕行为是非预期的（unexpected），那么就可能会导致诸如分配了不足额的内存供后续操作使用，或易受攻击的安全漏洞（vulnerability）。

```cpp
void func(unsigned int ui_a, unsigned int ui_b) {
    unsigned int usum = ui_a + ui_b;
    /* ... */ 
}
```

##### 5.1.1.2 合规解决方案（前置条件测试）
这种，`void func(unsigned int ui_a)`方案对参与相加的操作数进行了前置条件测试，以保证不会出现回绕。

```cpp
#include <limits.h>

void func(unsigned int ui_a, unsigned int ui_b) {
    unsigned int usum;
    if (UINT_MAX - ui_a < ui_b) {
        /* Handle error */
    } else {
        usum = ui_a + ui_b;
    }
    /* ... */
}
```

##### 5.1.1.3 合规解决方案（后置条件测试）
这种方案对相加运算进行了后置条件测试，如果相加后得到的`usum`不小于第一个操作数，则说明没有发生回绕。

```cpp
void func(unsigned int ui_a, unsigned int ui_b) {
    unsigned int usum = ui_a + ui_b;
    if (usum < ui_a) {
        /* Handle error */
    }
    /* ... */
}
```

#### 5.1.2 减法
减法是在两个算术类型的操作数之间，两个指向兼容对象类型的限定或未限定版本的指针之间，或一个指向一种对象类型的指针与一个整数类型的值之间执行的。本规则只应用于两个算术类型的操作数之间的减法（关于指针运算参见 *ARR36-C. Do not subtract or compare two pointers that do not refer to the same array，ARR37-C. Do not add or subtract an integer to a pointer to a non-array object 及 ARR30-C. Do not form or use out-of-bounds pointers or array subscripts*）。

此外，自减运算等同于减 1 运算。

##### 5.1.2.1 不合规代码示例
在以下的不合规代码示例中，无符号的算子`ui_a`和`ui_b`相减时可能会产生无符号整数回绕。如果回绕行为是非预期的，那么就可能导致易受攻击的安全漏洞。

```cpp
void func(unsigned int ui_a, unsigned int ui_b) {
    unsigned int udiff = ui_a - ui_b;
    /* ... */
}
```

##### 5.1.2.2 合规解决方案（前置条件测试）
这种方案对参与相减的操作数进行了前置条件测试，以保证不会出现回绕。

```cpp
void func(unsigned int ui_a, unsigned int ui_b) {
    unsigned int udiff;
    if (ui_a < ui_b) {
        /* Handle error */
    } else {
        udiff = ui_a - ui_b;
    }
    /* ... */
}
```

##### 5.1.2.3 合规解决方案（后置条件测试）
这种方案对减法运算进行了后置条件测试，如果相减的结果`udiff`不大于被减数，则说明没有发生回绕。

```cpp
void func(unsigned int ui_a, unsigned int ui_b) {
    unsigned int udiff = ui_a - ui_b;
    if (udiff > ui_a) {
        /* Handle error */
    }
    /* ... */
}
```

#### 5.1.3 乘法
乘法是在两个算术类型的操作数之间执行的。

##### 5.1.3.1 不合规代码示例
在 Mozilla Scalable Vector Graphics (SVG) 的查看程序中曾经存在一个堆缓冲区溢出的漏洞，这是由于`signed int`类型的值 pen->num_vertices 与 size_t 类型的值`sizeof(cairo_pen_vertex_t)`相乘造成的[VU#551436](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-VU551436)]。在进行乘法运算之前，`signed int`类型的操作数首先会被转换成无符号的`size_t`类型（参见 *INT02-C. Understand integer conversion rules*）。

```cpp
pen->num_vertices = _cairo_pen_vertices_needed( gstate->tolerance, radius, &gstate->ctm );
pen->vertices = malloc( pen->num_vertices * sizeof(cairo_pen_vertex_t) );
```

无符号整数回绕可能会导致分配到的内存不足。

##### 5.1.3.2 合规解决方案（后置条件测试）
合规解决方案是测试乘法的操作数，以保证不会出现回绕。

```cpp
pen->num_vertices = _cairo_pen_vertices_needed( gstate->tolerance, radius, &gstate->ctm );
if (pen->num_vertices > SIZE_MAX / sizeof(cairo_pen_vertex_t)) {
    /* Handle error */
}
pen->vertices = malloc( pen->num_vertices * sizeof(cairo_pen_vertex_t) );
```

#### 5.1.4 例外
**INT30-C-EX1**：在符合程序执行的需要时，无符号整数也可以表现出取模（回绕）行为。建议对于支持取模行为的整数，在声明变量以及对它的每一次操作时，都使用注释明确说明。

**INT30-C-EX2**：当在编译期就能够确定不会发生回绕行为时，那么就可以省略掉对回绕的检查。比如以下对无符号整数的运算操作就可以免去回绕检查：

- 两个编译期常量之间的运算
- 变量与 0 之间的运算（除了除 0 或对 0 取余的运算之外）
- 减法运算中，以减数的类型的最大值作为被减数时；比如，从`UINT_MAX`减去任意的`unsigned int`类型的数都是安全的
- 任何变量与 1 相乘
- 因子非 0 时的除法和取余运算
- 向右移位的位数不超过被操作的整数的精度时；比如对于`UNIT_MAX >> x`操作，只要`x`满足`0 <= x < 32`就是安全的（假设`unsigned int`类型的精度是 32 位）。

**INT30-C-EX3**： 两个整数之间的向左移位操作。对无符号整数的左移操作 << 可以有取模（回绕）行为。之所以允许这种例外，是因为通常情况下这是程序员本身所期望的，并且移位操作也有明确的规范定义（参见 *INT34-C 不要将表达式移动负数位或移动大于等于操作数中存在的位数*）。

#### 5.1.5 风险评估
整数回绕可能导致缓冲区溢出并执行攻击者的任何代码。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| INT30-C | 高 | 很可能 | 高 | P9 | L2 |

##### 5.1.5.1 相关漏洞
[CVE-2009-1385](https://nvd.nist.gov/vuln/detail/CVE-2009-1385) 是与本规则相关的一个漏洞。该值对缓冲区的长度执行了一次未经检查的减法，然后将与结果相应长度的字节数据的数据添加到另一个缓冲区（[xorl 2009](https://xorl.wordpress.com/2009/06/10/cve-2009-1385-linux-kernel-e1000-integer-underflow/)）。这个可能会导致缓冲区溢出，并允许攻击者执行任意代码。

Rafal Wojtczuk 在 [[Wojtczuk 2008](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-Wojtczuk08)] 中描述了一个（由无符号整数回绕引起的）缓冲区溢出的 Linux 内核漏洞。

Don Bailey 在 [[Bailey 2014](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-Bailey14)] 中描述了一个 LZO 算法中的无符号整数回绕漏洞，这个漏洞可能会被某些实现利用。

[CVE-2014-4377](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-4377) 描述了一个 IOS 7.1 中的由乘法运算回绕引起的漏洞。该漏洞中会产生一个不够大的值并被传递给一个内存分配程序，而导致随后的溢出。

#### 5.1.6 相关指南
| 文献 | 条目 |
| ---- | ---- |
| [SEI CERT C Coding Standard](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard) | [INT02-C. Understand integer conversion rules](https://www.securecoding.cert.org/confluence/display/c/INT02-C.+Understand+integer+conversion+rules) <br> [ARR30-C. Do not form or use out-of-bounds pointers or array subscripts](https://www.securecoding.cert.org/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts) <br> [ARR36-C. Do not subtract or compare two pointers that do not refer to the same array](https://www.securecoding.cert.org/confluence/display/c/ARR36-C.+Do+not+subtract+or+compare+two+pointers+that+do+not+refer+to+the+same+array) <br> [ARR37-C. Do not add or subtract an integer to a pointer to a non-array object](https://www.securecoding.cert.org/confluence/display/c/ARR37-C.+Do+not+add+or+subtract+an+integer+to+a+pointer+to+a+non-array+object) <br> [CON08-C. Do not assume that a group of calls to independently atomic methods is atomic](https://www.securecoding.cert.org/confluence/display/c/CON08-C.+Do+not+assume+that+a+group+of+calls+to+independently+atomic+methods+is+atomic) |
| [ISO/IEC TR 24772:2013](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-ISO-IECTR24772-2013) | Arithmetic Wrap-Around Error [FIF] |
| [MITRE CWE](http://cwe.mitre.org/) | [CWE-190](http://cwe.mitre.org/data/definitions/190.html), Integer Overflow or Wraparound |

### 5.2 INT31-C 保证整型转换不会丢失或错误解释数据
整型转换（包括隐式转换和显示转换）必须保证不会丢失或错误解释数据。对于来自不信任来源并且按以下方式使用的数据，这一点尤其重要：

- 在任何指针运算中，包括作为数组索引
- 用于声明变长数组时
- 通过自增或自减运算得到数组起始地址，或用于指定数组下标的表达式
- 作为 size_t 或 rsize_t 类型的实参（比如内存分配函数的参数）

本规则也被应用于传递给以下标准库函数的参数，这些参数会被转换为`unsigend char`类型：

• `memset()`
• `memset_s()`
• `fprintf()`及类似函数 (对于格式化修饰符 `%c` ，在不与修饰符`%l`组合使用时，整数参数会被转换为一个`unsigned char`类型的值，并且作为一个字符写入目标流中）
• `fputc()`
• `ungetc()`
• `memchr()`

此外，传递给以下库函数的参数会被转换为`char`类型:

• `strchr()`
• `strrchr()`
• `<ctype.h>`中列举的所有函数

对于所有的数据值以及所有遵循标准的编译器，唯一能保证安全的整数类型转换是将一个整数值转换为一种具有相同符号的更宽的类型。C语言标准 6.3.1.3 [ISO/IEC 9899:2011] 表示：

> 当一个整数类型的值被转换为除 _Bool 以外的另一种整数类型时，如果这个值能够用新类型表示，它就不会被修改。
>
> 否则，如果新类型是无符号的，这个值就反复加上或减去“这种新类型可以表示的最大值加 1”，直到这个值位于新类型的范围之内。
>
> 否则，这种新类型是有符号的并且这个值无法被新类型表示，此时它的结果是由编译器定义的，或者产生一个基于编译器实现的信号。

一般情况下，将一个整数类型转换为一个更小的类型会导致高位被截断。

#### 5.2.1 不合规代码示例（无符号转为有符号）
从一种无符号类型的转换为一种有符号类型时，可能会发生类型范围错误，包括数据丢失（截断）和符号位丢失（符号错误）。下面的不合规代码在大多数的编译器中都会产生一个截断错误：

```cpp
#include <limits.h> void func(void) {
    unsigned long int u_a = ULONG_MAX;
    signed char sc;
    sc = (signed char)u_a; /* Cast eliminates warning */
    /* ... */
}
```

#### 5.2.2 合规解决方案（无符号转为有符号）
从一种无符号类型转换为一种有符号类型时对范围进行验证。例如以下的代码可以用于从`unsigned long int`类型转换为`signed char`类型：

```cpp
#include <limits.h>

void func(void) {
    unsigned long int u_a = ULONG_MAX;
    signed char sc;
    if (u_a <= SCHAR_MAX) {
        sc = (signed char)u_a; /* Cast eliminates warning */
    } else {
        /* Handle error */
    }
}
```

#### 5.2.3 不合规代码示例（有符号转为无符号）
从一种有符号类型的转换为一种无符号类型时，可能会发生类型范围错误，包括数据丢失（截断）和符号位丢失（符号错误）。下面的不合规代码会导致符号位丢失：

```cpp
#include <limits.h>

void func(void) {
    signed int si = INT_MIN; /* Cast eliminates warning */
    unsigned int ui = (unsigned int)si;
    /* ... */
}
```

#### 5.2.4 合规解决方案（有符号转为无符号）
从一种有符号类型转换为一种无符号类型时对范围进行验证。例如以下的代码可以用于从`signed int`类型转换为`unsigned char`类型：

```cpp
#include <limits.h>

void func(void) {
    signed int si = INT_MIN;
    unsigned int ui;
    if (si < 0) {
        /* Handle error */
    } else {
        ui = (unsigned int)si; /* Cast eliminates warning */
    }
    /* ... */
}
```

根据C语言标准 [ISO/IEC 9899:2011] 6.2.5 第 9 段的条款，遵循标准的编译器实现（conforming implementation）能够保证以上的方案有效。

> 有符号整数类型的非负值的范围是相应的无符号整数类型的子范围，并且两种类型中相同值的表示是相同的。

#### 5.2.5 不合规代码示例（有符号数转换，精度损失）
从一种有符号整数类型转换为另一种精度更小的有符号类型时，可能会发生数据损失（截断）。以下的不合规代码在大多数编译器上都会发生数据截断错误：

```cpp
#include <limits.h>

void func(void) {
    signed long int s_a = LONG_MAX;
    signed char sc = (signed char)s_a; /* Cast eliminates warning */
    /* ... */
}
```

#### 5.2.6 合规解决方案（有符号数转换，精度损失）
从一种有符号类型转换为一种精度更小的有符号类型时，对范围进行验证。例如以下的代码可以用于从`signed long int`类型转换为`signed char`类型：

```cpp
#include <limits.h>

void func(void) {
    signed long int s_a = LONG_MAX;
    signed char sc;
    if ((s_a < SCHAR_MIN) || (s_a > SCHAR_MAX)) {
        /* Handle error */
    } else {
        sc = (signed char)s_a; /* Use cast to eliminate warning */
    }
    /* ... */
}
```

从有符号整数类型转换为精度更小的另一种有符号类型时，上界和下界都需要检查。

#### 5.2.7 不合规代码示例（无符号数转换，精度损失）
从一种无符号整数类型转换为另一种精度更小的无符号类型时，可能会发生数据损失（截断）。以下的不合规代码在大多数编译器上都会发生数据截断错误：

```cpp
#include <limits.h>
void func(void) {
    unsigned long int u_a = ULONG_MAX;
    unsigned char uc = (unsigned char)u_a; /* Cast eliminates warning */
    /* ... */
}
```

#### 5.2.8 合规解决方案（无符号数转换，精度损失）
从一种无符号类型转换为一种精度更小的无符号类型时，对范围进行验证。例如以下的代码可以用于从`unsigned long int`类型转换为`unsigned char`类型：

```cpp
#include <limits.h>

void func(void) {
    unsigned long int u_a = ULONG_MAX;
    unsigned char uc;
    if (u_a > UCHAR_MAX) {
        /* Handle error */
    } else {
        uc = (unsigned char)u_a; /* Cast eliminates warning */
    }
    /* ... */
}
```

从无符号整数类型转换为精度更小的另一种无符号类型时，只有上界需要检查。

#### 5.2.9 不合规代码示例（time_t 类型作为返回值）
`time()`函数在表示当前日历时间无效时，会将 -1 转换为`time_t`类型后的值（即`(time_t)(-1)`）返回。C 语言标准只要求`time_t`类型是一个能够表示时间的实数类型（整数和实数浮点数类型统称为实数类型）。具体采用哪种实数类型表示时间，交由编译器实现来决定。如果`time_t`被实现为一个精度小于`signed int`的无符号整数类型，那么`time()`的返回值将永远不会与整型字面常量`-1`相等。

```cpp
#include <time.h>

void func(void) {
    time_t now = time(NULL);
    if (now != -1) {
        /* Continue processing */
    }
}
```

#### 5.2.10 合规解决方案（time_t 类型作为返回值）
为了确保比较正确执行，`time()`的返回值应该与`-1`被转换成`time_t`类型以后的值比较：

```cpp
#include <time.h>

void func(void) {
    time_t now = time(NULL);
    if (now != (time_t)-1) {
        /* Continue processing */
    }
}
```

这个解决方案同样也符合 *INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size* 的规定。

#### 5.2.11 不合规代码示例（memset()）
因为历史原因，某些 C 标准库函数可以接受一个 int 类型的参数并将其转换为`unsigned char`类型或普通的 char 类型。如果参数的值无法被更小的类型表示，这种转换可能会导致非预期的行为。以下的不合规代码会将数组置为全 0,这显然是不符合预期的：

```cpp
#include <string.h>
#include <stddef.h>

int *init_memory(int *array, size_t n) {
    return memset(array, 4096, n);
}
```

#### 5.2.12 合规解决方案（memset()）
一般来说，`memeset()`函数不应该用于初始化整数数组，除非是希望将整个数组置 0:

```cpp
#include <string.h>
#include <stddef.h>

int *init_memory(int *array, size_t n) {
    return memset(array, 0, n);
}
```

#### 5.2.13 例外
**INT31-C-EX1**: C 语言标准定义了标准整数类型的最小范围。例如，`unsigned short int`类型对象的最小范围是 0 ~ 65,535，而`int`类型的最小范围是 -32,767 ~ +32,767。这意味着`unsigned short int`类型的值并不都能够用`int`来表示。但是，在 IA-32 架构中，实际的整数范围是`−2,147,483,648` ~ `+2,147,483,647`，这意味着在这种架构下所有的 `unsigned short int`值都可以用`int`类型来表示。因此，在 IA-32 架构下对这种转换进行测试就是不必要的。而在不知道底层类型的精度的情况下，无法对转换行为作出假设。如果未提供对转换的测试，就必须明确记录与精度有关的假设。在这些假设无效的系统中，这些代码就无法安全的移植。记录这些假设的一种较好的方式是使用静态断言（参见 *DCL03-C. Use a static assertion to test the value of a constant expression*）。

**INT31-C-EX2**: 只要值表示一个字符，而不是一个整数，允许从任何整数类型转换为值为`SCHAR_MIN`和`UCHAR_MAX`之间的字符类型。

转换为无符号字符类型由 C 定义为模块化行为。字符的值不会由于符号的丢失或转换为负数而被曲解。例如，欧元符号`€`有时由位模式`0x80`表示，根据类型的符号性，其可以具有数值`128`或`-127`。

转换为有符号字符类型更容易出现问题。C 标准 6.3.1.3 第 3 段（ISO/IEC 9899:2011）的条款表示，关于有符号类型转换：

> 否则，这种新类型是有符号的并且这个值无法被新类型表示，此时它的结果是由编译器定义的，或者产生一个基于编译器实现的信号。

此外，6.2.6.2 第 2 段的条款表示，关于此时的整型变换：

> 如果符号位是 1，这个值应该按以下的方式之一进行变换：
- 符号位 0 表示负值（原码）
- 符号位的值为 -(2<sup>M</sup>)（补码）
- 符号位的值为 -(2<sup>M</sup> - 1) （反码）
以上情况中，当符号位为 1 而其它位为 0 时（对于前两种情况），或者当符号位和其它位都为 1 时（对于反码的情况），由编译器实现来决定属于正常值还是异常表示。

因此，标准允许以下代码陷入系统中断：

```cpp
int i = 128; /* 1000 0000 in binary */ assert(SCHAR_MAX == 127);
signed char c = i; /* can trap */
```

但是，会将这段代码处理为异常或者产生一个无法预料的值的平台是很少见的。根据 Derk Jones 在 [The New C Standard: An Economic and Cultural Commentary](http://www.knosof.co.uk/cbook/cbook.html) 中所述：

> 具有这种处理方式的实现过去被认为是存在的，但是无法找到任何描述这类处理器的文档。

#### 5.2.14 风险评估
整数截断错误可能导致缓冲区溢出并执行攻击者的任何代码。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| INT31-C | 高 | 有可能 | 高 | P6 | L2 |

##### 5.2.14.1 相关漏洞
[CVE-2009-1376](http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2009-1376) 是一个与本规则相关的漏洞。在 Pidgin 2.5.5 版本中，将一个 64 位的无符号整数设置给了一个`size_t`类型的偏移值。如果是在一个将`size_t`实现为 32 位的平台上，这个值可能会被截断。从而，一个攻击者就可以通过选择合适的值引发缓冲区溢出并执行任意代码。

#### 5.2.15 相关指南
| 文献 | 条目 |
| ---- | ---- |
| [SEI CERT C Coding Standard](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard) | [DCL03-C. Use a static assertion to test the value of a constant expression](https://www.securecoding.cert.org/confluence/display/c/DCL03-C.+Use+a+static+assertion+to+test+the+value+of+a+constant+expression) <br> [INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size](https://www.securecoding.cert.org/confluence/display/c/INT18-C.+Evaluate+integer+expressions+in+a+larger+size+before+comparing+or+assigning+to+that+size) <br> [FIO34-C. Distinguish between characters read from a file and EOF or WEOF](https://www.securecoding.cert.org/confluence/display/c/FIO34-C.+Distinguish+between+characters+read+from+a+file+and+EOF+or+WEOF) |
| [CERT Oracle Secure Coding Standard for Java](https://www.securecoding.cert.org/confluence/display/java/SEI+CERT+Oracle+Coding+Standard+for+Java) | [NUM12-J. Ensure conversions of numeric types to narrower types do not result in lost or misinterpreted data](https://www.securecoding.cert.org/confluence/display/java/NUM12-J.+Ensure+conversions+of+numeric+types+to+narrower+types+do+not+result+in+lost+or+misinterpreted+data) |
| [ISO/IEC TR 24772:2013](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-ISO-IECTR24772-2013) | Numeric Conversion Errors [FLC] |
| [MISRA C:2012](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-MISRA12) | Rule 10.1 (required) <br> Rule 10.3 (required) <br> Rule 10.4 (required) <br> Rule 10.6 (required) <br> Rule 10.7 (required) |
| [MITRE CWE](http://cwe.mitre.org/) | [CWE-192](http://cwe.mitre.org/data/definitions/192.html), Integer Coercion Error <br> [CWE-197](http://cwe.mitre.org/data/definitions/197.html), Numeric Truncation Error <br> [CWE-681](http://cwe.mitre.org/data/definitions/681.html), Incorrect Conversion between Numeric Types |

### 5.3 INT32-C 保证有符号整数的运算不会溢出
有符号整数的溢出是一种未定义行为，这意味着编译器在处理有符号整数的溢出时有多种选择（参见 *MSC15-C. Do not depend on undefined behavior*）。例如，将有符号整数类型定义为具有取模行为的编译器就不需要检查整数溢出。编译器也可以捕捉有符号算术溢出，或者简单的假设溢出永远不会发生，并相应的生成代码。同一个遵循标准的编译器在不同的场景下生成具有不同行为的代码，也同样是可能的。例如，一个编译器可能判定在局部范围声明的有符号整型的循环控制变量不可能溢出，并基于这一点来生成有效的代码；而同一个编译器也可能判定在类似场景下使用的全局变量将会捕捉到异常。

基于这些理由，保证有符号整型运算不会导致溢出是非常重要的。尤其是来自于不信任源（tainted source）的数据按照以下方式被使用时：

- 在任何指针运算中，包括作为数组索引
- 用于声明变长数组时
- 通过自增或自减运算得到数组起始地址，或用于指定数组下标的表达式
- 作为`size_t`或`rsize_t`类型的实参（比如内存分配函数的参数）

如果结果值无法由整数的底层表示形式表示，整数运算就会发生溢出。下表中给出了哪些操作符可能会产生溢出。

| Operator | Wrap | Operator | Wrap | Operator | Wrap | Operator | Wrap |
| -- | --- | -- | --- | -- | --- | -- | --- |
| + | Yes | -= | Yes | << | Yes | < | No |
| - | Yes | *= | Yes | >> | No | > | No |
| * | Yes | /= | Yes | & | No | >= | No |
| / | Yes | %= | Yes | &#124; | No | <= | No |
| % | Yes | <<= | Yes | ^ | No | == | No |
| ++ | Yes | >>= | No | ~ | No | != | No |
| -- | Yes | &= | No | ! | No | && | No |
| = | No | &#124;= | No | un + | No | &#124;&#124; | No |
| += | Yes | ^= | No | un - | Yes | ?: | No |

下面各节讨论了可能会产生有符号整数溢出的特定操作。对小整数类型（小于`int`）进行操作时，会发生整型提升。另外，在执行运算之前，也可能会发生算术转换，即将操作数（隐式的）转换为相同的类型。因此，在实现安全的算术运算之前，要确保理解整数转换规则（参见 *INT02-C. Understand integer conversion rules*）。

#### 5.3.1 实现细节
使用[`-fwrapv`](https://gcc.gnu.org/onlinedocs/gcc-4.5.2/gcc/Code-Gen-Options.html#index-fwrapv-2088)命令行选项调用的 GNU GCC 编译器为无符号的和有符号的整数定义了同样的取模算法。

当一个有符号整数溢出时，使用[`-ftrapv`](https://gcc.gnu.org/onlinedocs/gcc-4.5.2/gcc/Code-Gen-Options.html#index-ftrapv-2088)命令行选项调用的GNU GCC 编译器会产生一个陷阱，这很有可能导致异常退出。在 UNIX 系统上，这个事件可能会产生一个发送到进程的信号。

既没有`-fwrapv`选项也没有`-ftrapv`选项调用的 GNU GCC 编译器，只是简单的假设有符号整数绝对不会溢出，并生成相应的目标代码。

#### 5.3.2 原子整数
C 标准定义了有符号原子整数的算术行为，以便在溢出时使用静默回绕的补码表示。尽管有定义，但是这些结果仍然可能是非期望的，并且会因此带来与无符号整数回绕类似的风险（参见 *INT30-C 保证无符号整型数操作不会出现回绕*）。一般来说，原子整数类型的有符号整型溢出行为也应该被检查和预防。


#### 5.3.3 加法
加法是在两个算术类型的操作数之间或一个指向对象的指针和一个整数类型之间执行的。本规则只应用于两个算术类型相加的情况（指针加法的规则参见 *ARR37-C. Do not add or subtract an integer to a pointer to a non-array object* 和 *ARR30-C. Do not form or use out-of-bounds pointers or array subscripts*）。

此外，自增运算等同于加 1 运算。

##### 5.3.3.1 不合规代码示例
在以下的不合规代码示例中，有符号的算子 si_a 和 si_b 相加时可能会导致有符号整型溢出：

```cpp
void func(signed int si_a, signed int si_b) {
    signed int sum = si_a + si_b;
    /* ... */
}
```

##### 5.3.3.2 合规解决方案
这种方案保证了加法操作不可能溢出，而无需考虑底层表示：

```cpp
#include <limits.h>

void f(signed int si_a, signed int si_b) {
    signed int sum;
    if (((si_b > 0) && (si_a > (INT_MAX - si_b))) ||
        ((si_b < 0) && (si_a < (INT_MIN - si_b)))) {
        /* Handle error */
    } else {
        sum = si_a + si_b;
    }
    /* ... */
}
```

#### 5.3.4 减法
减法是在两个算术类型的操作数之间，两个指向兼容对象类型的限定或未限定版本的指针之间，或一个指向一种对象类型的指针与一个整数类型的值之间执行的。本规则只应用于两个算术类型的操作数之间的减法（关于指针运算参见 *ARR36-C. Do not subtract or compare two pointers that do not refer to the same array*，*ARR37-C. Do not add or subtract an integer to a pointer to a non-array object* 和 *ARR30-C. Do not form or use out-of-bounds pointers or array subscripts*）。

此外，自减运算等同于减 1 运算。

##### 5.3.4.1 不合规代码示例
在以下的不合规代码示例中，有符号的算子`si_a`和`si_b`相减时可能会导致有符号整数溢出：

```cpp
void func(signed int si_a, signed int si_b) {
    signed int diff = si_a - si_b;
    /* ... */
}
```

##### 5.3.4.2 合规解决方案
这种方案对参与相减的操作数进行了测试，以保证不会出现溢出，而无需考虑底层表示：

```cpp
#include <limits.h>

void func(signed int si_a, signed int si_b) {
    signed int diff;
    if ((si_b > 0 && si_a < INT_MIN + si_b) ||
        (si_b < 0 && si_a > INT_MAX + si_b)) {
        /* Handle error */
    } else {
        diff = si_a - si_b;
    }
    /* ... */
}
```

#### 5.3.5 乘法
乘法是在两个算术类型的操作数之间执行的。

##### 5.3.5.1 不合规代码示例
在以下的不合规代码示例中，有符号的算子`si_a`和`si_b`相乘时可能会导致有符号整型溢出：

```cpp
void func(signed int si_a, signed int si_b) {
    signed int result = si_a * si_b;
    /* ... */
}
```

##### 5.3.5.2 合规解决方案
两个操作数的乘积可以总是使用比两个操作数中的较大者的位数多两倍的位来表示。以下的合规方案在`long long`类型长度至少为`int`类型长度的两倍的系统上，消除了有符号整型溢出的情况：

```cpp
#include <stddef.h>
#include <assert.h>
#include <limits.h>
#include <inttypes.h>

extern size_t popcount(uintmax_t);
#define PRECISION(umax_value) popcount(umax_value)

void func(signed int si_a, signed int si_b) {
    signed int result;
    signed long long tmp;
    assert(PRECISION(ULLONG_MAX) >= 2 * PRECISION(UINT_MAX));
    tmp = (signed long long)si_a * (signed long long)si_b;
    
    /*
     * If the product cannot be represented as a 32-bit integer,
     * handle as an error condition.
     */
    if ((tmp > INT_MAX) || (tmp < INT_MIN)) {
        /* Handle error */
    } else {
        result = (int)tmp;
    }
    /* ... */
}
```

如果`long long`的长度小于`int`的精度长度的 2 倍，则断言会失败。其中，宏`PRECISION()`和函数`popcount()`能够计算任何整数类型的正确精度（参见 *INT35-C 使用正确的整数精度*）。

##### 5.3.5.3 合规解决方案
以下的可移植的合规解决方案能够应用于任何符合标准的编译器，即使这些编译器并不存在任何精度为 int 类型两倍的整数类型：

```cpp
#include <limits.h>

void func(signed int si_a, signed int si_b) {
    signed int result;
    if (si_a > 0) {/* si_a is positive */
        if (si_b > 0) { /* si_a and si_b are positive */
            if (si_a > (INT_MAX / si_b)) {
                /* Handle error */
            }
        } else { /* si_a positive, si_b nonpositive */
            if (si_b < (INT_MIN / si_a)) {
                /* Handle error */
            }
        } /* si_a positive, si_b nonpositive */
    } else { /* si_a is nonpositive */
        if (si_b > 0) { /* si_a is nonpositive, si_b is positive */
            if (si_a < (INT_MIN / si_b)) {
                /* Handle error */
            }
        } else { /* si_a and si_b are nonpositive */
            if ( (si_a != 0) && (si_b < (INT_MAX / si_a))) {
                /* Handle error */
            }
        } /* End if si_a and si_b are nonpositive */
    } /* End if si_a is nonpositive */
    result = si_a * si_b;
}
```

#### 5.3.6 除法
除法是在两个算术类型之间执行的。在补码表示的有符号整数除法中，当有符号整数类型的最小值（负值）除以 -1 时，就会发生溢出。除法运算还可能导致除零错误（参见 *INT33-C 保证除法和取余运算不会导致除零错误*）。

##### 5.3.6.1 不合规代码示例
以下的不合规代码防止了除零错误（*INT33-C 保证除法和取余运算不会导致除零错误*），但是却没有防止补码表示下的有符号整型溢出错误。

```cpp
void func(signed long s_a, signed long s_b) {
    signed long result;
    if (s_b == 0) {
        /* Handle error */
    } else {
        result = s_a / s_b;
    }
    /* ... */
}
```

##### 5.3.6.2 实现细节
在 x86-32 架构下，溢出产生的错误很容易导致拒绝服务攻击。

##### 5.3.6.3 合规解决方案
以下的合规解决方案消除了除零错误和有符号整型溢出的可能性：

```cpp
#include <limits.h>

void func(signed long s_a, signed long s_b) {
    signed long result;
    if ((s_b == 0) || ((s_a == LONG_MIN) && (s_b == -1))) {
        /* Handle error */
    } else {
        result = s_a / s_b;
    }
    /* ... */
}
```
#### 5.3.7 取余
取余运算符用于计算两个整型值相除时的余数。由于很多平台都使用相同的指令实现取余和除法运算，因此取余操作也同样容易导致算术溢出和除零错误（参见 *INT33-C 保证除法和取余运算不会出现除零错误*）。

##### 5.3.7.1 不合规代码示例
许多硬件架构将取余实现为除法运算符的一部分，因此其也可能溢出。当有符号整数类型的最小值（负值）对 -1 取余时，就可能发生溢出，即使这种取余运算的结果在数学上为 0。以下的不合规代码防止了除零错误（*INT33-C 保证除法和取余运算不会导致除零错误*），但是却没有防止有符号整型溢出：

```cpp
void func(signed long s_a, signed long s_b) {
    signed long result;
    if (s_b == 0) {
        /* Handle error */
    } else {
        result = s_a % s_b;
    }
    /* ... */
}
```

##### 5.3.7.2 实现细节
在 x86-32 架构下，有符号整型的取余操作符是使用`idiv`指令代码与除法操作符一起实现的。既然`LONG_MIN / -1`会溢出并导致软件异常，`LONG_MIN % −1`也同样如此。

##### 5.3.7.3 合规解决方案
以下的合规解决方案对取余运算的操作数进行了测试，保证不会出现溢出：

```cpp
#include <limits.h>

void func(signed long s_a, signed long s_b) {
    signed long result;
    if ((s_b == 0 ) || ((s_a == LONG_MIN) && (s_b == -1))) {
        /* Handle error */
    } else {
        result = s_a % s_b;
    }
    /* ... */
}
```

#### 5.3.8 左移位操作符
左移位运算是在两个整数操作数之间执行的。E1 << E2 的结果是 E1 向左移动 E2 个 bit 位，其中空位填充零。C 标准 6.5.7 第 4 段（[ISO/IEC 9899:2011]）表示：

> 如果 E1 是一个有符号类型的非负值，并且 E1 × 2<sup>E2</sup> 能够被结果类型所表示，则就以其作为结果值；否则，该行为是未定义的。
在几乎所有情况下，试图移动负数个 bit 位或者移动超出操作数位数的 bit 位数，都会导致逻辑错误。这一点在 *INT34-C 不要将表达式移动负数位或移动大于等于操作数中存在的位数*中进行说明。

##### 5.3.8.1 不合规代码示例
以下的不合规代码进行左移操作时，对移位数非负，以及移位的数目为有效值的要求进行了验证。其中，宏`PRECISION()`和 函数`popcount()`能够计算任何整数类型的正确精度（参见 *INT35-C 使用正确的整数精度*）。但是，由于代码中未进行溢出检查，因此结果仍然有可能得到一个无法表示的值。

```cpp
#include <limits.h>
#include <stddef.h>
#include <inttypes.h>

extern size_t popcount(uintmax_t);
#define PRECISION(umax_value) popcount(umax_value)

void func(signed long si_a, signed long si_b) {
    signed long result;
    if ((si_a < 0) || (si_b < 0) ||
        (si_b >= PRECISION(ULONG_MAX)) {
        /* Handle error */
    } else {
        result = si_a << si_b;
    }
    /* ... */
}
```

##### 5.3.8.2 合规解决方案
以下的合规解决方案消除了左移位运算中溢出的可能:

```cpp
#include <limits.h>
#include <stddef.h>
#include <inttypes.h>

extern size_t popcount(uintmax_t);
#define PRECISION(umax_value) popcount(umax_value)

void func(signed long si_a, signed long si_b) {
    signed long result;
    if ((si_a < 0) || (si_b < 0) ||
        (si_b >= PRECISION(ULONG_MAX) ||
        (si_a > (LONG_MAX >> si_b))) {
        /* Handle error */
    } else {
        result = si_a << si_b;
    }
    /* ... */
}
```

#### 5.3.9 单目取负
单目取负运算是在一个算符类型的操作数上执行的。在补码表示下，当对有符号整数类型的最小值（负值）进行单目取负操作时，就会发生溢出。

##### 5.3.9.1 不合规代码示例
以下的不合规代码在对有符号操作数`s_a`进行单目取负操作时，可能会导致有符号整型溢出：

```cpp
void func(signed long s_a) {
    signed long result = -s_a;
    /* ... */
}
```

##### 5.3.9.2 合规解决方案
以下的合规解决方案对取负操作进行了测试，以保证不会出现有符号整型溢出的可能：

```cpp
#include <limits.h>

void func(signed long s_a) {
    signed long result;
    if (s_a == LONG_MIN) {
        /* Handle error */
    } else {
        result = -s_a;
    }
    /* ... */
}
```

#### 5.3.10 风险评估
整型溢出可能导致缓冲区溢出并执行攻击者的任何代码。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| INT32-C | 高 | 很可能 | 高 | P9 | L2 |

#### 5.3.11 相关指南
| 文献 | 条目 |
| ---- | ---- |
| [SEI CERT C Coding Standard](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard) | [INT02-C. Understand integer conversion rules](https://www.securecoding.cert.org/confluence/display/c/INT02-C.+Understand+integer+conversion+rules) <br> [INT35-C. Use correct integer precisions](https://www.securecoding.cert.org/confluence/display/c/INT35-C.+Use+correct+integer+precisions) <br> [INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors](https://www.securecoding.cert.org/confluence/display/c/INT33-C.+Ensure+that+division+and+remainder+operations+do+not+result+in+divide-by-zero+errors) <br> [INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand](https://www.securecoding.cert.org/confluence/display/c/INT34-C.+Do+not+shift+an+expression+by+a+negative+number+of+bits+or+by+greater+than+or+equal+to+the+number+of+bits+that+exist+in+the+operand) <br> [ARR30-C. Do not form or use out-of-bounds pointers or array subscripts](https://www.securecoding.cert.org/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts) <br> [ARR36-C. Do not subtract or compare two pointers that do not refer to the same array](https://www.securecoding.cert.org/confluence/display/c/ARR36-C.+Do+not+subtract+or+compare+two+pointers+that+do+not+refer+to+the+same+array) <br> [ARR37-C. Do not add or subtract an integer to a pointer to a non-array object](https://www.securecoding.cert.org/confluence/display/c/ARR37-C.+Do+not+add+or+subtract+an+integer+to+a+pointer+to+a+non-array+object) <br> [MSC15-C. Do not depend on undefined behavior](https://www.securecoding.cert.org/confluence/display/c/MSC15-C.+Do+not+depend+on+undefined+behavior) <br> [CON08-C. Do not assume that a group of calls to independently atomic methods is atomic](https://www.securecoding.cert.org/confluence/display/c/CON08-C.+Do+not+assume+that+a+group+of+calls+to+independently+atomic+methods+is+atomic) |
| [CERT Oracle Secure Coding Standard for Java](https://www.securecoding.cert.org/confluence/display/java/SEI+CERT+Oracle+Coding+Standard+for+Java) | [INT00-J. Perform explicit range checking to avoid integer overflow](https://www.securecoding.cert.org/confluence/display/java/NUM00-J.+Detect+or+prevent+integer+overflow) |
| [ISO/IEC TR 24772:2013](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-ISO-IECTR24772-2013) | Arithmetic Wrap-Around Error [FIF] |
| [ISO/IEC TS 17961](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-ISO-IECTS17961) | Overflowing signed integers [intoflow] |
| [MITRE CWE](http://cwe.mitre.org/) | [CWE-129](http://cwe.mitre.org/data/definitions/129.html), Improper Validation of Array Index <br> [CWE-190](http://cwe.mitre.org/data/definitions/190.html), Integer Overflow or Wraparound |

### 5.4 INT33-C 保证除法和取余运算不会导致除零错误
C 标准认为在以下条件下进行除法或取余运算将会导致未定义行为：

| UB | Description |
| -- |
| [45](https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_45) | / 或 % 运算符的第二个操作数为零（6.5.5） |

因此，必须保证除法和取余运算不会导致除零错误。

#### 5.4.1 除法
除法操作符（/）的结果是第一个操作数除以第二个操作数的商。除法操作可能会导致除零错误。此外，在补码表示的有符号整数除法中，当有符号整数类型的最小值（负值）除以 -1 时，就会发生溢出（参见 *INT32-C 保证有符号整数运算不会导致溢出*）。

##### 5.4.1.1 不合规代码示例
以下不合规代码防止了有符号整型溢出，符合 *INT32-C 保证有符号整数运算不会导致溢出*的规定，但是却没有防止有符号操作数`s_a`和`s_b`进行除法运算时可能出现的除零错误：

```cpp
#include <limits.h>

void func(signed long s_a, signed long s_b) {
    signed long result;
    if ((s_a == LONG_MIN) && (s_b == -1)) {
        /* Handle error */
    } else {
        result = s_a / s_b;
    }
    /* ... */
}
```

##### 5.4.1.2 合规解决方案
以下的合规解决方案对除法操作进行了测试，以保证不会出现除零错误或有符号整型溢出的可能：

```cpp
#include <limits.h>

void func(signed long s_a, signed long s_b) {
    signed long result;
    if ((s_b == 0) || ((s_a == LONG_MIN) && (s_b == -1))) {
        /* Handle error */
    } else {
        result = s_a / s_b;
    }
    /* ... */
}
```

#### 5.4.2 取余
取余运算符提供了求取两个操作数相除时的产生的余数的操作。

##### 5.4.2.1 不合规代码示例
以下不合规代码防止了有符号整型溢出，符合 *INT32-C 保证有符号整数运算不会导致溢出*的规定，但是却没有防止有符号操作数 s_a 和 s_b 进行取余运算时可能出现的除零错误：

```cpp
#include <limits.h>

void func(signed long s_a, signed long s_b) {
    signed long result;
    if ((s_a == LONG_MIN) && (s_b == -1)) {
        /* Handle error */
    } else {
        result = s_a % s_b;
    }
    /* ... */
}
```

##### 5.4.2.2 合规解决方案
以下的合规解决方案对取余操作进行了测试，以保证不会出现除零错误或有符号整型溢出的可能：

```cpp
#include <limits.h>

void func(signed long s_a, signed long s_b) {
    signed long result;
    if ((s_b == 0 ) || ((s_a == LONG_MIN) && (s_b == -1))) {
        /* Handle error */
    } else {
        result = s_a % s_b;
    }
    /* ... */
}
```

#### 5.4.3 风险评估
除零错误可能导致程序异常退出（abnormal program termination）和拒绝服务。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| INT33-C | 低 | 很可能 | 中 | P6 | L2 |

#### 5.4.4 相关指南

| 文献 | 条目 |
| ---- | ---- |
| [SEI CERT C Coding Standard](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard) | [INT32-C. Ensure that operations on signed integers do not result in overflow](https://www.securecoding.cert.org/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow)  |
| [CERT Oracle Secure Coding Standard for Java](https://www.securecoding.cert.org/confluence/display/java/SEI+CERT+Oracle+Coding+Standard+for+Java) | [NUM02-J. Ensure that division and remainder operations do not result in divide-by-zero errors](https://www.securecoding.cert.org/confluence/display/java/NUM02-J.+Ensure+that+division+and+remainder+operations+do+not+result+in+divide-by-zero+errors) |
| [ISO/IEC TS 17961](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-ISO-IECTS17961) | Integer division errors [diverr] |
| [MITRE CWE](http://cwe.mitre.org/) | [CWE-369](http://cwe.mitre.org/data/definitions/369.html), Divide By Zero |

### 5.5 INT34-C 不要将表达式移动负数位或移动大于等于操作数中存在的位数
移位操作包括形式为 shift-expression << additive-expression 的左移操作，以及形式为 shift-expression >> additive-expression 的右移操作。首先，会在具有整数类型的操作数上执行标准的整数提升动作。结果的类型是是提升后的左操作数的类型。如果右操作数的值为负值或大于等于升位后的左操作数的宽度，则该行为是未定义的。

表达式移位的位数不能为负或大于等于提升后的左操作数精度。整数类型的精度是它用来表示值的位数，不包括任何符号位和填充位。对于无符号整数类型，宽度和精度是相同的; 而对于有符号整数类型，宽度大于精度。本规则使用精度而不是宽度，因为几乎在所有情况下，试图移位大于或等于操作数精度的位数就会导致错误（逻辑错误）。逻辑错误不同于溢出，后者只是表示形式方面的缺陷。 一般来说，只应该在无符号操作数上执行移位操作（参见 *INT13-C. Use bitwise operators only on unsigned operands*）。

#### 5.5.1 不合规代码示例（左移位，无符号类型）

`E1 << E2`的结果是`E1`左移`E2`个位的位置; 空位填充零。下图说明了左移操作：

![左移](整数（INT）/left-shift.jpg)

根据C标准，如果`E1`是无符号类型，则结果为使用 E1 * 2<sup>E2</sup> 对“结果类型中可表示的最大值加1”进行取模运算得到的值。

该不合规的代码示例无法确保右操作数小于提升后的左操作数的精度：

```cpp
void func(unsigned int ui_a, unsigned int ui_b) {
  unsigned int uresult = ui_a << ui_b;
  /* ... */
}
```

#### 5.5.2 合规解决方案（左移位，无符号类型）
此合规解决方案消除了移位的位数大于或等于左操作数精度的可能性：

```cpp
#include <limits.h>
#include <stddef.h>
#include <inttypes.h>

extern size_t popcount(uintmax_t);
#define PRECISION(x) popcount(x)

void func(unsigned int ui_a, unsigned int ui_b) {
  unsigned int uresult = 0;
  if (ui_b >= PRECISION(UINT_MAX)) {
    /* Handle error */
  } else {
    uresult = ui_a << ui_b;
  }
  /* ... */
}
```

`PRECISION（）`宏和`popcount（）`函数为所有整数类型都提供了正确的精度（参见 *INT35-C 使用正确的整数精度*）。

规则 *INT30-C 保证无符号整数运算不会导致回绕中* 的异常**INT30-EX3**允许由左移无符号整数类型而引起的取模行为。


#### 5.5.3 不合规代码示例（左移位，有符号类型）
`E1 << E2`的结果是`E1`左移`E2`个位的位置，空位填充零。如果`E1`是一个有符号类型的非负值，并且 E1 × 2<sup>E2</sup> 能够被结果类型所表示，则就以其作为结果值；否则，该行为是未定义的。

该不合规的代码示例不能确保左和右操作数具有非负值，以及右操作数小于提升后的左操作数的精度。不过该示例符合 *INT32-C 保证无符号整数运算不会导致溢出* 的规则，检查了有符号整数是否会溢出。

```cpp
#include <limits.h>
#include <stddef.h>
#include <inttypes.h>

void func(signed long si_a, signed long si_b) {
  signed long result;
  if (si_a > (LONG_MAX >> si_b)) {
    /* Handle error */
  } else {
    result = si_a << si_b;
  }
  /* ... */
}
```

根据规则 *INT13-C. Use bitwise operators only on unsigned operands*，移位运算符和其他位运算符只能用于无符号整数操作数。

#### 5.5.4 合规解决方案（左移位，有符号类型）
除了检查溢出，这个合规解决方案还会确保左和右操作数都是非负值，并且右操作数小于提升后的左操作数的精度：

```cpp
#include <limits.h> 
#include <stddef.h> 
#include <inttypes.h> 

extern size_t popcount(uintmax_t); 
#define PRECISION(x) popcount(x) 

void func(signed long si_a, signed long si_b) { 
  signed long result; 
  if ((si_a < 0) || (si_b < 0) || 
      (si_b >= PRECISION(ULONG_MAX)) || 
      (si_a > (LONG_MAX >> si_b))) { 
    /* Handle error */ 
  } else { 
    result = si_a << si_b; 
  }
  /* ... */
}
```

#### 5.5.5 不合规代码示例（右移位）
`E1 >> E2`的结果是`E1`右移`E2`个 bit 位。如果`E1`是无符号类型，或者如果`E1`是有符号类型的非负值，那么结果的值是 E1 / 2<sup>E2</sup> 的商的整数部分。如果`E1`是有符号类型的负值，则结果值是由编译器实现定义的，可能是算术（有符号）移位：

![算术移位](整数（INT）/arithmetic-shift.jpg)

或者是逻辑（无符号）移位：

![逻辑移位](整数（INT）/logical-shift.jpg)

下面的不合规示例代码没有测试右操作数是否大于或等于提升后的左操作数的精度，因此可能出现未定义的行为：

```cpp
void func(unsigned int ui_a, unsigned int ui_b) { 
  unsigned int uresult = ui_a >> ui_b; 
  /* ... */
}
```

当使用有符号操作数时，对右移位是实现为算术移位（有符号）还是逻辑移位（无符号）做出假设也可能会导致易受攻击的安全漏洞（参见 *INT13-C. Use bitwise operators only on unsigned operands*）。

#### 5.5.6 合规解决方案（右移位）
此合规解决方案消除了移位位数大于或等于左操作数的精度的可能性：

```cpp
#include <limits.h>
#include <stddef.h>
#include <inttypes.h>

extern size_t popcount(uintmax_t);
#define PRECISION(x) popcount(x)

void func(unsigned int ui_a, unsigned int ui_b) {
  unsigned int uresult = 0;
  if (ui_b >= PRECISION(UINT_MAX)) {
    /* Handle error */
  } else {
    uresult = ui_a >> ui_b;
  }
  /* ... */
}
```

#### 5.5.7 实现细节
对于移位数为负数或大于类型宽度的数的情况，GCC 没有提供选项来决定是进行结果可预期的处理还是陷入异常; 它们都被视为未定义的。处理器可能通过对类型宽度取模来减少移位量。例如，在x86-32上使用以下的指令来实现右移32位：

```
sarl   %cl, %eax
```

sarl指令从 ％cl 获取最低有效5位的位掩码，来产生范围[0,31]中的值，然后将 ％eax 移位相同的位数。在 64 位系统上的指令如下：

```
// 64-bit right shifts on IA-32 platforms become 
shrdl  %edx, %eax 
sarl   %cl, %edx 
```

其中 ％eax 存储待移位的双字中的最低有效位，％edx 存储最高有效位。

#### 5.5.8 风险评估
虽然在C中移位的位数为负数位或移位大于或等于提升后的左操作数宽度的数会导致未定义的行为，但是这种风险通常较低，因为处理器频繁地通过取模类型宽度来减少移位位数。

| 规则 | 严重性 | 可能性 | 修补成本    | 优先级 | 级别 |
|--------|
| INT34-C | 低 | 不太可能 | 中 | P2 | L3 |

#### 5.5.9 相关指南

| 文献 | 条目 |
| ---- | ---- |
| [SEI CERT C Coding Standard](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard) | [INT13-C. Use bitwise operators only on unsigned operands](https://www.securecoding.cert.org/confluence/display/c/INT13-C.+Use+bitwise+operators+only+on+unsigned+operands) <br> [INT35-C. Use correct integer precisions](https://www.securecoding.cert.org/confluence/display/c/INT35-C.+Use+correct+integer+precisions) <br> [INT32-C. Ensure that operations on signed integers do not result in overflow](https://www.securecoding.cert.org/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow) |
| [ISO/IEC TR 24772:2013](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-ISO-IECTR24772-2013) | Arithmetic Wrap-Around Error [FIF] |

### 5.6 INT35-C 使用正确的整数精度
在 C 中整数类型包含“大小”和“精度”两部分。“大小”表示一个对象使用的字节数，可以通过 sizeof 运算符得到任何对象或类型的“大小”。一个整数类型的"精度"是它用来表示值的位数，不包括任何符号位和填充位。

填充位有助于表示整数的大小，但不影响精度。因此，根据整数类型的大小推断它的精度可能会得到过大的值，那么对于这些类型的数值范围就可能会导致不正确的假设。程序员应该在代码中使用正确的整数精度，特别是在使用填充位的架构或严格遵循标准（追求可移植性）的程序上，不应该使用 sizeof 运算符来计算整数类型的精度。

#### 5.6.1 不合规代码示例
这个不合规的代码示例演示了一个函数，它的功能是计算输入参数的2次方。为了符合 *INT34-C 不要将表达式移动负数位或移动大于等于操作数中存在的位数* 的规定，防止未定义的行为，该函数确保了参数要小于存储`unsigned int`类型值的位数。

```cpp
#include <limits.h>

unsigned int pow2(unsigned int exp) {
  if (exp >= sizeof(unsigned int) * CHAR_BIT) {
    /* Handle error */
  }
  return 1 << exp;
}
```

然而，如果这个代码运行在这样一个平台上，其中`unsigned int`有一个或多个填充位，它仍然可能导致`exp`的值太大。例如，在一个平台上用 64 位来存储无符号整数，但仅使用 48 位来表示值，左移 56 位将导致未定义的行为。

#### 5.6.2 合规解决方案
此合规解决方案使用`popcount()`函数，该函数会针对任意整数，计算其在无符号整数上设置的位数，并由此确定整数类型（有符号或无符号）的精度。

```cpp
#include <stddef.h>
#include <stdint.h>

/* Returns the number of set bits */
size_t popcount(uintmax_t num) {
 size_t precision = 0;
  while (num != 0) {
    if (num % 2 == 1) {
      precision++;
    }
    num >>= 1;
  }
  return precision;
}
#define PRECISION(umax_value) popcount(umax_value)
```

该实现会用一个类型通用宏来替换`PRECISION()`宏，类型通用宏会返回一个整数常量表达式，该常量表达式是该实现的指定类型的精度。此返回值可以在任何一个可以使用整数常量表达式的地方使用，例如在静态断言中。（参见 *DCL03-C. Use a static assertion to test the value of a constant expression*）例如，下面的类型通用宏可以用于IA-32架构的特定实现：

```cpp
#define PRECISION(value)  _Generic(value, \
  unsigned char : 8, \
  unsigned short: 16, \
  unsigned int : 32, \
  unsigned long : 32, \
  unsigned long long : 64, \
  signed char : 7, \
  signed short : 15, \
  signed int : 31, \
  signed long : 31, \
  signed long long : 63)
```

`pow2()`函数的修订版本使用`PRECISION()`宏来确定无符号类型的精度：

```cpp
#include <stddef.h>
#include <stdint.h>
#include <limits.h>
extern size_t popcount(uintmax_t);
#define PRECISION(umax_value) popcount(umax_value)
unsigned int pow2(unsigned int exp) {
  if (exp >= PRECISION(UINT_MAX)) {
    /* Handle error */
  }
  return 1 << exp;
}
```

#### 5.6.3 实现细节
一些平台,比如 Cray Linux 环境（CLE; Cray XT CNL 计算节点支持）提供一个`_popcnt`指令可以代替`popcount()`函数。

```cpp
#define PRECISION(umax_value) _popcnt(umax_value)
```

#### 5.6.4 风险评估
错误的整数精度大小可以允许无效的精确参数的操作，比如如位移，这会导致未定义的行为。

| 规则 | 严重性 | 可能性 | 补救代价 | 优先级 | 级别 |
| ---- | ---- | ---- | ---- | ---- | ---- | 
| INT35-C | 低 | 不太可能 | 中 | P2 | L3 |

### 5.7 INT36-C 指针转换为整数或整数转换为指针
虽然程序员在C语言中经常使用整数和指针的互换，但是指针到整数和整数到指针的转换是由实现定义的。

整数和指针之间的转换可能会产生不期望的后果，这取决于编译器实现。根据 C 语言标准 6.3.2.3 条款 [ISO/IEC 9899:2011]：

>整数可以转换为任何指针类型。 除非先前指定，否则结果是实现定义的，可能未正确对齐，可能不指向引用类型的实体，并且可能是陷阱表示形式。

>任何指针类型都可以转换为整数类型。 除非先前指定，否则结果是实现定义的。如果结果不能在整数类型中表示，则该行为是未定义的。结果不需要在任何整数类型的值的范围内。

如果生成的指针未正确对齐，或不指向引用类型的实体，或者是一个陷阱表示（[trap representation](https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-traprepresentation)），请勿将整数类型转换为指针类型。

如果结果不能在整数类型中表示，请不要将指针类型转换为整数类型（参见 [undefined behavior 24](https://www.securecoding.cert.org/confluence/display/c/CC.+Undefined+Behavior#CC.UndefinedBehavior-ub_24)）。

指针和整数之间的映射必须与执行环境的寻址结构一致。 例如，在具有分段存储器模型的体系结构上可能出现问题。

#### 5.7.1 不合规代码示例
指针的大小可以大于整数的大小，例如在指针长度为 64 位且无符号整数长度为 32 位的实现中。此代码示例在此类实现上不合规，因为转换为 64 位指针的结果无法以 32 位整数类型来表示：

```cpp
void f(void) {
  char *ptr;
  /* ... */
  unsigned int number = (unsigned int)ptr;
  /* ... */
}
```

#### 5.7.2 合规解决方案
任何指向`void`的有效指针都可以转换为`intptr_t`或`uintptr_t`，并且不会改变它的值（参见**INT36-EX2**）。C 标准保证指向`void`的指针可以转换为指向任何对象类型的指针，或者转换回`void`，并且结果必须等于原始指针。 因此，在支持`uintptr_t`类型的实现上，允许像该合规解决方案中这样，直接从`char *`指针转换为`uintptr_t`。

```cpp
#include <stdint.h>

void f(void) {
  char *ptr;
  /* ... */
  uintptr_t number = (uintptr_t)ptr;
  /* ... */
}
```

#### 5.7.3 不合规代码示例
在这个不合规的代码示例中，指针`ptr`被转换为整数值。数字的高阶 9 位用于保存标志值，并将结果转换回指针。此示例在指针长度为 64 位且无符号整数长度为 32 位的实现上不合规，因为转换为 64 位指针的结果不能以 32 位整数类型表示。

```cpp
void func(unsigned int flag) {
  char *ptr;
  /* ... */
  unsigned int number = (unsigned int)ptr;
  number = (number & 0x7fffff) | (flag << 23);
  ptr = (char *)number;
}
```

在Emacs的早期版本中使用了类似的方案，限制了其可移植性，并阻止了编辑大于 8MB 的文件的能力。

#### 5.7.4 合规解决方案
该合规解决方案使用结构来提供指针和标志值的存储。此解决方案可移植到不同字大小（小于和大于 32 位）的机器，即使在指针无法以任何整数类型表示时仍可正常工作。

```cpp
struct ptrflag {
  char *pointer;
  unsigned int flag : 9;
} ptrflag;

void func(unsigned int flag) {
  char *ptr;
  /* ... */
  ptrflag.pointer = ptr;
  ptrflag.flag = flag;
}
```

#### 5.7.5 不合规代码示例
有时需要在特定位置访问存储器，需要一个字面整数到指针的转换。 在这个不合规的代码中，指针直接设置为整数常量，这样无法知道结果是否是符合预期的：

```cpp
unsigned int *g(void) {
  unsigned int *ptr = 0xdeadbeef;
  /* ... */
  return ptr;
}
```
此赋值的结果是实现定义的，可能未正确对齐，可能不指向引用类型的实体，并且可能是陷阱表示。

#### 5.7.6 合规解决方案
添加显式转换可以帮助编译器将整数值转换为有效指针。一种常见的技术是将整数分配给类型为`intptr_t`或`uintptr_t`的`volatile`限定对象，然后将整数值分配给指针：

```cpp
unsigned int *g(void) {
  volatile uintptr_t iptr = 0xdeadbeef;
  unsigned int *ptr = (unsigned int *)iptr;
  /* ... */
  return ptr;
}
```

#### 5.7.7 例外
**INT36-C-EX1：** 空指针可以转换为整数；它取值为0。同样的，整数值0也可以转换为指针；它变为空指针。

**INT36-C-EX2：** 任何指向 void 的有效指针都可以转换为`intptr_t`或`uintptr_t`或它们的底层类型，并且返回值不会改变。不建议使用底层类型替换`intptr_t`或`uintptr_t`类型，因为它限制了可移植性。

```cpp
#include <assert.h>
#include <stdint.h>

void h(void) {
  intptr_t i = (intptr_t)(void *)&i;
  uintptr_t j = (uintptr_t)(void *)&j;
  void *ip = (void *)i;
  void *jp = (void *)j;

  assert(ip == &i);
  assert(jp == &j);
}
```

#### 5.7.8 风险评估
从指针转换到整数或从整数转换到指针，会导致不可移植的代码，并可能创建意外的指向无效内存的指针。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 |级别 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| INT36-C | 低 | 有可能 | 高 | P2 | L3 |

#### 5.7.9 相关指南

| 文献 | 条目 |
| ---- | ---- |
| [MITRE CWE](http://cwe.mitre.org/) | [CWE-190](http://cwe.mitre.org/data/definitions/190.html), Integer Overflow or Wraparound |

## 6 浮点数(FLP)

### 6.1 FLP30-C 不要使用浮点数作为循环计数器
由于浮点数实际上表示的是实数，所以我们经常会错误地假定它们可以精确地表示任何简单分数。和整数一样，浮点数也有表示范围的限制，二进制浮点数并不能精确地表示所有实数，即使它们可以用少量位数的十进制数表示。

另外，因为浮点数可以表示大的数值，所以程序员经常错误地假定它们可以表示那些数值的所有有效数字。为了获得大的表示范围，浮点数维持固定的位数来表示精度（也称为有效位数）和指数，这就限制了它们能表示的有符号数的个数。

不同的实现具有不同的精度限制，为了保持代码可移植性，浮点型变量不能用作循环计数变量。

#### 6.1.1 不合规代码示例

在这个不合规的代码示例中，一个浮点型变量被用作循环计数器，十进制数0.1作为重复小数，但是由于0.1是用二进制表示，存在误差，根据这里的实现，循环可能重复9或10次才能结束。
```cpp
void func(void) {
  for (float x = 0.1f; x <= 1.0f; x += 0.1f) {
    /* Loop may iterate 9 or 10 times */
  }
}
```

例如，当使用GCC或Microsoft Visual Studio 2013编译并在x86处理器上执行时，循环只执行了9次。

#### 6.1.2 合规解决方案
在此兼容解决方案中，循环计数器是一个整数，代码中用到的浮点值是从该整数得出：
```cpp
#include <stddef.h>

void func(void) {
  for (size_t count = 1; count <= 10; ++count) {
    float x = count / 10.0f;
    /* Loop iterates exactly 10 times */
  }
}
```


#### 6.1.3 不合规代码示例
在这个不合规代码示例中，浮点循环计数器增量太小，修改后的值不能达到其精度要求：
```cpp
void func(void) {
  for (float x = 100000001.0f; x <= 100000010.0f; x += 1.0f) {
    /* Loop may not terminate */
  }
}
```
在许多实现上，上面这段代码是无限循环。

#### 6.1.4 合规解决方案
在此合规解决方案中，循环计数器是从其浮点值导出的整数，变量x在每次循环中被增加与上面非合规代码中相同的浮点值。
```cpp
void func(void) {
  for (size_t count = 1; count <= 10; ++count) {
    float x = 100000000.0f + (count * 1.0f);
    /* Loop iterates exactly 10 times */
  }
}
```

#### 6.1.5 风险评估
使用浮点变量作为循环计数器可能导致非预期行为。

| 规则    | 严重性 | 可能性 | 修补成本 | 优先级 | 级别 |
|---------|--------|--------|----------|--------|------|
| FLP30-C | 低     | 可能   | 低       | P6     | L2   |

#### 6.1.6 相关指南
ISO/IEC TR 24772:2013 Floating-Point Arithmetic(浮点运算)[FLP]

### 6.2 FLP32-C 防止或检测数学函数中的定义域和值域错误
值域错误的一个实例是对一个负数的求平方根，如sqrt(-1.0)在实数运算中是没有意义的。另一方面，10的100万次方pow(10.,1e6)，由于浮点数范围的限制，很可能无法用浮点形式表示，从而导致值域错误。在上述两种情况下函数都会返回结果，但返回的结果是不正确的。极值错误的一个例子是log(0.0)，结果是导致负无穷大。

在函数调用之前，程序员通过对参数进行仔细的边界检查，可以防止定义域错误和极值错误，并在出现错误后采取相应的措施。

值域错误通常无法预防，因为它们依赖于浮点数的实现以及所使用的函数。相对于预防值域错误，更好的办法是检查值域错误，并在发生值域错误时采取适当的行动。

下表列出了double型的标准数学函数，以及为了保证合适定义域而进行的检查，并指出它们是否会导致值域错误及极值错误。为了节省篇幅，表中省略了这些这些函数的float和long double型实现。如果一个函数具有特定的定义域，程序员必须检查其输入值的合法性，同时程序员还必须检查可能发生的值域错误。本表中未列出的标准数学函数，如fabs()没有定义域限制，它不会导致值域错误或极值错误。


#### 6.2.1 定义域和极值检查
处理定义域错误和极值错误最可靠的方法是通过预先检查参数范围来防止它们，示例代码如下：
```cpp
double safe_sqrt(double x) {
  if (x < 0) {
    fprintf(stderr, "sqrt requires a nonnegative argument");
    /* Handle domain / pole error */
  }
  return sqrt (x);
}
```

#### 6.2.2 值域检查
程序员通常不能阻止值域错误，因此处理值域错误最可靠的办法在它们发生时检查它们，并采取相应措施。

对数学函数错误条件的准确处理是相当复杂的。在C11标准的7.12.1
节中对浮点溢出定义了如下的行为：

*如果数学结果的量级是有限的但过于庞大，大到这个结果无法在不产生四舍五入错误的情况下用指定类型的对象表示，就会出现浮点结果溢出。如果一个浮点结果溢出，并且默认的四舍五入生效，则该函数根据返回类型返回HUGE\_VAL、
HUGE\_VALF或HUGE\_VALL，并且返回值的符号和函数正确值的符号相同。如果整数表达式math\_errhandling
&MATH\_ERRNO为非零值，整数表达式errno就获取ERANGE的值;
如果整数表达式math\_errhandling & MATH_ERREXCEPT为非零值，就会产生浮点溢出异常。*

通过将返回值与HUGE\_VAL或0进行比较，在如下几种情况下，更倾向于不做错误检查：

-   一般来说，这些是合法（尽管不太可能）数据值。
-   进行这样的测试需要详细了解每个数学函数的各种错误返回。
-   HUGE\_VAL和0等多种返回结果都是可能的，程序员必须知道哪些情况下返回哪些结果。
-   不同版本的库函数其错误返回行为不尽相同。

使用errno检查数学错误是比较困难的，因此编译器可能并不会设置errno。对于真正的函数实现，程序员可以通过检查math\_errhandling&MATH\_ERRNO是否非零来判断编译器是否设置errno。

System V接口定义第三版（SVID3）[UNIX 1992]对数学库的错误处理提供了更多的控制。程序员可以定义一个名为matherr的函数，当一个数学函数出现错误的时候被调用。matherr函数可以打印诊断、终止执行或指定所需返回值。C或POSIX尚未采纳matherr()，因此不具有可移植性。

当math\_errhandling被定义的时候，下面的错误处理模板使用C标准函数处理浮点错误C宏，并提示应该使用它们;否则它就检查errno。
```cpp
#include <math.h>
#include <fenv.h>
#include <errno.h>

/* ... */
/* Use to call a math function and check errors */
{
  #pragma STDC FENV_ACCESS ON

  if (math_errhandling & MATH_ERREXCEPT) {
    feclearexcept(FE_ALL_EXCEPT);
  }
  errno = 0;

  /* Call the math function */

  if ((math_errhandling & MATH_ERRNO) && errno != 0) {
    /* Handle range error */
  } else if ((math_errhandling & MATH_ERREXCEPT) &&
             fetestexcept(FE_INVALID | FE_DIVBYZERO |
                          FE_OVERFLOW | FE_UNDERFLOW) != 0) {
    /* Handle range error */
  }
}
```

关于如何检查浮点错误的更多信息，参见“FLP03-C，检测和处理浮点错误”。

#### 6.2.3 不合规代码示例（sqrt()）
这段不合规代码示例了求x的平方根：
```cpp
#include <math.h>

void func(double x) {
 double result;
  result = sqrt(x);
}
```

但是，这段代码会产生一个值域x为负的错误。

#### 6.2.4 合规解决方案（sqrt()）
由于此函数有定义域错误，但没有值域错误，边界检查可以用来防止定义域错误：
```cpp
#include <math.h>

void func(double x) {
  double result;

  if (isless(x, 0.0)) {
    /* Handle domain error */
  }
  result = sqrt(x);
}
```


#### 6.2.5 不合规代码示例（sinh()值域错误）
这段不合规代码暴露了sinh函数的不足：
```cpp
#include <math.h>

void func(double x) {
  double result;
  result = sinh(x);
}
```

如果x值很大的话此代码可能会产生值域错误。

#### 6.2.6 合规解决方案（sinh()值域错误）
由于此函数没有定义域错误，但可能有值域错误，程序员必须检查值域错误并采取相应措施：
```cpp
#include <math.h>
#include <fenv.h>
#include <errno.h>

void func(double x) {
  double result;
  {
    #pragma STDC FENV_ACCESS ON
    if (math_errhandling & MATH_ERREXCEPT) {
      feclearexcept(FE_ALL_EXCEPT);
    }
    errno = 0;

    result = sinh(x);

    if ((math_errhandling & MATH_ERRNO) && errno != 0) {
      /* Handle range error */
    } else if ((math_errhandling & MATH_ERREXCEPT) &&
               fetestexcept(FE_INVALID | FE_DIVBYZERO |
                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {
      /* Handle range error */
    }
  }

  /* Use result... */
}
```

#### 6.2.7 不合规代码示例（pow()）
这段不合规代码求x的y次方：
```cpp
#include <math.h>

void func(double x, double y) {
  double result;
  result = pow(x, y);
}
```
当x是负值，y不是整数值，或者当x和y均为0时会产生一个定义域错误。当x为0，y是负数的时候，会导致值域错误或者极值错误，当结果不能被double类型表示的时候会出现值域错误。

#### 6.2.8 合规解决方案（pow()）
由于pow()函数会产生定义域错误、极值错误以及值域错误，程序员必须首先检查x和y在合适的范围内，以保证不产生极值错误，然后还要检测是否发生了值域错误，并采取相应的措施：
```cpp
#include <math.h>
#include <fenv.h>
#include <errno.h>

void func(double x, double y) {
  double result;

  if (((x == 0.0f) && islessequal(y, 0.0)) || isless(x, 0.0)) {
    /* Handle domain or pole error */
  }
   {
    #pragma STDC FENV_ACCESS ON
    if (math_errhandling & MATH_ERREXCEPT) {
      feclearexcept(FE_ALL_EXCEPT);
    }
    errno = 0;

    result = pow(x, y);

    if ((math_errhandling & MATH_ERRNO) && errno != 0) {
      /* Handle range error */
    } else if ((math_errhandling & MATH_ERREXCEPT) &&
               fetestexcept(FE_INVALID | FE_DIVBYZERO |
                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {
      /* Handle range error */
    }
  }

  /* Use result... */
}
```

#### 6.2.9 风险评估
未能防止或检测数学函数的值域和定义域错误可能会导致意外结果。

| 规则    | 严重性 | 可能性 | 修补成本 | 优先级 | 级别 |
|---------|--------|--------|----------|--------|------|
| FLP32-C | 中     | 可能   | 中       | P8     | L2   |

### 6.3 FLP34-C 确保浮点转换在新类型的范围内
如果一个浮点数要被转换为更小范围和精度的浮点类型或整数类型，或者要将一个整型转换为浮点型，该值必须可被目标类型表示。

C标准[ISO/IEC 9899：2011]的第6.3.1.4节表示：

当一个实数浮点类型的有限值转换为一种除\_Bool之外的整数类型的时候，小数部分被丢弃（即截断为0）。如果整数部分的值无法用这种类型的整数表示，其行为是未定义的。

同一条目下的第2款表示：

当一个整型值被转换为一个浮点类型的时候，如果转换的值可以准确的用新类型表示，它将不会被修改，如果转换的值位于这种类型可以表示的范围之内但无法精确的表示，它的结果就是最临近的稍大或稍小值。如果转换的值位于可表示值的范围之外，其行为是未定义的。

同时，第6.3.1.5节表示：

当一种浮点类型被转换为另外一种浮点类型的时候，如果要转换的值可以在新类型中精确表示，则它将不会修改。如果所转换的值位于可表示的值的范围之内但无法准确地表示，其结果是最接近的稍大或稍小的值，如果所转换的值位于可表示的值的范围之外，其行为是未定义的。

见不确定的行为17和18。

这条规则并不适用于支持有符号无限值实现的浮点类型（如IEEE 754）的降级，因为所有的数都在范围内。

#### 6.3.1 不合规代码示例（float转换为int）
如果浮点数f\_a的整数部分不能被int类型的整数容纳，这段不合规代码将出现未定义行为：
```cpp
Void func(float f_a) {
  int i_a;

  /* Undefined if the integral part of f_a cannot be represented. */
  i_a = f_a;
}
```

#### 6.3.2 合规解决方案（float转换为int）
该合规解决方案通过在赋值之前进行测试来确保float值的范围内适合int变量。
```cpp
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stddef.h>
#include <stdint.h>

extern size_t popcount(uintmax_t); /* 参见INT35-C */
#define PRECISION(umax_value) popcount(umax_value)

void func(float f_a) {
  int i_a;

  if (PRECISION(INT_MAX) < log2f(fabsf(f_a)) ||
      (f_a != 0.0F && fabsf(f_a) < FLT_MIN)) {
    /* Handle error */
  } else {
    i_a = f_a;
  }
}
```

#### 6.3.3 不合规代码示例（降级）
这段不合规代码示例将尝试执行将数值截断后赋给目标类型：
```cpp
void func(double d_a, long double big_d) {
  double d_b = (float)big_d;
  float f_a = (float)d_a;
  float f_b = (float)big_d;
}
```

对于这些转换的结果，有可能d_a超出了float类型的范围，或者big_d超出了float或double的范围。如果出现这种情况，在不支持“IEC 60559浮点架构”的实现中，其结果是未定义的。

#### 6.3.4 合规解决方案（降级）
此合规解决方案检查要存储的值是否可以用新类型表示：
```cpp
#include <float.h>
#include <math.h>

void func(double d_a, long double big_d) {
  double d_b;
  float f_a;
  float f_b;

  if (isgreater(fabs(d_a), FLT_MAX) ||
      isless(fabs(d_a), FLT_MIN)) {
    /* Handle error */
  } else {
    f_a = (float)d_a;
  }
  if (isgreater(fabsl(big_d), FLT_MAX) ||
      isless(fabsl(big_d), FLT_MIN)) {
    /* Handle error */
  } else {
    f_b = (float)big_d;
  }
  if (isgreater(fabsl(big_d), DBL_MAX) ||
      isless(fabsl(big_d), DBL_MIN)) {
    /* Handle error */
  } else {
    d_b = (double)big_d;
  }
}
```

#### 6.3.5 风险评估
将浮点值转换为更小范围和精度的浮点值、将浮点值转换为整型值或将整型值转换为浮点型值，这些操作可能会导致数值在目标类型中无法表示，对于不支持附件F规范的浮点数实现，这会导致未定义行为。

| 规则    | 严重性 | 可能性   | 修补成本 | 优先级   |  级别 |
|---------|--------|----------|-------|--------|------|
| FLP34-C | 低     | 不大可能 | 低      | P3     | L3   |

#### 6.3.6 相关指南
ISO/IEC TR 24772:2013    Numeric Conversion Errors(数值转换错误)[FLC]

### 6.4 FLP36-C 将整数值转换为浮点类型时保留精度
较窄的算术类型可以转换为更宽的类型，这不会对数值的大小产生任何影响。
然而，整数类型表示精确值，浮点类型具有有限的精度。

将一个整数值转换为一个浮点值，但是没有足够的精度的话就会导致精度丢失，但不发生运行时异常。

#### 6.4.1 不合规代码示例
在这个不合规例子中，一个long int类型的较大值被转换为float类型的值，不保证能被正确的表示：
```cpp
#include <stdio.h>

int main(void) {
  long int big = 1234567890;
  float approx = big;
  printf("%ld\n", (big - (long int)approx));
  return 0;
}
```
对于大多数浮点数硬件，最接近值1234567890的浮点值是1234567844,因此，该程序将打印值-46。

#### 6.4.2 合规解决方案
该合规解决方案使用double型代替float型。此外，它使用一个断言保证double类型可以表示任何long int型而不丢失精度（参见“INT35-C，使用正确的整数精度”和“MSC11-C，将断言纳入诊断测试中”）。
```cpp
#include <assert.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>

extern size_t popcount(uintmax_t); /* See INT35-C */
#define PRECISION(umax_value) popcount(umax_value)

int main(void) {
    assert(PRECISION(LONG_MAX) <= DBL_MANT_DIG * log2(FLT_RADIX));
    long int big = 1234567890;
    double approx = big;
    printf("%ld\n", (big - (long int)approx));
    return 0;
}
```
在相同的实现中，这个程序打印0，这意味着整数值1234567890被double型无误差的保存了。

#### 6.4.3 风险评估
将整型值转换为没有足够精度的浮点型时，可能会导致精度丢失（丢失最低有效位）。

| 规则     | 严重性  | 可能性    | 修补成本  | 优先级  | 级别  |
|---------|--------|----------|----------|--------|------|
| FLP36-C | 低     | 不大可能   | 中       | P2     | L3   |

### 6.5 FLP37-C 不要使用对象表示来比较浮点值

浮点值的对象是已被实现了的定义。然而，定义一个__STDC_IEC_559__宏应符合IEC 60559浮点标准以及经常被提及的IEEE 754浮点算法[ISO/IEC 9899：2011]。 IEC 60559使用的浮点对象表示是当前使用的最常见的浮点对象表示之一。

所有浮点对象表示使用特定位模式来编码所表示的浮点数的值。然而，浮点值的等价不仅仅由用于表示其值的位模式的编码。例如，如果浮点格式支持负零值（如IEC 60559一样），则-0.0和0.0是等价的，其比较结果为相等，但在对象表示中使用的位模式是不相同的。类似地，如果两个浮点值都是（相同的）NaN，尽管位模式是相同的，但它们的比较结果是不相等的，因为它们不等价。

请不要调用memcmp()之类的函数直接将两个浮点对象就行比较，应该用==和!=运算符来确定两个浮点值相等。

#### 6.5.1 不合规代码示例

在这个不符合要求的代码示例中，memcmp()函数被用来比较两个结构体是否相等，
但是，由于结构体中包含浮点对象，所以代码行为可能达不到程序员的预期。
```cpp
#include <stdbool.h>
#include <string.h>

struct S {
  int i;
  float f;
};

bool are_equal(const struct S *s1, const struct S *s2) {
  if (!s1 && !s2)
    return true;
  else if (!s1 || !s2)
    return false;
  return 0 == memcmp(s1, s2, sizeof(struct S));
}
```

#### 6.5.2 合规解决方案
在这个合规解决方案中，结构成员被单独进行比较：
```cpp
#include <stdbool.h>
#include <string.h>

struct S {
  int i;
  float f;
};

bool are_equal(const struct S *s1, const struct S *s2) {
  if (!s1 && !s2)
    return true;
  else if (!s1 || !s2)
    return false;
  return s1->i == s2->i &&
         s1->f == s2->f;
}
```

#### 6.5.3 风险评估
使用浮点值的对象表示进行比较可能导致不正确的结果，从而导致非预期行为。

| 规则    | 严重性 | 可能性   | 修补成本 | 优先级 | 级别 |
|---------|--------|----------|----------|--------|------|
| FLP37-C | 低     | 不大可能 | 中       | P2     | L2   |

## 7 数组(ARR)

### 7.1 ARR30-C 不要使用超出边界的指针或超出边界的数组下标

#### 7.1.1 不合规代码示例（构造越界指针）
这个不合规代码示例中，函数f()使用index作为一个偏移量来访问静态分配的整数表，并在使用之前验证index，但是函数未拒绝负index索引值。
当index小于零时，在函数的返回语句中的表达式的行为是不确定的。在一些实现中，仅仅是一个加法行为就可能触发硬件陷阱。在其他实现中，在解除引用时，加法可能触发硬件陷阱。其他实现方式中仍可能会产生一个不同于表的解除引用的指针，使用这种指针访问对象可能导致信息暴露或导致错误对象被修改。
```cpp
enum { TABLESIZE = 100 };

static int table[TABLESIZE];

int *f(int index) {
  if (index < TABLESIZE) {
    return table + index;
  }
  return NULL;
}

```

#### 7.1.2 合规解决方案
一个合规解决方案是检测并拒绝无效值index，这些无效值会导致指针运算时产生无效指针：
```cpp
enum { TABLESIZE = 100 };

static int table[TABLESIZE];

int *f(int index) {
  if (index >= 0 && index < TABLESIZE) {
    return table + index;
  }
  return NULL;
}

```

#### 7.1.3 合规解决方案
另一个稍微简单，而且可能更高效的合规解决方案是使用一个无符号类型，这样不仅可以检查负值索引，还同时可避免超出边界正值索引：
```cpp
#include <stddef.h>

enum { TABLESIZE = 100 };

static int table[TABLESIZE];

int *f(size_t index) {
  if (index < TABLESIZE) {
    return table + index;
  }
  return NULL;
}
```

#### 7.1.4 不合规代码示例（解除引用越界指针）
这个不合规的代码示例显示了由W32.Blaster.Worm利用的Windows分布式组件对象模型（DCOM）远程过程调用（RPC）接口中的逻辑缺陷。错误的原因是在GetMachineName()函数中while循环未充分检测边界。当pwszTemp所指向的字符数组中，若开始的MAX_COMPUTERNAME_LENGTH_FQDN + 1个字符中不包含反斜线字符，则在循环迭代的过程中将解除对尾指针的引用，从而出现可利用的未定义行为。最终的攻击允许攻击者将可执行代码注入运行程序中。
```cpp
error_status_t _RemoteActivation(/* ... */,WCHAR *pwszObjectName,...) {
   *phr = GetServerPath(pwszObjectName,&pwszObjectName);
   /* ... */
}

HRESULT GetServerPath(WCHAR *pwszPath, WCHAR **pwszServerPath ){
  WCHAR *pwszFinalPath = pwszPath;
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1];
  hr = GetMachineName(pwszPath, wszMachineName);
  *pwszServerPath = pwszFinalPath;
}

HRESULT GetMachineName(WCHAR *pwszPath,
  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])
{
  pwszServerName = wszMachineName;
  LPWSTR pwszTemp = pwszPath + 2;
  while (*pwszTemp != L'\\')
    *pwszServerName++ = *pwszTemp++;
  /* ... */
}
```

#### 7.1.5 合规解决方案
在这个合规解决方案中，GetMachineName()函数中的while是有界的，当发现终止符、反斜线、或者到达缓冲区的尾部都会终止循环，此代码不会导致缓冲区溢出，即使没有反斜杠字符。
```cpp
HRESULT GetMachineName(
  wchar_t *pwszPath,
  wchar_t wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])
{
  wchar_t *pwszServerName = wszMachineName;
  wchar_t *pwszTemp = pwszPath + 2;
  wchar_t *end_addr
    = pwszServerName + MAX_COMPUTERNAME_LENGTH_FQDN;
  while ((*pwszTemp != L'\\')
     &&((*pwszTemp != L'\0'))
     &&(pwszServerName < end_addr))
  {
    *pwszServerName++ = *pwszTemp++;
  }
  /* ... */
}
```
此合规解决方案仅用于说明，并不一定是Microsoft实施的解决方案。此特定解决方案不一定正确，因为不能保证能找到反斜杠。

#### 7.1.6 不合规代码示例（使用越界索引）
本示例中，不合规函数insert\_in\_table()中使用一个有效索引来将数值存放在一个数组成员中，但仍然发生了越界操作。

首先，函数中对索引pos的大小进行了不正确的验证。pos最初初始化为size大小，函数试图在size大小索引处存储内容，这实际上已越界。

其次，当pos值已大于size时，该函数在增大buffer之前修改了size的大小，如果调用realloc()函数失败，那么下一次调用insert\_in\_table()函数的时候，pos值就可能等于或者大于size值,这时进行内存访问就会出现缓冲区溢出。

第三，函数违反规则“INT30-C，确保无符号整数运算不回绕”，pos加1或者加size\*int的长度（一般为4）时可能会导致回绕。
```cpp
#include <stdlib.h>

static int *table = NULL;
static size_t size = 0;

int insert_in_table(size_t pos, int value) {
  if (size < pos) {
    int *tmp;
    size = pos + 1;
    tmp = (int *)realloc(table, sizeof(*table) * size);
    if (tmp == NULL) {
      return -1;   /* Failure */
    }
    table = tmp;
  }

  table[pos] = value;
  return 0;
}
```

#### 7.1.7 合规解决方案
该合规解决方案使用<=关系运算符正确验证指数pos，确保乘法不会溢出，在调用realloc()成功之前避免修改size大小。
```cpp
#include <stdint.h>
#include <stdlib.h>

static int *table = NULL;
static size_t size = 0;

int insert_in_table(size_t pos, int value) {
  if (size <= pos) {
    if ((SIZE_MAX - 1 < pos) ||
        ((pos + 1) > SIZE_MAX / sizeof(*table))) {
      return -1;
    }

    int *tmp = (int *)realloc(table, sizeof(*table) * (pos + 1));
    if (tmp == NULL) {
      return -1;
    }
    /* Modify size only after realloc() succeeds */
    size  = pos + 1;
    table = tmp;
  }

  table[pos] = value;
  return 0;
}
```

#### 7.1.8 不合规代码示例（索引超出范围的访问）
这段不合规代码示例声明一个7行5列的matrix数组。该函数init_matrix在迭代35次将参数x赋给每个成员，在第一次迭代过程中，j的值达到COLS，此时程序尝试存取元素matrix[0][5]，但实际已超出数组matrix[7][5]列的范围，这时就会导致未定义行为。
```cpp
#include <stddef.h>
#define COLS 5
#define ROWS 7
static int matrix[ROWS][COLS];
void init_matrix(int x) {
  for (size_t i = 0; i < COLS; i++) {
    for (size_t j = 0; j < ROWS; j++) {
      matrix[i][j] = x;
    }
  }
}
```

#### 7.1.9 合规解决方案
该标准的解决方案避免了使用初始化超出范围的指数matrix在同一行主顺序元素作为多维对象是用C语言声明：
```cpp
#include <stddef.h>
#define COLS 5
#define ROWS 7
static int matrix[ROWS][COLS];

void init_matrix(int x) {
  for (size_t i = 0; i < ROWS; i++) {
    for (size_t j = 0; j < COLS; j++) {
      matrix[i][j] = x;
    }
  }
}
```

#### 7.1.10 不合规代码示例（指针超过柔性数组成员范围）
在这个不合规的代码示例中，函数find()试图遍历柔性元素buf的成员。但是由于函数g()没有为buf数组分配存储空间，函数find()中的表达式first++将尝试访问未分配成员的buf数组的末尾。这将导致未定义行为。
```cpp
#include <stdlib.h>

struct S {
  size_t len;
  char buf[];  /* Flexible array member */
};

const char *find(const struct S *s, int c) {
  const char *first = s->buf;
  const char *last  = s->buf + s->len;

  while (first++ != last) { /* Undefined behavior */
    if (*first == (unsigned char)c) {
      return first;
    }
  }
  return NULL;
}

void g(void) {
  struct S *s = (struct S *)malloc(sizeof(struct S));
  if (s == NULL) {
    /* Handle error */
  }
  s->len = 0;
  find(s, 'a');
}
```

#### 7.1.11 合规解决方案
此合规解决方案在确认指针不会越界后才会做增操作。
```cpp
#include <stdlib.h>

struct S {
  size_t len;
  char buf[];  /* Flexible array member */
};

const char *find(const struct S *s, int c) {
  const char *first = s->buf;
  const char *last  = s->buf + s->len;

  while (first != last) { /* Avoid incrementing here */
if (*++first == (unsigned char)c) {

      return first;
    }
  }
  return NULL;
}

void g(void) {
  struct S *s = (struct S *)malloc(sizeof(struct S));
  if (s == NULL) {
    /* Handle error */
  }
  s->len = 0;
  find(s, 'a');
}
```

#### 7.1.12 不合规代码示例（空指针运算）
这段不合规示例代码示例和2008年Adobe Flash Player的一个漏洞利用类似，该代码分配一个内存块并用特定数据进行初始化。
```cpp
#include <string.h>
#include <stdlib.h>

char *init_block(size_t block_size, size_t offset,
                 char *data, size_t data_size) {
  char *buffer = malloc(block_size);
  if (data_size > block_size || block_size - data_size < offset) {
    /* Data won't fit in buffer, handle error */
  }
  memcpy(buffer + offset, data, data_size);
  return buffer;
}
```

但是由于上面的函数未对内存分配成功进行检查，这违反规则:“ERR33-C，检查和处理标准库的错误”。如果内存分配失败，malloc()函数返回一个空指针。这时目标写入地址就由offset来决定，攻击者通过构造特殊的数据以及offset地址，可以将攻击代码写入由攻击者指定的位置，从而导致执行任意代码。

#### 7.1.13 符合解决方案（空指针运算）

该合规解决方案可以确保调用malloc()成功调用。
```cpp
#include <string.h>
#include <stdlib.h>

char *init_block(size_t block_size, size_t offset,
                 char *data, size_t data_size) {
  char *buffer = malloc(block_size);
  if (NULL == buffer) {
    /* Handle error */
  }
  if (data_size > block_size || block_size - data_size < offset) {
    /* Data won't fit in buffer, handle error */
  }
  memcpy(buffer + offset, data, data_size);
  return buffer;
}
```

#### 7.1.14 风险评估
指针或下标越界会导致缓冲区溢出以及越权的任意代码执行。通过读取越界的指针也会导致意外的信息泄露。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 级别   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| ARR30-C | 高    | 很可能  | 高    | P9   | L2   |

##### 7.1.14.1 相关漏洞
CVE-2008-1517是违反本规则的结果。在Mac OS X 10.5.7版本之前,XNU内核以未校验的用户输入索引访问一个数组，攻击者可以传递一个大于数组长度的索引访问数组以外的内存，从而执行任意代码。


### 7.2 　ARR32-C 确保变长数组的大小参数在有效范围内

变长数组（VLA）在本质上与传统C数组相同，主要区别在于它们在声明时使用了一个长度参数而不是一个常量整数表达式，它只能在块范围或函数原型范围内声明。当使用变长数组的时候，可声明一个数组长度变量。
```cpp
{ /* Block scope */
  Char vla[size];
}
```

其中整数表达size和数组vla的声明都在运行时计算，如果提供给变长度数组的size参数不是正整数值，则该行为是未定义的。此外，如果参数过大，程序的行为可能出意想不到的行为。一个攻击者可以利用这一行为来覆盖关键的程序数据。程序员必须确保变长数组的大小参数是在有效范围内。

由于变长度数组是C11有条件支持的特性，它们的可移植通过检测宏__STDC_NO_VLA__来实现，当不支持变长数组实现时，就把__STDC_NO_VLA__设置为1。

#### 7.2.1 不合规代码示例

在这个不合规的代码示例中，变长数组的长度用size来表示，并被声明为size_t类型。然而，size的值可以是零或者过大，这将增大存在安全漏洞的风险。
```cpp
#include <stddef.h>

extern void do_work(int *array, size_t size);

void func(size_t size) {
  int vla[size];
  do_work(vla, size);
}
```

#### 7.2.2 合规解决方案
这个合规解决方案确保了vla数组的size参数处于有效范围（在1和程序员定义的最大值之间）;若size值过大，就使用动态内存分配算法。该解决方案还避免了无符号整数的回绕（当size值足够大的时候），这将导致malloc函数不能为数组分配足够的空间。
```cpp
#include <stdint.h>
#include <stdlib.h>

enum { MAX_ARRAY = 1024 };
extern void do_work(int *array, size_t size);

void func(size_t size) {
  if (0 == size || SIZE_MAX / sizeof(int) < size) {
    /* Handle error */
    return;
  }
  if (size < MAX_ARRAY) {
    int vla[size];
    do_work(vla, size);
  } else {
    int *array = (int *)malloc(size * sizeof(int));
    if (array == NULL) {
      /* Handle error */
    }
    do_work(array, size);
    free(array);
  }
}
```

#### 7.2.3 不合规代码示例（sizeof）

下面的这段不合规代码展示的是定义一个变长数组A，然后使用sizeof操作符在运行时动态计算它的大小。当函数调用的实参大于SIZE\_MAX/(N1* sizeof (int))，这个含有sizeof的表达式就可能回绕，得到的结果比N1 * n2 *
sizeof(int)小，在调用malloc()成功后，会分配少于少n2个元素的数组，这样就会导致循环最后一、二个memset()函数调用在for循环中越界。
```cpp
#include <stdlib.h>
#include <string.h>

enum { N1 = 4096 };

void *func(size_t n2) {
  typedef int A[n2][N1];

  A *array = malloc(sizeof(A));
  if (!array) {
    /* Handle error */
    return NULL;
  }

  for (size_t i = 0; i != n2; ++i) {
    memset(array[i], 0, N1 * sizeof(int));
  }

  return array;
}
```

#### 7.2.4 合规解决方案（sizeof）

这个合规解决方案在回绕发生之前就进行检查，同时也避免了在条件检查到时的后继计算。
```cpp
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

enum { N1 = 4096 };

void *func(size_t n2) {
  if (n2 > SIZE_MAX / (N1 * sizeof(int))) {
    /* Prevent sizeof wrapping */
    return NULL;
  }

  typedef int A[n2][N1];

  A *array = malloc(sizeof(A));
  if (!array) {
    /* Handle error */
    return NULL;
  }

  for (size_t i = 0; i != n2; ++i) {
    memset(array[i], 0, N1 * sizeof(int));
  }
  return array;
}
```

#### 7.2.5 风险评估
如果不能恰当的地指定一个变长数组的长度大小，可能导致任意代码执行或者是堆栈耗尽。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 级别   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| ARR32-C | 高    | 可能   | 高    | P6   | L2   |

#### 7.2.6 相关指南
ISO/IEC TR 24772:2013 Unchecked Array Indexing(未检查的数组索引)[XYZ]

### 7.3 ARR36-C 不要将两个不同数组的指针做减法或者进行比较

若要两个指针相减，两者必须都指向同一个数组对象的元素或者只是这个数组对象最后一个元素的位置。相减的结果是两个数组元素的下标差。否则，得到的结果是不确定行为。

同样，使用关系运算符指针<，<=，>=，和>对指针的相对位置进行比较得出各指针指向元素的相互位置关系，未指向同一个数组的不同指针进行相减或比较将引发未定义的行为。

使用==和!=运算符进行指针的比较具有明确的语义，不论指针是否为空，是否指向相同类型的对象，或者指向数组对象尾部+1的位置，或者是指向一个函数等。

#### 7.3.1 不合规代码示例

在这个不合规代码示例中，指针减操作用于确定数组nums中有多少个可用成员：
```cpp
#include <stddef.h>

enum { SIZE = 32 };

void func(void) {
  int nums[SIZE];
  int end;
  int *next_num_ptr = nums;
  size_t free_elements;

  /* Increment next_num_ptr as array fills */

  free_elements = &end - next_num_ptr;
}
```
这个程序错误地假定nums数组和end变量比邻而居在存储器空间中，但实际上编译器允许在两个变量之间插入填充字节，甚至在内存中对它们重新排序。

#### 7.3.2 合规解决方案
在这个合规的解决方案，nums数组中可用数组成员通过中减去指针next\_num\_ptr的方式获取，同时这个指针可以不被解除引用，它可以用于指针运算。
```cpp
#include <stddef.h>
enum { SIZE = 32 };

void func(void) {
  int nums[SIZE];
  int *next_num_ptr = nums;
  size_t free_elements;

  /* Increment next_num_ptr as array fills */

  free_elements = &(nums[SIZE]) - next_num_ptr;
}
```

#### 7.3.3 例外
**ARR36-C-EX1：**比较同一个结构体对象不同成员的指针是允许的，指向结构体后定义的成员的指针比指向结构体中先定义的成员指针大。

#### 7.3.4 风险评估

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 级别   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| ARR36-C | 中    | 可能   | 中    | P8   | L2   |


### 7.4 ARR37-C 不要对指向非数组对象的指针进行加减操作

指针算术运算只能在引用数组对象元素的指针上执行。

#### 7.4.1 不合规代码示例
这个不合规的代码示例尝试使用指针运算访问结构体成员。这种做法是危险的，因为不能保证结构体成员是连续存放的。
```cpp
struct numbers {
  short num_a, num_b, num_c;
};

int sum_numbers(const struct numbers *numb){
  int total = 0;
  const short *numb_ptr;

  for (numb_ptr = &numb->num_a;
       numb_ptr <= &numb->num_c;
       numb_ptr++) {
    total += *(numb_ptr);
  }
  return total;
}

int main(void) {
  struct numbers my_numbers = { 1, 2, 3 };
  sum_numbers(&my_numbers);
  return 0;
}

```

#### 7.4.2 合规解决方案

可以使用->操作符解引用每个结构成员：
```cpp
total = numb->num_a + numb->num_b + numb->num_c;
```
但是，这种解决方案导致程序难写也难于维护（特别是结构成员较多的时候），这正是不合规代码示例的作者应尽量避免。

#### 7.4.3 合规解决方案
更好的解决方案是定义结构体中包含数组成员，并将数字存放在数组中而不是结构体中，合规代码如下：
```cpp
#include <stddef.h>
 
struct numbers {
  short a[3];
};
 
int sum_numbers(const short *numb, size_t dim) {
  int total = 0;
  for (size_t i = 0; i < dim; ++i) {
    total += numb[i];
  }
 
  return total;
}
 
int main(void) {
  struct numbers my_numbers = { .a[0]= 1, .a[1]= 2, .a[2]= 3};
  sum_numbers(my_numbers.a,
    sizeof(my_numbers.a)/sizeof(my_numbers.a[0])
  );
  return 0;
}
```

数组元素保证了其在内存中是连续存放的，故这个解决方案是完全可移植的。

#### 7.4.4 例外
**ARR37-C-EX1：**任何在内存中的非数组对象可以被认为是只有一个成员的数组，对这样的对象指针进行加1操作会导致指针指向数组的尾部+1的位置，减1的话就又把指针变成了原始指针，这个机理允许如下代码：
```cpp
#include <stdlib.h>
#include <string.h>

struct s {
  char *c_str;
  /* Other members */
};

struct s *create_s(const char *c_str) {
  struct s *ret;
  size_t len = strlen(c_str) + 1;

  ret = (struct s *)malloc(sizeof(struct s) + len);
  if (ret != NULL) {
    ret->c_str = (char *)(ret + 1);
    memcpy(ret + 1, c_str, len);
  }
  return ret;
}
```

这个问题的一个更一般和更安全的解决方案是使用一个柔性数组成员来保证结构体总是的正确对齐，如果需要，可在前后成员之间插入填充。

#### 7.4.5 风险评估

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 级别   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| ARR37-C | 中    | 可能   | 中    | P8   | L2   |


### 7.5 ARR38-C 保证库函数不会产生无效指针
对数组或对象进行修改的C库函数至少需要两个参数：一个指向数组或对象的指针，一个指示要操作的元素或字节数的整数个数。为了实现该规则，一个成员对指针指向的数组或者对象就行计数，以保证成员能被有效访问。假定这个函数的参数会导致函数产生一个指向别处的指针或者指向对象的尾部的指针，这将会导致不确定行为。

在下面的代码中：
```cpp
int arr[5];
int *p = arr;

unsigned char *p2 = (unsigned char *)arr;
unsigned char *p3 = arr + 2;
void *p4 = arr;
```

指针p指向数组的元素个数是sizeof(arr)/sizeof(arr[0])，也就是5，指针p2指向的元素个数是sizeof(arr)也就是20，指针p3指向的元素个数是12因为p3指向arr后两个元素开始的位置。指针p4被处理成unsigned char *型而不是void *类型，所以它和p2是一样的。

#### 7.5.1 Pointer + Integer

以下标准库函数接受指针参数和大小参数，其约束是指针必须指向由大小参数指示的有效内存对象。
| fgets()         | fgetws()       | mbstowcs()     | wcstombs()    |
| --------------- | -------------- | -------------- | ------------- |
| mbrtoc16()      | mbrtoc32()     | mbsrtowcs()    | wcsrtombs()   |
| mbtowc()        | mbrtowc()      | mblen()        | mbrlen()      |
| memchr()        | wmemchr()      | memset()       | wmemset()     |
| strftime()      | wcsftime()     | strxfrm()      | wcsxfrm()     |
| strncat()       | wcsncat()      | snprintf()     | vsnprintf()   |
| swprintf()      | vswprintf()    | setvbuf()      | tmpnam\_s()   |
| snprintf\_s()   | sprintf\_s()   | vsnprintf\_s() | vsprintf\_s() |
| gets\_s()       | getenv\_s()    | wctomb\_s()    | mbstowcs\_s() |
| wcstombs\_s()   | memcpy\_s()    | memmove\_s()   | strncpy\_s()  |
| strncat\_s()    | strtok\_s()    | strerror\_s()  | strnlen\_s()  |
| asctime\_s()    | ctime\_s()     | snwprintf\_s() | swprintf\_s() |
| vsnwprintf\_s() | vswprintf\_s() | wcsncpy\_s()   | wmemcpy\_s()  |
| wmemmove\_s()   | wcsncat\_s()   | wcstok\_s()    | wcsnlen\_s()  |
| wcrtomb\_s()    | mbsrtowcs\_s() | wcsrtombs\_s() | memset\_s()   |

对于接受指针和整数大小的函数调用，给定的整数大小应不大于指针指向的实际的元素个数。

##### 7.5.1.1 不合规代码示例（元素计数）
在这个不合规的代码示例中，在调用wmemcpy()函数时成员计数有误，sizeof运算符返回以字节表示的大小，但wmemcpy()使用的元素成员的的类型是wchar_t * 。
```cpp
#include <string.h>
#include <wchar.h>

static const char str[] = "Hello world";
static const wchar_t w_str[] = L"Hello world";
void func(void) {
  char buffer[32];
  wchar_t w_buffer[32];
  memcpy(buffer, str, sizeof(str)); /* Compliant */
  wmemcpy(w_buffer, w_str, sizeof(w_str)); /* Noncompliant */
}
```

##### 7.5.1.2 合规解决方案（元素计数）
当使用对指针指向的区域进行操作的函数时，程序员必须始终确保元素计数满足函数期望。例如，memcpy()函数期望元素计数基于void*，但wmemcpy()函数期望元素计数基于wchar_t*。在这个合规的解决方案中，类型为T的数组A可通过表达式sizeof(A)/sizeof(T)或sizeof(A)/sizeof(*A)来计数其成员的个数。
```cpp
#include <string.h>
#include <wchar.h>

static const char str[] = "Hello world";
static const wchar_t w_str[] = L"Hello world";
void func(void) {
  char buffer[32];
  wchar_t w_buffer[32];
  memcpy(buffer, str, strlen(str) + 1);
  wmemcpy(w_buffer, w_str, wcslen(w_str) + 1);
}
```

##### 7.5.1.3 不合规代码示例（指针+整数）
这段不合规代码示例了分配一个比可用存储器字节数大的值给变量n
，然后将n传递给了memset()函数。
```cpp
#include <stdlib.h>
#include <string.h>

void f1(size_t nchars) {
  char *p = (char *)malloc(nchars);
  /* ... */
  const size_t n = nchars + 1;
  /* ... */
  memset(p, 0, n);
}
```

##### 7.5.1.4 合规解决方案（指针+整数）
这个合规解决方案确保了n的值不会比p所指向的态分配内存空间大：
```cpp
#include <stdlib.h>
#include <string.h>

void f1(size_t nchars) {
  char *p = (char *)malloc(nchars);
  /* ...  */
  const size_t n = nchars;
  /* ...  */
  memset(p, 0, n);
}
```

##### 7.5.1.5 不合规代码示例（指针+整数）
在这个不合规代码示例中，数组a的元素个数是ARR_SIZE个。由于memset()函数需要用字节数作为入参，数组的大小被sizeof(int)而不是sizeof(long)来进行度量，由于sizeof(int)!=sizeof(long)，这就导致了结构上的无效指针。
```cpp
#include <string.h>

void f2(void) {
  const size_t ARR_SIZE = 4;
  long a[ARR_SIZE];
  const size_t n = sizeof(int) * ARR_SIZE;
  void *p = a;

  memset(p, 0, n);
}
```

##### 7.5.1.6 合规解决方案（指针+整数）
在这个合规的解决方案中，函数memset()所需成员个数被合适的计算。
```cpp
#include <string.h>

void f2(void) {
  const size_t ARR_SIZE = 4;
  long a[ARR_SIZE];
  const size_t n = sizeof(a);
  void *p = a;

  memset(p, 0, n);
}
```

#### 7.5.2 两个指针+一个整数
以下的标准库函数接受两个指针参数和一个大小参数，约束条件是这两个指针必须在由大小参数指示的元素数量的有效内存内。

| memcpy()   | wmemcpy()  | memmove()  | wmemmove() |
| ---------- | ---------- | ---------- | ---------- |
| strncpy()  | wcsncpy()  | memcmp()   | wmemcmp()  |
| strncmp()  | wcsncmp()  | strcpy_s() | wcscpy_s() |
| strcat_s() | wcscat_s() |            |            |

对于具有两个指针和整数大小的调用，给定的大小不应大于任一指针的元素个数。

##### 7.5.2.1 不合规代码示例（两个指针+一个整数）
在这个不合规的代码示例中，n的值被错误地计算，从而导致超过q指向的对象的尾部：
```cpp
#include <string.h>

void  f4() {
  char p[40];
  const char *q = "Too short";
  size_t n = sizeof(p);
  memcpy(p, q, n);
}
```

##### 7.5.2.2 合规解决方案（两个指针+一个整数）
这个合规的解决方案确保了n等于字符数组的长度：
```cpp
#include <string.h>

void f4() {
  char p[40];
  const char *q = "Too short";
  size_t n = sizeof(p) < strlen(q) + 1 ? sizeof(p) : strlen(q) + 1;
  memcpy(p, q, n);
}
```

#### 7.5.3 一个指针+两个整数
如下标准库函数接受一个指针参数和两个大小参数，其约束条件是指针必须指向两个大小参数乘积大小的有效内存对象中。

| bsearch() | bsearch_s() | qsort() | qsort_s() |
| --------- | ----------- | ------- | --------- |
| fread()   | fwrite()    |         |           |

对于入参是指针和两个整数的函数调用，其中一个整数表示单个对象所需的字节数，第二个整数表示有多少个单个对象。两个整数的乘积结果不能比指针指向区域的字节数大。

##### 7.5.3.1 不合规代码示例（一个指针+两个整数）
这个不合规的代码示例中分配了类型为struct
obj的对象大小的内存，该函数检查变量num\_objs是否足够小，以防止回绕。struct obj的大小被16个字节对齐，以保证其符合long long型分布。但是，填充通常取决于目标体系结构，因此这个对象的大小可能不正确，从而得出不正确的元素个数。
```cpp
#include <stdint.h>
#include <stdio.h>

struct obj {
  char c;
  long long i;
};

void func(FILE *f, struct obj *objs, size_t num_objs) {
  const size_t obj_size = 16;
  if (num_objs > (SIZE_MAX / obj_size) ||
      num_objs != fwrite(objs, obj_size, num_objs, f)) {
    /* Handle error */
  }
}
```

##### 7.5.3.2 合规解决方案（一个指针+两个整数）
这个合规解决方案使用sizeof操作符得到对象的正确大小以及由num_objs提供成员个数：
```cpp
#include <stdint.h>
#include <stdio.h>

struct obj {
  char c;
  long long i;
};

void func(FILE *f, struct obj *objs, size_t num_objs) {
  const size_t obj_size = sizeof(*objs);
  if (num_objs > (SIZE_MAX / obj_size) ||
      num_objs != fwrite(objs, obj_size, num_objs, f)) {
    /* Handle error */
  }
}
```

##### 7.5.3.3 不合规代码示例（一个指针+两个整数）
在这个不合规的代码示例中，函数f()调用fread()来读取类型为wchar_t的nitems，每个size的大小字节为一组，把这些内容读到有BUFFER_SIZE个元素的数组wbuf中。但是用于计算的值的表达式nitems数组大小的时候忽略了wchar_t可能大于1这个事实，这就导致fread()函数可能会构造越过数组wbuf尾部的指针，从而访问其并不存在的成员。这种尝试是未定义的行为,这种未定义行为导致的可能后果就是缓冲区溢出。
```cpp
#include <stddef.h>
#include <stdio.h>

void f(FILE *file) {
  enum { BUFFER_SIZE = 1024 };
  wchar_t wbuf[BUFFER_SIZE];

  const size_t size = sizeof(wbuf[0]);
  const size_t nitems = sizeof(wbuf);

  size_t nread = fread(wbuf, size, nitems, file);
  /* ... */
}
```

##### 7.5.3.4 合规解决方案（一个指针+两个整数）
该合规解决方案能保证函数fread()从文件中读取最大条目数：
```cpp
#include <stddef.h>
#include <stdio.h>

void  f(FILE *file) {
  enum { BUFFER_SIZE = 1024 };
  wchar_t wbuf[BUFFER_SIZE];

  const size_t size = sizeof(*wbuf);
  const size_t nitems = sizeof(wbuf) / size;

  size_t nread = fread(wbuf, size, nitems, file);
  /* ... */
}
```

##### 7.5.3.5 不合规代码示例（Heartbleed）
CERT漏洞720951描述了OpenSSL的1.0.1-1.0.1f版本，俗称“心脏出血漏洞”。此漏洞允许攻击者窃取正常情况下受（SSL/TLS）加密保护的信息。

尽管漏洞很严重，但Heartbleed却是由一个常见的编程错误和明显缺乏安全编码意识而导致的。以下是有漏洞的代码：
```cpp
int dtls1_process_heartbeat(SSL *s) {         
  unsigned char *p = &s->s3->rrec.data[0], *pl;
  unsigned short hbtype;
  unsigned int payload;
  unsigned int padding = 16; /* Use minimum padding */

  /* Read type and payload length first */
  hbtype = *p++;
  n2s(p, payload);
  pl = p;

  /* ... More code ... */

  if (hbtype == TLS1_HB_REQUEST) {
    unsigned char *buffer, *bp;
    int r;

    /*
     * Allocate memory for the response; size is 1 byte
     * message type, plus 2 bytes payload length, plus
     * payload, plus padding.
     */
    buffer = OPENSSL_malloc(1 + 2 + payload + padding);
    bp = buffer;

    /* Enter response type, length, and copy payload */
    *bp++ = TLS1_HB_RESPONSE;
    s2n(payload, bp);
    memcpy(bp, pl, payload);

    /* ... More code ... */
  }
  /* ... More code ... */
}
```


此代码处理来自客户端的“心跳”包。正如RFC 6520规定，当程序接收到一个心跳包时，它必须回应数据包给客户端。除了包含数据以外，报文还包含一个长度域以方便指示数据包的长度，但是没有措施可以防止一个恶意报文来谎报其数据长度。

从payload和p1相关的p指针指向从报文中获取的数据。代码分配一个足够长度的buffer以容纳payload字节以及一些额外开销，然后从p1处复制payload到该缓冲区并将其发送到客户端。该代码最明显的错误就是缺少对从报文中获取的长度和报文实际数据是否一致进行检查。由于客户端可以任意构造payload,这样一个攻击者就可以让服务器返回超过报文长度以外的内容，这与规则“INT04-C,对来自不信任来源的整数值进行限制”相违背。导致的后果就是若调用memcpy()函数除了报文本身被复制外，报文尾部其他的内容也被复制了，从而导致敏感数据暴露给了攻击者。

##### 7.5.3.6 合规解决方案（Heartbleed）
OpenSSL的1.0.1g版本包含以下补丁，这保证了payload是在一个有效的范围内。而这个范围受输入记录的大小限制。
```cpp
int dtls1_process_heartbeat(SSL *s) {
  unsigned char *p = &s->s3->rrec.data[0], *pl;
  unsigned short hbtype;
  unsigned int payload;
  unsigned int padding = 16; /* Use minimum padding */

  /* ... More code ... */

  /* Read type and payload length first */
  if (1 + 2 + 16 > s->s3->rrec.length)
    return 0; /* Silently discard */
  hbtype = *p++;
  n2s(p, payload);
  if (1 + 2 + payload + 16 > s->s3->rrec.length)
    return 0; /* Silently discard per RFC 6520 */
  pl = p;

  /* ... More code ... */

  if (hbtype == TLS1_HB_REQUEST) {
    unsigned char *buffer, *bp;
    int r;

    /*
     * Allocate memory for the response; size is 1 byte
     * message type, plus 2 bytes payload length, plus
     * payload, plus padding.
     */
    buffer = OPENSSL_malloc(1 + 2 + payload + padding);
    bp = buffer;
    /* Enter response type, length, and copy payload */
    *bp++ = TLS1_HB_RESPONSE;
    s2n(payload, bp);
    memcpy(bp, pl, payload);
    /* ... More code ... */
  }
  /* ... More code ... */
}
```

#### 7.5.4 风险评估
通过调用库函数，攻击者可以通过堆或栈溢出漏洞运行任意代码。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 级别   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| ARR38-C | 高    | 很可能  | 中    | P18  | L1   |

### 7.6 ARR39-C 不要向指针中添加或减去缩放的整数
指针运算只有当指针指向一个数组的时候才是合理的（参见“ARR37-C，不要给一个非数组对象指针加上或减去一个整数”）。当执行指针运算时，对指针进行加减操作时，其大小将自动缩放为该数组对象类型的大小。
向指针中添加或减去缩放的整数值是无效的，因为它可能产生不指向数组或者超过数组末尾的指针（参见“不要使用超出边界的指针或超出边界的数组下标”）。

同时，向指针增加一个非相同成员类型的大小时也是违反规则的，然而，假如arr是一个数组名，但不是一个指针的话，arr[sizeof(arr)/sizeof(arr[0])])这样的语句是允许的。

#### 7.6.1 不合规代码示例
在这个不合规的代码示例中，sizeof(buf)的结果和地址buf相加。这个例子之所以是不合规的，sizeof(buf)的实际大小将由由int的大小进行伸缩（有的系统int是4字节，有的系统是8字节），这个结果会导致然buf被伸缩。
```cpp
enum { INTBUFSIZE = 80 };

extern int getdata(void);
int buf[INTBUFSIZE];

void func(void) {
  int *buf_ptr = buf;

  while (buf_ptr < (buf + sizeof(buf))) {
    *buf_ptr++ = getdata();
  }
}
```

#### 7.6.2 合规解决方案
此合规解决方案使用非伸缩整数来获取指向数组末尾的指针：
```cpp
enum { INTBUFSIZE = 80 };

extern int getdata(void);
int buf[INTBUFSIZE];

void func(void) {
  int *buf_ptr = buf;

  while (buf_ptr < (buf + INTBUFSIZE)) {
    *buf_ptr++ = getdata();
  }
}
```

#### 7.6.3 不合规代码示例
在这个不符合要求的代码示例中，指针s加上了skip变量的值。然而，skip表示ull\_b成员在struct
big中的字节偏移量，当和指针s相加后，skip被加上了skip个struct big这样的大小。
```cpp
#include <string.h>
#include <stdlib.h>
#include <stddef.h>

struct big {
  unsigned long long ull_a;
  unsigned long long ull_b;
  unsigned long long ull_c;
  int si_e;
  int si_f;
};

void func(void) {
  size_t skip = offsetof(struct big, ull_b);
  struct big *s = (struct big *)malloc(sizeof(struct big));
  if (s == NULL) {
    /* Handle malloc() error */
  }

  memset(s + skip, 0, sizeof(struct big) - skip);
  /* ... */
  free(s);
  s = NULL;
}
```

#### 7.6.4 合规解决方案
这个合规的解决方案使用unsigned char*来计算偏移而不使用struct big*，后者会导致所加的大小被伸缩放大：
```cpp
#include <string.h>
#include <stdlib.h>
#include <stddef.h>

struct big {
  unsigned long long ull_a;
  unsigned long long ull_b;
  unsigned long long ull_c;
  int si_d;
  int si_e;
};

void func(void) {
  size_t skip = offsetof(struct big, ull_b);
  unsigned char *ptr = (unsigned char *)malloc(
    sizeof(struct big)
  );
  if (ptr == NULL) {
     /* Handle malloc() error */
  }

  memset(ptr + skip, 0, sizeof(struct big) - skip);
  /* ... */
  free(ptr);
  ptr = NULL;
}
```

#### 7.6.5 不合规代码示例
在这个不合规的代码示例中，当给指针变量error_msg加上wcslen(error_msg)*sizeof(wchar_t)的时候，实际字节大小将被wchar_t类型的大小进行伸缩：
```cpp
#include <wchar.h>
#include <stdio.h>

enum { WCHAR_BUF = 128 };

void func(void) {
  wchar_t error_msg[WCHAR_BUF];

  wcscpy(error_msg, L"Error: ");
  fgetws(error_msg + wcslen(error_msg) * sizeof(wchar_t), WCHAR_BUF - 7, stdin);
  /* ... */
}
```

#### 7.6.6 合规解决方案
这个合规解决方案不会导致字符串长度被伸缩，
wcslen()返回的字符串的实际字符数而不是字节数。
```cpp
#include <wchar.h>
#include <stdio.h>

enum { WCHAR_BUF = 128 };
const wchar_t ERROR_PREFIX[7] = L"Error: ";

void func(void) {
  const size_t prefix_len = wcslen(ERROR_PREFIX);
  wchar_t error_msg[WCHAR_BUF];

  wcscpy(error_msg, ERROR_PREFIX);
  fgetws(error_msg + prefix_len,
        WCHAR_BUF - prefix_len, stdin);
  /* ... */
}
```

#### 7.6.7 风险评估
错误的理解和不恰当的使用指针运算可能会导致攻击者执行任意代码。

| 规则      | 严重性  | 可能性  | 修补成本 | 优先级  | 级别   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| ARR39-C | 高    | 有可能  | 高    | P6   | L2   |

#### 7.6.8 相关指南
ISO/IEC TR 24772:2013 Pointer Casting and Pointer Type Changes(指针类型转换与指针类型变化)[HFC]

## 8 字符和字符串（STR）

### 8.1 STR30-C 不要试图修改字符串常量

字符串常量是双引号内的0个或多个字节字符的序列（如`”xyz”`），宽字符串常量基本相同，区别在于它有字母前缀`‘L’`（例如`L”xyz”`）。

在编译时，字符串常量用于创建一个长度足以容纳字符序列和``null``终止符的具有静态持久期的数组。标准并没有指定这些数组是否不同。如果一个程序试图修改字符串常量，其行为是未定义的，但是常常会导致访问违规，因为字符串常量一般存储在只读内存中。

不要试图修改字符串常量，可以使用命名的字符数组实现可修改的字符串。不要将字符串常量（强制转换）赋值给`non-const`指针。



#### 8.1.1 不合规代码示例

在这个不合规代码示例中，`char`指针`p`初始化为指向一个字符串常量的地址。试图修改这个字符串常量会导致未定义的行为。

```cpp
char *p = “string literals”;
p[0] = ‘S’;
```



#### 8.1.2 合规解决方案

当字符串常量做为数组初始化值时，它指定了数组中字符的初始值以及数组的长度。这段代码在字符数组`a`分配的空间中创建了这个字符串常量的一份拷贝。存储在`a`中的字符串可以安全地修改。

```cpp
char a[] = “string literals”;
a[0] = ‘S’;
```



#### 8.1.3 不合规代码示例

在这个不合规代码示例中，`mktemp`函数入参是`non-const`指针，`mktemp`函数修改了它的字符串参数。 

```cpp
mktemp(“/temp/edxxxxxxxx”);
```



#### 8.1.4 合规解决方案

不传递字符串常量，而是使用一个命名数组：

```cpp
static char fname[] = “/temp/edxxxxxxxx”;
mktemp(fname);
```



#### 8.1.5 不合规代码示例

在这个不合规代码示例中，使用`strrchr`函数的`char *`类型返回结果，修改`pathname`。因为`strrchr`的入参是一个字符串常量，因此这种修改行为是未定义的。

```cpp
#include <stdio.h>
#include <string.h>
const char *get_dirname(const char *pathname) {
    char *slash;
    slash = strrchr(pathname, ‘/’);
    if (slash) {
        *slash = ‘\0’; /* Undefined behavior */
    }
    return pathname;
}

int main(void) {
    puts(get_dirname(__FILE__));
    return 0;
}
```



#### 8.1.6 合规解决方案

避免修改`const`对象，即使`strrchr`函数返回的是`non-const char *`指针。仅仅将`pathname`入参的类型修改为`char *`是不够的，因为并没有强制要求编译器对将字符串常量赋值给`char *`进行检查。

```cpp
#include <stdio.h>
#include <string.h>
const char *get_dirname(const char *pathname, char *dirname, size_t size) {
    const char *slash;
    slash = strrchr(pathname, ‘/’);
    if (slash) {
        ptrdiff_t slash_idx = slash – pathname;
        if ((size_t)slash_idx < size) {
            memcpy(dirname, pathname, slash_idx);
            dirname[slash_idx] = ‘\0’;
            return dirname;
        }
    }
    return 0;
}

int main(void) {
    char dirname[260];
    if (get_dirname(__FILE__, dirname, sizeof(dirname))) {
        puts(dirname);
    }
    return 0;
}
```



#### 8.1.7 风险评估

修改字符串常量可能导致程序异常终止，可能导致拒绝服务攻击。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| STR30-C | 低       | 很可能     | 低        | P9      | L2     |



#### 8.1.8 相关指南

| **标准**                        | **条目**                                   |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | EXP05-C. Do not cast away a const qualification <br>STR11-C. Do not specify the bound of a char-acter array initialized with a string literal |
| ISO/IEC TS 17961:2013         | Modifying string literals [strmod]       |



#### 8.1.9 参考文献
| **文献**              | **条目**                                |
| ------------------- | ------------------------------------- |
| [ISO/IEC 9899:2011] | 6.4.5, “String Literals”              |
| [Plum 1991]         | Topic 1.26, “Strings—String Literals” |
| [Summit 1995]       | comp.lang.c FAQ List, Question 1.32   |




### 8.2 STR31-C 保证字符串的存储具有足够的空间容纳字符数据和null结尾符

把数据复制到一个不足以容纳这些数据的缓冲区会导致缓冲区溢出。缓冲区溢出并不限于`null`结尾的字节字符串（NTBS），但是它常常是在操纵NTBS数据时发生。为了防止这类错误，需要对复制进行限制，可以通过截断或者保证目标缓冲区具有足够的空间容纳需要复制的字符数据和`null`结尾符。后者是更好的方法。



#### 8.2.1 不合规代码示例（误差为1的错误）

这个不合规代码示例演示了常见的误差为`1`的错误。这个循环把数据从`src`复制到`dest`。但是`null`终止符可能不正确地写到`dest`尾部之后的一个字节中，这是因为这个循环并没有考虑到必须在`dest`后面添加一个`null`终止符。

```cpp
void copy(size_t n, char src[n], char dest[n]) {
    size_t i;
    for (i = 0; src[i] && (i < n); ++i) {
        dest[i] = src[i];
    }
    dest[i] = ‘\0’;
}
```



#### 8.2.2 合规解决方案（误差为1的错误）

为了修正这个例子，必须对循环终止条件进行修改，在`dest`的尾部添加`null`终止符。

```cpp
void copy(size_t n, char src[n], char dest[n]) {
    size_t i;
    for (i = 0; src[i] && (i < n - 1); ++i) {
        dest[i] = src[i];
    }
    dest[i] = ‘\0’;
}
```



#### 8.2.3 不合规代码示例（gets()）

`gets()`函数在C99技术勘误中被标注为弃用（deprecated），且在c11中被移除。因为该函数有很大的安全隐患，它不能指定一次从`stdin`中读取多少数据到缓冲区。如下的代码假设`gets()`不会读取超过`BUFFER_SIZE – 1`的字符，而这是一种不合法的假设，结果就会导致缓冲区溢出。

```cpp
#include <stdio.h>

#define BUFFER_SIZE 1024

void func(void) {
    char buf[BUFFER_SIZE];
    if (gets(buf) == NULL) {
        /* Handle error */
    }
}
```



#### 8.2.4 合规解决方案（fgets()）

`fgets()`函数每次最多读取`bufsize-1`个字符（第`bufsize`个字符赋`'\0'`）。

`fgets()`函数并非严格定义用来代替`gets()`函数，因为`fgets()`会返回换行符，也有可能读取一行的一部分。可以考虑使用下面的顺从解决方案。

```cpp
#include <stdio.h>
#include <string.h>
enum {BUFFERSIZE = 32};
void func() {
    char buf[BUFFERSIZE];
    int ch;
    if (fgets(buf, sizeof(buf), stdin)) {
        char *p = strchr(buf, ‘\n’);
        if (p) {
            *p = ‘\0’;
        } else {
            while ((ch = getchar()) != ‘\n’ && ch != EOF)
                ;
            if (ch == EOF && !feof(stdin) && !ferror(stdin)) {
                /* Character resembles EOF; handle error */
            }
        } 
    } else {
    /* fgets() failed; handle error */
    }
}
```



#### 8.2.5 合规解决方案（gets_s()）

`gets_s()`函数每次最多从`stdin`读取`bufsize-1`个字符，另外，`gets_s()`函数不会读入换行符，在最后一个字符后会自动补`null`字符。如果没有读到任何字符，则`buffer`的第一个字符会被置为`null`字符，其它部分保持不变。

```cpp
#define __STDC_WANT_LIB_EXT1__ 1
enum { BUFFERSIZE = 32 };
void func() {
    char buf[BUFFERSIZE];
    if (gets_s(buf, sizeof(buf)) == NULL) {
        /* Handle error */
    }
}
```



#### 8.2.6 合规解决方案（getline()）

`getline()`函数和`fgets()`函数类似，不同之处在于`getline()`函数会自动进行动态内存的分配，所以使用这个函数非常注意的就使用要注意自己进行内存的释放。

如果分配了内存，但在使用过程中发现所分配的内存不足的话，`getline()`函数会调用`realloc()`函数来重新进行内存的分配，同时更新`buffer`和`size`。

注意`buffer`指向的是一个动态分配的内存，由`malloc`，`calloc`或`realloc`分配的，不能是静态分配的数组。

```cpp
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
void func(void) { 
    int ch; 
    size_t buffer_size = 32; 
    char *buffer = malloc(buffer_size); 
    if (!buffer) { 
        /* Handle error */ 
        return; 
    }
    
    if ((ssize_t size = getline(&buffer, &buffer_size, stdin)) == -1) { 
        /* Handle error */ 
    } else { 
        char *p = strchr(buffer, '\n'); 
        if (p) { 
            *p = '\0'; 
        } else { 
            /* Newline not found; flush stdin to end of line */ 
            while ((ch = getchar()) != '\n' && ch != EOF) ;
            if (ch == EOF && !feof(stdin) && !ferror(stdin)) { 
                /* Character resembles EOF; handle error */ 
            }
        } 
    }
    free (buffer); 
}
```



#### 8.2.7 不合规代码示例（getchar()）

如下的代码忽略了目标缓冲区大小的判断，从而引入缓冲区溢出的风险。

```cpp
#include <stdio.h> 
enum { BUFFERSIZE = 32 }; 
void func(void) { 
    char buf[BUFFERSIZE]; 
    char *p; 
    int ch; 
    p = buf; 
    while ((ch = getchar()) != '\n' && ch != EOF) { 
        *p++ = (char)ch; 
    }
    *p++ = 0; 
    if (ch == EOF) { 
        /* Handle EOF or error */
    }
}
```



#### 8.2.8 合规解决方案（getchar()）

循环读取`stdin`，直到行尾或文件尾，或发生错误。但最多只拷贝`BUFFERSIZE – 1`个字符，留出最后一个空间用于写入`null`字符。

```cpp
#include <stdio.h> 
enum { BUFFERSIZE = 32 }; 
void func(void) { 
    char buf[BUFFERSIZE]; 
    int ch;
    size_t index = 0; 
    size_t chars_read = 0; 
    while ((ch = getchar()) != '\n' && ch != EOF) { 
        if (index < sizeof(buf) - 1) { 
            buf[index++] = (char)ch; 
        }
        chars_read++; 
    }
    buf[index] = '\0'; /* Terminate string */ 
    if (ch == EOF) { 
        /* Handle EOF or error */ 
    }
    if (chars_read > index) { 
        /* Handle truncation */ 
    }
}
```



#### 8.2.9 不合规代码示例（fscanf()）

如下的不合规代码示例，调用`fscanf()`函数可能会导致缓冲区写溢出。

```cpp
#include <stdio.h> 
enum { BUF_LENGTH = 1024 }; 
void get_data(void) { 
    char buf[BUF_LENGTH]; 
    if (1 != fscanf(stdin, "%s", buf)) { 
        /* Handle error */ 
    }
    /* Rest of function */
}
```



#### 8.2.10 合规解决方案（fscanf()）

```cpp
#include <stdio.h> 
enum { BUF_LENGTH = 1024 }; 
void get_data(void) { 
    char buf[BUF_LENGTH]; 
    if (1 != fscanf(stdin, "%1023s", buf)) {
        /* Handle error */ 
    }
    /* Rest of function */
}
```



#### 8.2.11 不合规代码示例（argv）

命令行参数会以字符串指针数组的形式传递给`main()`函数，从`argv[0]`到`argv[argc–1]`。如果`argc`大于0，则`argv[0]`按惯例为程序的名字。如果`argc`大于1，则`argv[1]`到`argv[argc-1]`为程序的其他参数。

因此，如果不适当的拷贝命令行参数，可能会导致安全隐患。正如下面的这段代码，攻击者可以通过操纵`argv[0]`的内容制造缓冲区溢出。

```cpp
#include <string.h> 
int main(int argc, char *argv[]) { 
    /* Ensure argv[0] is not null */ 
    const char *const name = (argc && argv[0]) ? argv[0] : ""; 
    char prog_name[128]; 
    strcpy(prog_name, name); 
    return 0;
}
```



#### 8.2.12 合规解决方案（argv）

使用`strlen()`函数来确定`argv[0]`字符串的长度，从而可以动态分配足够的内存。

```cpp
#include <stdlib.h> 
#include <string.h> 
int main(int argc, char *argv[]) { 
    /* Ensure argv[0] is not null */ 
    const char *const name = (argc && argv[0]) ? argv[0] : ""; 
    char *prog_name = (char *)malloc(strlen(name) + 1); 
    if (prog_name != NULL) { 
        strcpy(prog_name, name); 
    } else {
        /* Handle error */
    }
    free(prog_name); 
    return 0;
}
```



#### 8.2.13 合规解决方案（argv）

`strcpy_s()`函数能提供额外的安全保障，它可以接受目标缓冲区长度做为入参。如果没有足够的空间，`strcpy_s()`函数返回错误。

```cpp
#define __STDC_WANT_LIB_EXT1__ 1 
#include <stdlib.h> 
#include <string.h> 
int main(int argc, char *argv[]) { 
    /* Ensure argv[0] is not null */ 
    const char *const name = (argc && argv[0]) ? argv[0] : ""; 
    char *prog_name; 
    size_t prog_size; 
    prog_size = strlen(name) + 1; 
    prog_name = (char *)malloc(prog_size); 
    if (prog_name != NULL) { 
        if (strcpy_s(prog_name, prog_size, name)) { 
            /* Handle error */ 
        } 
    } else { 
        /* Handle error */ 
    }/* ... */ 
    free(prog_name);
    return 0;
}
```



#### 8.2.14 合规解决方案（argv）

如果参数不需要被修改或被连接，则没有理由拷贝一份。不拷贝字符串是防止缓冲区写溢出的最好的手段，而且往往也最高效。不过不要做出`argv[0]`一定非空的错误假设。

```cpp
int main(int argc, char *argv[]) { 
    /* Ensure argv[0] is not null */ 
    const char * const prog_name = (argc && argv[0]) ? argv[0] : ""; 
    /* ... */ 
    return 0;
}
```



#### 8.2.15 不合规代码示例（getenv()）

环境变量的值可以任意大，如果不比较长度就将它们拷贝到目标缓冲区，可能会引发缓冲区写溢出。

```cpp
#include <stdlib.h> 
#include <string.h> 
void func(void) { 
    char buff[256]; 
    char *editor = getenv("EDITOR"); 
    if (editor == NULL) { 
        /* EDITOR environment variable not set */
    } else { 
        strcpy(buff, editor);
    }
}
```



#### 8.2.16 合规解决方案（getenv()）

使用`strlen()`函数获取环境变量值的长度，再使用这个长度动态分配内存：

```cpp
#include <stdlib.h> 
#include <string.h> 
void func(void) {
    char *buff;
    char *editor = getenv("EDITOR"); 
    if (editor == NULL) { 
        /* EDITOR environment variable not set */ 
    } else { 
        size_t len = strlen(editor) + 1; 
        buff = (char *)malloc(len); 
        if (buff == NULL) { 
            /* Handle error */
        } 
        memcpy(buff, editor, len); 
        free(buff); 
    }
}
```



#### 8.2.17 不合规代码示例（sprintf()）

下面的这段示例代码，使用了一个外部的字符串`name`，它可能来自于用户输入，文件，或网络。程序根据`name`构建一个文件名。因为`sprintf()`函数并不保证产生的字符串的长度，因此如果`name`足够长，将会产生缓冲区写溢出。

```cpp
#include <stdio.h> 
void func(const char *name) { 
    char filename[128]; 
    sprintf(filename, "%s.txt", name);
}
```



#### 8.2.18 合规解决方案（sprintf()）

通过给`sprintf`使用的格式化字符串`”%s”`增加精度，可以阻止上述的缓冲溢出。当指定精度后，可以防止输出多余该数量的字符。精度`123`保证只输出`name`的头`123`个字符，再加上`.txt`和`null`字符，不会超过缓冲区长度`128`。

```cpp
#include <stdio.h> 
void func(const char *name) { 
    char filename[128]; 
    sprintf(filename, "%.123s.txt", name);
}
```



#### 8.2.19 合规解决方案（snprintf()）

一个更加通用的解决方案是使用`snprintf()`函数：

```cpp
#include <stdio.h> 
void func(const char *name) { 
    char filename[128]; 
    snprintf(filename, sizeof(filename), "%s.txt", name);
}
```



#### 8.2.20 风险评估

把`null`结尾的字节字符串（NTBS）数据复制到无法容纳这些数据的缓冲区会导致缓冲区溢出。攻击者可以利用这种情况在具有潜在风险进程的权限下执行任意代码。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| STR31-C | 高       | 很可能     | 中        | P18     | L1     |



#### 8.2.21 相关指南

| **标准**                        | **条目**                                   |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | STR03-C. Do not inadvertently truncate a string <br>STR07-C. Use the bounds-checking interfaces for remediation of existing string manipulation code <br>MSC24-C. Do not use deprecated or obsoles-cent functions <br>MEM00-C. Allocate and free memory in the same module, at the same level of abstraction <br>FIO34-C. Distinguish between characters read from a file and EOF or WEOF |
| ISO/IEC TR 24772:2013         | String Termination [CJM] <br>Buffer Boundary Violation (Buffer Overflow) [HCB] <br>Unchecked Array Copying [XYW] |
| ISO/IEC TS 17961:2013         | Using a tainted value to write to an object using a formatted input or output function [taintfor-matio] <br>Tainted strings are passed to a string copying function [taintstrcpy] |
| MITRE CWE                     | CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer <br>CWE-120, Buffer Copy without Checking Size of Input (“Classic Buffer Overflow”) <br>CWE-123, Write-what-where Condition <br>CWE-125, Out-of-bounds Read <br>CWE-193, Off-by-one Error |



#### 8.2.22 参考文献
| **文献**              | **条目**                                   |
| ------------------- | ---------------------------------------- |
| [Dowd 2006]         | Chapter 7, “Program Building Blocks” (“Loop Constructs,” pp. 327–336) |
| [Drepper 2006]      | Section 2.1.1, “Respecting Memory Bounds” |
| [ISO/IEC 9899:2011] | K.3.5.4.1, “The gets_s Function”         |
| [Lai 2006]          |                                          |
| [NIST 2006]         | SAMATE Reference Dataset Test Case ID 000-000-088 |
| [Seacord 2013b]     | Chapter 2, “Strings”                     |
| [xorl 2009]         | FreeBSD-SA-09:11: NTPd Remote Stack Based Buffer Overflows |



### 8.3 STR32-C 不要将非null结尾的字符序列当做字符串传递给库函数

很多库函数接受一个字符串参数，且要求该字符串是以`null`字符结尾的。如果传递一个非`null`结尾的字符序列，则可能导致库函数访问边界外的非法内存。因此，不要传递一个非`null`结尾的字符序列给库函数。



#### 8.3.1 不合规代码示例

下面的代码示例中，字符序列`c_str`没有以`null`字符结尾，且当做入参传递给了`printf()`函数。

```cpp
#include <stdio.h> 
void func(void) { 
    char c_str[3] = "abc"; 
    printf("%s\n", c_str);
}
```



#### 8.3.2 合规解决方案

该解决方案在声明字符数组时未指定范围，此时，编译器会根据字符字面值的长度分配合适的存储空间，用于容纳该字符字面值以及`null`字符。

```cpp
#include <stdio.h> 
void func(void) { 
    char c_str[] = "abc"; 
    printf("%s\n", c_str);
}
```



#### 8.3.3 不合规代码示例

在所有可用的内存都被耗尽的紧急情况下，减少内存使用率的一种方法是使用`realloc()`函数把消息字符串的长度减半。标准函数`realloc()`不存在`null`结尾的字节字符串的概念。因此，如果调用`realloc()`减少一个`null`结尾的字节字符串所占用的内存，这个`null`字符坑你会截断。

下面的这个不合规代码示例无法保证`cur_msg`是否正确地以`null`结尾。

```cpp
#include <stdlib.h> 
#include <wchar.h> 
wchar_t *cur_msg = NULL; 
size_t cur_msg_size = 1024; 
size_t cur_msg_len = 0; 
void lessen_memory_usage(void) { 
    wchar_t *temp; 
    size_t temp_size; 
    /* ... */ 
    if (cur_msg != NULL) { 
        temp_size = cur_msg_size / 2 + 1; 
        temp = realloc(cur_msg, temp_size * sizeof(wchar_t)); 
        /* temp &and cur_msg may no longer be null-terminated */ 
        if (temp == NULL) { 
        /* Handle error */ 
        }
        cur_msg = temp; 
        cur_msg_size = temp_size; 
        cur_msg_len = wcslen(cur_msg);
    }
}
```



#### 8.3.4 合规解决方案

在这个合规解决方案中，`lessen_memory_usage()`函数保证结果字符串总是正确地以`null`结尾。

```cpp
#include <stdlib.h> 
#include <wchar.h> 
wchar_t *cur_msg = NULL; 
size_t cur_msg_size = 1024; 
size_t cur_msg_len = 0; 
void lessen_memory_usage(void) { 
    wchar_t *temp; 
    size_t temp_size; 
    /* ... */ 
    if (cur_msg != NULL) { 
        temp_size = cur_msg_size / 2 + 1; 
        temp = realloc(cur_msg, temp_size * sizeof(wchar_t)); 
        /* temp and cur_msg may no longer be null-terminated */ 
        if (temp == NULL) { 
            /* Handle error */
         }
        cur_msg = temp; /* Properly null-terminate cur_msg */ 
        cur_msg[temp_size - 1] = L'\0'; 
        cur_msg_size = temp_size; 
        cur_msg_len = wcslen(cur_msg); 
    }
}
```



#### 8.3.5 不合规代码示例（strncpy()）

`strncpy()`函数并不保证结果字符串是以`null`结尾的。如果源数组的前`n`个字符中不存在`null`字符，其结果就不是以`null`结尾的。

将一个非null结尾的字符串传递给`strlen()`的行为是未定义的。

```cpp
#include <string.h> 
enum { STR_SIZE = 32 }; 
size_t func(const char *source) { 
    char c_str[STR_SIZE]; 
    size_t ret = 0; 
    if (source) { 
        c_str[sizeof(c_str) - 1] = '\0'; 
        strncpy(c_str, source, sizeof(c_str)); 
        ret = strlen(c_str); 
    } else { 
        /* Handle null pointer */ 
    }
    return ret;
}
```



#### 8.3.6 合规解决方案（截断）

正确的解决方案取决于程序员的意图。如果程序员的意图是截断字符串但仍然保证它是`null`结尾的字符串，可以使用这个解决方案。

```cpp
#include <string.h> 
enum { STR_SIZE = 32 }; 
size_t func(const char *source) { 
    char c_str[STR_SIZE]; 
    size_t ret = 0; 
    if (source) { 
        strncpy(c_str, source, sizeof(c_str) - 1); 
        c_str[sizeof(c_str) - 1] = '\0'; 
        ret = strlen(c_str); 
    } else { 
        /* Handle null pointer */ 
    }
    return ret;
}
```



#### 8.3.7 合规解决方案（截断,strncpy_s()）

`strncpy_s()`函数也可以用于截断拷贝。`strncpy_s()`函数最多拷贝n个字符，如果没有`null`字符，则目标缓冲区的第`n`个字符被置为`null`字符，以保证目标字符串总是以`null`结尾的。

```cpp
#define __STDC_WANT_LIB_EXT1__ 1 
#include <string.h> 
enum { STR_SIZE = 32 }; 
size_t func(const char *source) { 
    char a[STR_SIZE]; 
    size_t ret = 0; 
    if (source) { 
        errno_t err = strncpy_s( a, sizeof(a), source, strlen(source) ); 
        if (err != 0) { 
            /* Handle error */ 
        } else { 
        ret = strnlen_s(a, sizeof(a)); 
        }
    } else { 
        /* Handle null pointer */ 
    }
    return ret;
}
```



#### 8.3.8 合规解决方案（不截断的复制）

如果程序员的意图是在复制时不进行截断，这个例子就复制数据并保证结果的`null`结尾的字节字符串是以`null`结尾的。如果这个字符串无法复制，就按照错误条件对它进行处理。

```cpp
#include <string.h> 
enum { STR_SIZE = 32 }; 
size_t func(const char *source) { 
    char c_str[STR_SIZE]; 
    size_t ret = 0; 
    if (source) {
        if (strlen(source) < sizeof(c_str)) { 
            strcpy(c_str, source); 
            ret = strlen(c_str); 
        } else { 
            /* Handle string-too-large */ 
        }
    } else { 
        /* Handle null pointer */ 
    }
    return ret;
}
```



#### 8.3.9 风险评估

没有正确地用`null`终止字符串可能会导致缓冲区溢出以及在具有潜在风险进程的权限下执行任意代码。`null`结尾错误还可能导致信息出乎意料地泄露。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| STR32-C | 高       | 很可能     | 中        | P12     | L1     |



#### 8.3.10 相关指南

| **标准**                | **条目**                                   |
| --------------------- | ---------------------------------------- |
| ISO/IEC TR 24772:2013 | String Termination [CMJ]                 |
| ISO/IEC TS 17961:2013 | Passing a non-null-terminated character se-quence to a library function that expects a string [strmod] |
| MITRE CWE             | CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer <br>CWE-123, Write-what-where Condition <br>CWE-125, Out-of-bounds Read <br>CWE-170, Improper Null Termination |



#### 8.3.11 参考文献
| **文献**         | **条目**                                   |
| -------------- | ---------------------------------------- |
| [Seacord 2013] | Chapter 2, “Strings”                     |
| [Viega 2005]   | Section 5.2.14, “Miscalculated NULL Termina-tion” |



### 8.4 STR34-C 在转换为更大的整数长度时把字符转换为无符号类型

有符号字符数据在赋值或转换为更大的有符号类型之前必须转换为无符号类型。由于编译器可以选择把`char`定义为与`signed char`相同的范围、表示形式和行为，因此这个规则应该同时适用于`signed char`和普通的`char`字符类型。

这个规则只适用于字符数据可能包含被解释为负值的字符的情况下。例如，如果`char`类型用8位补码表示，大于`+127`的所有字符都解释为负值。

 

#### 8.4.1 不合规代码示例

这个不合规代码示例取自bash 1.14.6及更早版本中的一个潜在风险，它导致了CERT AdvisoryCA-1996-22的发布。这个潜在风险来自bash源代码parse.y模块中的`yy_string_get()`函数中的string指针所引用的字符数据的符号扩展。

```cpp
static int yy_string_get(void) { 
    register char *c_str; 
    register int c; 
    c_str = bash_input.location.string; 
    c = EOF; 
    /* If the string doesn't exist or is empty, EOF found */ 
    if (c_str && *c_str) { 
        c = *c_str++; 
        bash_input.location.string = c_str; 
    }
    return (c);
}
```

`c_str`变量用于遍历包含了需要解析的命令行的字符串。从这个指针提取字符时，它们存储在一个`int`类型的变量中。对于`char`类型默认为`signed char`的编译器，这个值赋值给`int`变量时会进行符号扩展。以字符255（-1的补码形式）为例，有符号扩展导致把-1这个值赋值给了这个整数`c`，这样就无法与`EOF`区分。



#### 8.4.2 不合规代码示例

这个问题可以通过显式地把`c_str`变量声明为`unsigned char`类型来修正。
但是，这个解决方案违反了“使用普通`char`类型表示基本字符集中的字符”规范。

```cpp
static int yy_string_get(void) { 
    register unsigned char *c_str; 
    register int c; 
    c_str = bash_input.location.string; 
    c = EOF; 
    /* If the string doesn't exist or is empty, EOF found */ 
    if (c_str && *c_str) { 
        c = *c_str++; 
        bash_input.location.string = c_str; 
    }
    return (c);
}
```



#### 8.4.3 合规解决方案

在这个合规解决方案中，表达式`*c_str++`的结果在复制给`int`变量`c`之前转换为`unsigned char`类型。

```cpp
static int yy_string_get(void) { 
    register char *c_str; 
    register int c; 
    c_str = bash_input.location.string; 
    c = EOF; 
    /* If the string doesn't exist or is empty, EOF found */ 
    if (c_str && *c_str) { 
        c = (unsigned char)*c_str++; 
        bash_input.location.string = c_str; 
    }
    return (c);
}
```



#### 8.4.4 不合规代码示例

在这个不合规代码示例中，将`*s`转换为`unsigned int`类型可能会因为`int`类型提升产生一个超过`UCHAR_MAX`的数，从而导致非法内存访问。

```cpp
#include <limits.h> 
#include <stddef.h> 
static const char table[UCHAR_MAX] = { 'a' /* ... */ }; 
    ptrdiff_t first_not_in_table(const char *c_str) { 
      for (const char *s = c_str; *s; ++s) { 
        if (table[(unsigned int)*s] != *s) { 
            return s - c_str; 
        }
      }
      return -1;
}
```



#### 8.4.5 合规解决方案

在这个合规解决方案中，在隐式提升为更大类型前，将`char`转换为`unsigned char`类型。

```cpp
#include <limits.h> 
#include <stddef.h> 
static const char table[UCHAR_MAX] = { 'a' /* ... */ }; 
    ptrdiff_t first_not_in_table(const char *c_str) { 
    for (const char *s = c_str; *s; ++s) { 
        if (table[(unsigned char)*s] != *s) { 
            return s - c_str; 
        }
    }
    return -1; 
}
```



#### 8.4.6 风险评估

这个微妙的错误所涉及的范围极广，可能导致严重的潜在风险。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| STR34-C | 中       | 有可能     | 中        | P8      | L2     |



#### 8.4.7 相关指南

| **标准**                        | **条目**                                   |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | STR37-C. Arguments to character-handling functions must be representable as an unsigned char <br>STR04-C. Use plain char for characters in the basic character set <br>ARR30-C. Do not form or use out-of-bounds pointers or array subscripts |
| ISO/IEC TS 17961:2013         | Conversion of signed characters to wider inte-ger types before a check for EOF [signconv] |
| MISRA-C                       | Rule 10.1 through Rule 10.4 (required)   |
| MITRE CWE                     | CWE-704, Incorrect Type Conversion or Cast |



#### 8.4.8 参考文献
| **文献**      | **条目**                                   |
| ----------- | ---------------------------------------- |
| [xorl 2009] | CVE-2009-0887: Linux-PAM Signedness Issue |



### 8.5 STR37-C 字符处理函数的参数必须能够用unsigned char表示

根据C99第7.4节：

头文件`<ctype.h>`声明了几个函数，适用于对字符进行分类和映射。如果参数的类型是`int`，它的值应该可以用`unsigned char`表示或者等于`EOF`宏的值。如果参数为其他任何值，其行为是未定义的。

遵循这个规则的情况比较复杂，因为`char`数据类型在任何编译器中可能是有符号，也可能是无符号。

表8-1中的这些字符分类函数受这个规则影响。

表8-1 受规则影响的字符处理函数

| isalnum()  | isalpha() | isascii() | isblank() |
| ---------- | --------- | --------- | --------- |
| iscntrl()  | isdigit() | isgraph() | islower() |
| isprint()  | ispunct() | isspace() | isupper() |
| isxdigit() | toascii() | toupper() | tolower() |

 

#### 8.5.1 不合规代码示例

这个不合规代码示例可能向`isspace()`函数传递非法值。当编译器将`char`类型解释为`signed char`类型时，这段代码传递的值可能无法以`unsigned char`表示。

```cpp
#include <ctype.h> 
#include <string.h> 
size_t count_preceding_whitespace(const char *s) { 
    const char *t = s; 
    size_t length = strlen(s) + 1; 
    while (isspace(*t) && (t - s < length)) { 
        ++t; 
    }
    return t - s; 
}
```



#### 8.5.2 合规解决方案

```cpp
#include <ctype.h> 
#include <string.h> 
size_t count_preceding_whitespace(const char *s) { 
    const char *t = s; 
    size_t length = strlen(s) + 1; 
    while (isspace((unsigned char)*t) && (t - s < length)) { 
        ++t; 
    }
    return t - s;
}
```



#### 8.5.3 风险评估

把无法用`unsigned char`表示的值传递给字符处理函数会导致未定义的行为。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| STR37-C | 低       | 不太可能    | 低        | P3      | L3     |



#### 8.5.4 相关指南

| **标准**                        | **条目**                                   |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | STR34-C. Cast characters to unsigned char be-fore converting to larger integer sizes |
| ISO/IEC TS 17961              | Passing arguments to character-handling func-tions that are not representable as unsigned char [chrsgnext] |
| MITRE CWE                     | CWE-704, Incorrect Type Conversion or Cast <br>CWE-686, Function Call with Incorrect Argu-ment Type |



#### 8.5.5 参考文献
| **文献**              | **条目**                                   |
| ------------------- | ---------------------------------------- |
| [ISO/IEC 9899:2011] | 7.4, “Character Handling <ctype.h>”      |
| [Kettlewell 2002]   | Section 1.1, “<ctype.h> and Characters Types” |



### 8.6 STR38-C 正确地判断宽字符串的长度

当宽字符串被错误地表示为窄字符串或多字节字符串时，它们的长度可能会弄错。不正确的字符串长度在使用时会导致缓冲区溢出，例如分配了长度不够的缓冲区。



#### 8.6.1 不合规代码示例（宽字符串传递给窄字符串函数）

在这个不合规代码示例中，错误的使用`strncpy()`来拷贝10个宽字符。因为宽字符可能含有`null`字节，从而导致`strncpy()`出乎预期的提前结束拷贝。

```cpp
#include <stddef.h> 
#include <string.h> 
void func(void) { 
    wchar_t wide_str1[] = L"0123456789"; 
    wchar_t wide_str2[] = L"0000000000"; 
    strncpy(wide_str2, wide_str1, 10);
}
```



#### 8.6.2 不合规代码示例（窄字符串传递给宽字符串函数）

在这个不合规代码示例中，错误的使用宽字符串拷贝函数`wcsncpy()`从narrow_str1拷贝10个宽字符到narrow_str2。因为narrow_str2是窄字符串，它并没有足够的空间存放10个宽字符，因此copy会导致缓冲区溢出。

```cpp
#include <wchar.h> 
void func(void) { 
    char narrow_str1[] = "01234567890123456789"; 
    char narrow_str2[] = "0000000000"; 
    wcsncpy(narrow_str2, narrow_str1, 10);
}
```



#### 8.6.3 合规解决方案

在这个合规解决方案中，使用了合适宽度的函数。比如用`wcsncpy()`来处理宽字符串，使用`strncpy()`来处理窄字符串。

```cpp
#include <string.h> 
#include <wchar.h> 
void func(void) { 
    wchar_t wide_str1[] = L"0123456789"; 
    wchar_t wide_str2[] = L"0000000000";
    /* Use of proper-width function */ 
    wcsncpy(wide_str2, wide_str1, 10); 
    char narrow_str1[] = "0123456789"; 
    char narrow_str2[] = "0000000000"; 
    /* Use of proper-width function */ 
    strncpy(narrow_str2, narrow_str1, 10);
}
```



#### 8.6.4 不合规代码示例（strlen()）

在这个不合规代码示例中，`strlen()`函数用于确定一个宽字符串的长度。
`strlen()`函数计数一个以`null`结尾的字节字符串中结尾的`null`字节之前的字符数量。但是，宽字符可能包含`null`字符，尤其是它取自ASCII字符集时，如这个例子所示。因此，`strlen()`函数将返回字符串中第1个`null`字节之前的字节数量。

```cpp
#include <stdlib.h> 
#include <string.h> 
void func(void) { 
    wchar_t wide_str1[] = L"0123456789"; 
    wchar_t *wide_str2 = (wchar_t*)malloc(strlen(wide_str1) + 1); 
    if (wide_str2 == NULL) { 
        /* Handle error */ 
    }
    /* ... */ 
    free(wide_str2); 
    wide_str2 = NULL;
}
```



#### 8.6.5 不合规代码示例（大小缩放不正确）

在这个不合规代码示例中，`wcslen()`函数用于确定一个宽字符串长度，但长度并没有与`sizeof(wchar_t)`相乘。

```cpp
wchar_t wide_str1[] = L”0123456789”;
wchar_t *wide_str3 = (wchar_t*)malloc(wcslen(wide_str1) + 1);
if (wide_str3 == NULL) {
    /* Handle error */
}
/* …… */
free(wide_str3);
wide_str3 = NULL;
```



#### 8.6.6 合规解决方案

这个合规解决方案正确地计算包含这个宽字符串（包括结尾字符）的一份拷贝所需要的字节数量。

```cpp
wchar_t wide_str1[] = L”0123456789”;
wchar_t *wide_str2 = (wchar_t*)malloc(
(wcslen(wide_str1) + 1) * sizeof(wchar_t));
if (wide_str2 == NULL) {
    /* Handle error */
}
/* …… */
free(wide_str2);
wide_str2 = NULL;
```



#### 8.6.7 风险评估

未正确地确定宽字符串的长度可能会导致缓冲区溢出，导致攻击者执行任意代码。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| STR38-C | 高       | 很可能     | 中        | P27     | L1     |



#### 8.6.8 参考文献
| **文献**              | **条目**                                   |
| ------------------- | ---------------------------------------- |
| [ISO/IEC 9899:2011] | 7.24.2.4, “The strncpy Function” <br>7.29.4.2.2, “The wcsncpy Function” |

## 9 内存管理（MEM）

### 9.1 MEM30-C 不要访问已经释放的内存

访问已释放的内存可能会破坏用于管理堆的数据结构。指向已经销毁内存的指针称为野指针。访问野指针会导致可被利用的潜在风险。

当内存释放时，它的内容可能保存完整并可以被访问，因为什么时候重新分配或回收释放的内存块是内存管理程序决定的事情。释放的内存位置的数据可能是有效的。但是，它会意外地改变，导致意料不到的程序行为。因此，当内存释放后，有必要保证不再对它进行写入或读取。



#### 9.1.1 不合规代码示例

这个例子取自Kernighan和Ritchie，同时显示了从链表中删除元素的错误技巧和正确技巧。错误的解决方案无法完成任务，因为`p`在执行`p->next`之前已经释放，因此`p->next`读取的是已经释放的内存。

```cpp
#include <stdlib.h> 
struct node { 
    int value; 
    struct node *next; 
}; 
void free_list(struct node *head) { 
    for (struct node *p = head; p != NULL; p = p->next) { 
        free(p); 
    }
}
```



#### 9.1.2 合规解决方案

Kernighan和Ritchie还显示了正确的解决方案。为了修正这个错误，在释放`p`之前把`p->next`的引用存储在`q`中。

```cpp
#include <stdlib.h> 
struct node { 
  int value; 
  struct node *next; 
}; 
void free_list(struct node *head) { 
    struct node *q;
    for (struct node *p = head; p != NULL; p = q) { 
        q = p->next;
        free(p); 
    }
}
```



#### 9.1.3 不合规代码示例

在这个不合规代码示例中，对已经释放的buff进行了写入。这种潜在风险很容易被利用，在具有潜在风险的进程的权限下运行任意代码，并且很少被注意。一般情况下，内存的分配和释放的点相隔很远，因此难以识别和诊断这类问题。

```cpp
#include <stdlib.h> 
#include <string.h>
int main(int argc, char *argv[]) { 
    char *return_val = 0; 
    const size_t bufsize = strlen(argv[0]) + 1; 
    char *buf = (char *)malloc(bufsize); 
    if (!buf) { 
        return EXIT_FAILURE; 
    }
    /* ... */ 
    free(buf); 
    /* ... */ 
    strcpy(buf, argv[0]); 
    /* ... */ 
    return EXIT_SUCCESS;
}
```



#### 9.1.4 合规解决方案

不要释放内存，除非它不再需要。

```cpp
#include <stdlib.h> 
#include <string.h>
int main(int argc, char *argv[]) { 
    char *return_val = 0; 
    const size_t bufsize = strlen(argv[0]) + 1; 
    char *buf = (char *)malloc(bufsize); 
    if (!buf) { 
        return EXIT_FAILURE; 
    }
    /* ... */ 
    strcpy(buf, argv[0]); 
    /* ... */ 
    free(buf); 
    return EXIT_SUCCESS;
}
```



#### 9.1.5 不合规代码示例

在这个不合规代码示例中，`realloc()`在返回`null`指针时可能已经释放了`c_str1`，从而导致`c_str1`被释放两次。当前GNU C库和Microsoft Visual Studio’s Runtime库的实现，是当长度为0时，老的内存会被释放，同时返回`null`指针。

```cpp
#include <stdlib.h> 
void f(char *c_str1, size_t size) { 
    char *c_str2 = (char *)realloc(c_str1, size); 
    if (c_str2 == NULL) { 
        free(c_str1); 
    }
}
```



#### 9.1.6 合规解决方案

本解决方案不会传递长度为0给`realloc()`函数，从而消除了`c_str1`被释放两次的可能性。

```cpp
#include <stdlib.h>
void f(char *c_str1, size_t size) { 
    if (size != 0) { 
        char *c_str2 = (char *)realloc(c_str1, size); 
        if (c_str2 == NULL) { 
            free(c_str1); 
        } 
    }else { 
        free(c_str1); 
    } 
}
```

程序的行为取决于程序员的意图，当size为0时，本解决方案会释放内存，而不是什么也不做。



#### 9.1.7 不合规代码示例

这个不合规代码示例来自libwmf 0.2.8.4版本，`gdRealloc()`函数的返回值被赋予`more`，但是`im->clip->list`随后被直接使用。`realloc()`函数如果需要移动内存块，则原来的内存会被释放掉。攻击者可以通过指定足够大小的`im->clip->count`执行`realloc()`，从而释放原来的内存，并且可以访问这个已释放的内存。

```cpp
void gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) { 
    gdClipRectanglePtr more; 
    if (im->clip == 0) { 
        /* ... */ 
    }
    if (im->clip->count == im->clip->max) { 
        more = gdRealloc (im->clip->list,(im->clip->max + 8) * sizeof (gdClipRectangle)); 
        /** If the realloc fails, then we have not lost the * im->clip->list value. */ 
        if (more == 0) 
        return; 
        im->clip->max += 8; 
    }
    im->clip->list[im->clip->count] = *rect; 
    im->clip->count++;
}
```



#### 9.1.8 合规解决方案

在这个合规解决方案中，在调用`realloc()`函数后，通过简单的将`more`赋值给`im->clip->list`解决该隐患。

```cpp
void gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) { 
    gdClipRectanglePtr more; 
    if (im->clip == 0) { 
        /* ... */ 
    }
    if (im->clip->count == im->clip->max) { 
        more = gdRealloc (im->clip->list,(im->clip->max + 8) * sizeof (gdClipRectangle)); 
        if (more == 0) return; 
        im->clip->max += 8; 
        im->clip->list = more; 
    }
    im->clip->list[im->clip->count] = *rect; 
    im->clip->count++;
}
```



#### 9.1.9 风险评估

读取已经释放的内存可能导致程序异常终止和拒绝服务攻击。写入到已经释放的内存可能导致攻击者在具有潜在风险的进程的权限下执行任意代码。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| MEM30-C | 高       | 很可能     | 中        | P18     | L1     |




#### 9.1.10 相关指南

| **标准**                        | **条目**                                   |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | MEM01-C. Store a new value in pointers im-mediately after free() |
| SEI CERT C++ Coding Standard  | MEM50-CPP. Do not access freed memory    |
| ISO/IEC TR 24772:2013         | Dangling References to Stack Frames [DCM] <br>Dangling Reference to Heap [XYK] |
| ISO/IEC TS 17961              | Accessing freed memory [accfree] <br>Freeing memory multiple times [dblfree] |
| MISRA C:2012                  | Rule 18.6 (required)                     |
| MITRE CWE                     | CWE-415, Double Free <br>CWE-416, Use After Free |



#### 9.1.11 参考文献
| **文献**               | **条目**                                   |
| -------------------- | ---------------------------------------- |
| [ISO/IEC 9899:2011]  | 7.22.3, “Memory Management Functions”    |
| [Kernighan 1988]     | Section 7.8.5, “Storage Management”      |
| [OWASP Freed Memory] |                                          |
| [MIT 2005]           |                                          |
| [Seacord 2013b]      | Chapter 4, “Dynamic Memory Management”   |
| [Viega 2005]         | Section 5.2.19, “Using Freed Memory”     |
| [VU#623332]          |                                          |
| [xorl 2009]          | CVE-2009-1364: LibWMF Pointer Use after free() |



### 9.2 MEM31-C 释放不再需要的动态分配的内存

当通过调用标准内存分配函数分配的内存不再需要时，必须配对调用`free()`函数释放。



#### 9.2.1 不合规代码示例

在这个不合规代码示例中，通过`malloc()`分配的内存，在指向它的指针`text_buffer`生命周期结束前，没有释放该内存。

```cpp
#include <stdlib.h> 
enum { BUFFER_SIZE = 32 }; 
int f(void) { 
    char *text_buffer = (char *)malloc(BUFFER_SIZE); 
    if (text_buffer == NULL) { 
        return -1; 
    }
    free(text_buffer);
    return 0;
}
```



#### 9.2.2 合规解决方案

调用`free()`函数释放内存。

```cpp
#include <stdlib.h> 
enum { BUFFER_SIZE = 32 }; 
int f(void) { 
    char *text_buffer = (char *)malloc(BUFFER_SIZE); 
    if (text_buffer == NULL) { 
        return -1; 
    }
    free(text_buffer);
    return 0;
}
```



#### 9.2.3 例外

当使用具有全程序生命周期的静态指针指向分配的内存时，可以不需要有配对的释放操作。下面这个例子中，通过`malloc()`分配的内存地址被赋予了`static`变量。

```cpp
#include <stdlib.h> 
enum { BUFFER_SIZE = 32 }; 
int f(void) { 
    static char *text_buffer = NULL; 
    if (text_buffer == NULL) { 
        text_buffer = (char *)malloc(BUFFER_SIZE); 
        if (text_buffer == NULL) { 
            return -1; 
        } 
    }
    return 0;
}
```



#### 9.2.4 风险评估

未正确的释放内存可能会导致系统内存被耗尽，从而导致拒绝服务攻击。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| MEM31-C | 中       | 有可能     | 中        | P8      | L2     |




#### 9.2.5 相关指南

| **标准**                | **条目**                                   |
| --------------------- | ---------------------------------------- |
| ISO/IEC TR 24772:2013 | Memory Leak [XYL]                        |
| ISO/IEC TS 17961      | Failing to close files or free dynamic memory when they are no longer needed [fileclose] |
| MITRE CWE             | CWE-401, Improper Release of Memory Be-fore Removing Last Reference (“Memory Leak”) |




#### 9.2.6 参考文献
| **文献**              | **条目**                                   |
| ------------------- | ---------------------------------------- |
| [ISO/IEC 9899:2011] | Subclause 7.22.3, “Memory Management Functions” |




### 9.3 MEM33-C 动态分配和拷贝包含有灵活数据成员的结构

灵活数组成员是一种特殊类型的数组，一种包含多个命名成员结构的最后一个元素可能是一种不完整的数组类型。也就是说，这个数组的长度在这个结构内部并没有显式地指定。可以使用多种不同的语法声明灵活数组成员。

下面是一个例子：

```cpp
struct flex_array_struct {
    int num;
    int data[];
};
```

这样的定义意味着当计算结构体大小时，只有第一个成员`num`被考虑。在明确为这个结构体的灵活数组成员`data`考虑大小并分配内存前，对`data`的访问行为是未定义的。
为了避免这种潜在的未定义行为，包含灵活成员的结构的对象存储空间应该总是动态分配。包含灵活数组的结构必须：

- 动态分配内存
- 通过`memcpy()`或类似函数拷贝，而不是直接赋值
- 做为入参时，通过传址而非传值的方式





#### 9.3.1 不合规代码示例（存储周期）

在这个不合规代码示例中，使用了自动变量来定义包含灵活数组的结构变量。

```cpp
#include <stddef.h> 
struct flex_array_struct { 
    size_t num; 
    int data[]; 
}; 
void func(void) {
    struct flex_array_struct flex_struct; 
    size_t array_size = 4; 
    /* Initialize structure */ 
    flex_struct.num = array_size; 
    for (size_t i = 0; i < array_size; ++i) { 
        flex_struct.data[i] = 0; 
    }
}
```

因为`flext_struct`分配在栈上，并没有为`data`分配空间，因此，对`data`的访问行为是未定义的。



#### 9.3.2 合规解决方案（存储周期）

为`flex_array_struct`动态分配存储空间。

```cpp
#include <stdlib.h> 
struct flex_array_struct { 
    size_t num; 
    int data[]; 
}; 
void func(void) { 
    struct flex_array_struct *flex_struct; 
    size_t array_size = 4; 
    /* Dynamically allocate memory for the struct */ 
    flex_struct = (struct flex_array_struct *)malloc( sizeof(struct flex_array_struct) + sizeof(int) * array_size); 
    if (flex_sruct == NULL) { 
        /* Handle error */ 
    }
    /* Initialize structure */ 
    flex_struct->num = array_size; 
    for (size_t i = 0; i < array_size; ++i) { 
        flex_struct->data[i] = 0;
    }
}
```



#### 9.3.3 不合规代码示例（拷贝）

在这个不合规代码示例中，通过赋值的方式拷贝一个包含灵活数组的结构的对象。

```cpp
#include <stddef.h> 
struct flex_array_struct { 
    size_t num; 
    int data[]; 
}; 
void func(struct flex_array_struct *struct_a, struct flex_array_struct *struct_b) { 
    *struct_b = *struct_a;
}
```

当通过赋值方式拷贝结构体对象时，只有`num`被拷贝，灵活数组并不会被拷贝。

 

#### 9.3.4 合规解决方案（拷贝）

使用`memcpy()`函数将`struct_a`正确的拷贝到`struct_b`。

```cpp
#include <string.h> 
struct flex_array_struct { 
    size_t num; 
    int data[]; 
}; 
void func(struct flex_array_struct *struct_a, struct flex_array_struct *struct_b) { 
    if (struct_a->num > struct_b->num) { 
        /* Insufficient space; handle error */ 
        return; 
    }
    memcpy(struct_b, struct_a, sizeof(struct flex_array_struct) + (sizeof(int) * struct_a->num));
}
```



#### 9.3.5 不合规代码示例（函数入参）

在这个不合规代码示例中，通过传值的方式将一个包含灵活数组成员的结构实例传递给打印数组元素的函数。

```cpp
#include <stdio.h> 
#include <stdlib.h> 
struct flex_array_struct { 
    size_t num; 
    int data[]; 
}; 
void print_array(struct flex_array_struct struct_p) { 
    puts("Array is: "); 
    for (size_t i = 0; i < struct_p.num; ++i) { 
        printf("%d ", struct_p.data[i]); 
    }
    putchar('\n'); 
}
void func(void) { 
    struct flex_array_struct *struct_p; 
    size_t array_size = 4; 
    /* Space is allocated for the struct */ 
    struct_p = (struct flex_array_struct *)malloc( sizeof(struct flex_array_struct) + sizeof(int) * array_size); 
    if (struct_p == NULL) { 
        /* Handle error */ 
    }
    struct_p->num = array_size; 
    for (size_t i = 0; i < array_size; ++i) { 
        struct_p->data[i] = i; 
    }
    print_array(*struct_p);
}
```

当以传值方式传递入参时，灵活数组成员的大小不会被考虑，因此，只有`num`被拷贝。



#### 9.3.6 合规解决方案（函数入参）

以传址而非传值的方式传递参数。

```cpp
#include <stdio.h> 
#include <stdlib.h>
struct flex_array_struct { 
    size_t num; 
    int data[]; 
}; 
void print_array(struct flex_array_struct *struct_p) { 
    puts("Array is: "); 
    for (size_t i = 0; i < struct_p->num; ++i) { 
        printf("%d ", struct_p->data[i]); 
    }
    putchar('\n'); 
}
void func(void) { 
    struct flex_array_struct *struct_p; 
    size_t array_size = 4; 
    /* Space is allocated for the struct and initialized... */ 
    print_array(struct_p); 
}
```



#### 9.3.7 风险评估

错误的使用包含灵活数组成员的结构体可能会导致未定义的行为。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| MEM33-C | 低       | 不太可能    | 低        | P3      | L3     |




#### 9.3.8 相关指南

| **标准**                        | **条目**                                   |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | DCL38-C. Use the correct syntax when declar-ing a flexible array member |



#### 9.3.9 参考文献
| **文献**                | **条目**                                   |
| --------------------- | ---------------------------------------- |
| [ISO/IEC 9899:2011]   | Subclause 6.7.2.1, “Structure and Union Speci-fiers” |
| [JTC1/SC22/WG14 N791] | Solving the Struct Hack Problem          |



### 9.4 MEM34-C 只释放动态分配的内存

释放并非动态分配的内存会导致严重的错误。这个错误造成的特定后果取决于编译器，有可能什么也不发生，也可能导致程序异常终止。不管是什么编译器，应该避免对不是由动态内存分配函数（例如`malloc()`、`calloc()`、`realloc()`）所返回的指针调用`free()`。

向`realloc()`提供一个指向并非动态分配的内存的指针也会产生类似的情况。`realloc()`函数用于改变一块动态内存的大小。如果向`realloc()`提供一个指向并非由`malloc()`这样的内存分配函数分配的内存的指针，程序可能会异常终止。

C语言标准指出，给`free()`或`realloc()`函数传递一个并非有内存管理函数返回的指针，或释放已经由`free()`或`realloc()`释放的内存，其行为是未定义的。

传递空指针是安全的，因为C语言规范规定给`free()`函数传递空指针，不会有任何动作发生。

 

#### 9.4.1 不合规代码示例

这个不合规代码示例根据`argc`的值，把`c_str`设置为一块动态分配的内存的引用或者一个静态分配的字符串常量。不论那种情况，`c_str`做为参数传递给`free()`。如果`c_str`所引用的并不是动态分配的内存，对`free(c_str)`的调用就会出现错误。

```cpp
#include <stdlib.h> 
#include <string.h> 
#include <stdio.h> 
enum { MAX_ALLOCATION = 1000 }; 
int main(int argc, const char *argv[]) { 
    char *c_str = NULL; 
    size_t len; 
    if (argc == 2) { 
        len = strlen(argv[1]) + 1; 
        if (len > MAX_ALLOCATION) { 
            /* Handle error */ 
        }
        c_str = (char *)malloc(len); 
        if (c_str == NULL) { 
            /* Handle error */
        }
        strcpy(c_str, argv[1]); 
    } else { 
        c_str = "usage: $>a.exe [string]"; 
        printf("%s\n", c_str); 
    }
    free(c_str); 
    return 0; 
}
```



#### 9.4.2 合规解决方案

在这个合规解决方案中，消除了`c_str`执行非动态分配内存的可能。

```cpp
#include <stdlib.h> 
#include <string.h> 
#include <stdio.h> 
enum { MAX_ALLOCATION = 1000 }; 
int main(int argc, const char *argv[]) { 
    char *c_str = NULL; 
    size_t len; 
    if (argc == 2) { 
        len = strlen(argv[1]) + 1; 
        if (len > MAX_ALLOCATION) { 
            /* Handle error */ 
        }
        c_str = (char *)malloc(len); 
        if (c_str == NULL) { 
            /* Handle error */ 
        }
        strcpy(c_str, argv[1]); 
    } else { 
        printf("%s\n", "usage: $>a.exe [string]"); 
        return EXIT_FAILURE; 
    }
    free(c_str); 
    return 0;
}
```



#### 9.4.3 不合规代码示例（realloc()）

在这个不合规代码示例中，调用`realloc()`函数的指针参数，`buf`，并不是指向动态分配的内存。

```cpp
#include <stdlib.h> 
enum { BUFSIZE = 256 }; 
void f(void) { 
    char buf[BUFSIZE]; 
    char *p = (char *)realloc(buf, 2 * BUFSIZE); 
    if (p == NULL) { 
        /* Handle error */ 
    }
}
```



#### 9.4.4 合规解决方案（realloc()）

将`buf`指向动态分配的内存。

当`malloc()`失败后，`realloc()`依然能保证正确，因为给`realloc()`函数传递`null`指针时，`realloc()`的行为等同`malloc()`。

```cpp
#include <stdlib.h> 
enum { BUFSIZE = 256 }; 
void f(void) { 
    char *buf = (char *)malloc(BUFSIZE * sizeof(char)); 
    char *p = (char *)realloc(buf, 2 * BUFSIZE); 
    if (p == NULL) { 
        /* Handle error */ 
    }
}
```



#### 9.4.5 风险评估

释放或重新分配并不是动态分配的内存后，如果这块内存被`malloc()`复用，可能会导致任意的代码被执行。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| MEM34-C | 高       | 很可能     | 中        | P18     | L1     |




#### 9.4.6 相关指南

| **标准**                        | **条目**                                   |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | MEM31-C. Free dynamically allocated memory when no longer needed |
| SEI CERT C++ Coding Standard  | MEM51-CPP. Properly deallocate dynamically allocated resources |
| ISO/IEC TS 17961              | Reallocating or freeing memory that was not dynamically allocated [xfree] |
| MITRE CWE                     | CWE-590, Free of Memory Not on the Heap  |



#### 9.4.7 参考文献
| **文献**              | **条目**                                 |
| ------------------- | -------------------------------------- |
| [ISO/IEC 9899:2011] | Subclause J.2, “Undefined Behavior”    |
| [Seacord 2013b]     | Chapter 4, “Dynamic Memory Management” |




### 9.5 MEM35-C 为对象分配足够的内存

作为长度参数传递给`malloc()`、`calloc()`或`realloc()`的整数值必须是合法的，足以容纳被存储的对象。如果长度参数不正确或者可能被攻击者所操纵，就有可能发生缓冲区溢出。不正确的长度参数、不充分的范围检查、整数溢出或截断会导致分配长度不足的缓冲区。程序员必须保证内存分配函数的长度参数能够分配足够数量的内存。



#### 9.5.1 不合规代码示例（长度计算）

在这个不合规代码示例中，分配了一个`long`类型的数组并赋值给`p`。但是，它使用了`sizeof(int)`来确定分配内存的长度。如果`sizeof(long)`大于`sizeof(int)`，会导致实际分配的内存不足。

```cpp
#include <stdint.h> 
#include <stdlib.h> 
void function(size_t len) { 
    long *p; 
    if (len == 0 || len > SIZE_MAX / sizeof(long)) { /
        * Handle overflow */ 
    }
    p = (long *)malloc(len * sizeof(int)); 
    if (p == NULL) { 
        /* Handle error */ 
    }
    free(p);
}
```



#### 9.5.2 合规解决方案（长度计算）

为了修正这个不合规代码示例，使用`sizeof(long)`确定内存分配的长度。

```cpp
#include <stdint.h> 
#include <stdlib.h> 
void function(size_t len) { 
    long *p; 
    if (len == 0 || len > SIZE_MAX / sizeof(long)) { 
        /* Handle overflow */ 
    }
    p = (long *)malloc(len * sizeof(long)); 
    if (p == NULL) { 
        /* Handle error */ 
    }
    free(p);
}
```



#### 9.5.3 合规解决方案（长度计算）

另外，还可以使用`sizeof(*p)`正确地设置分配的长度。

```cpp
#include <stdint.h> 
#include <stdlib.h> 
void function(size_t len) { 
    long *p; 
    if (len == 0 || len > SIZE_MAX / sizeof(*p)) { 
        /* Handle overflow */
    }
    p = (long *)malloc(len * sizeof(*p)); 
    if (p == NULL) { 
        /* Handle error */ 
    }
    free(p);
}
```



#### 9.5.4 不合规代码示例（指针）

在这个不合规代码示例中，使用指针变量的大小来为`struct tm`确定分配内存的长度，从而导致分配的内存不足。

```cpp
#include <stdlib.h> 
#include <time.h> 
struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { 
    struct tm *tmb; 
    tmb = (struct tm *)malloc(sizeof(tmb)); 
    if (tmb == NULL) { 
        return NULL;
    }
    *tmb = (struct tm) { 
      .tm_sec = sec, .tm_min = min, .tm_hour = hour, 
      .tm_mday = day, .tm_mon = mon, .tm_year = year 
    }; 
    return tmb;
}
```



#### 9.5.5 合规解决方案（指针）

使用指针（解引用）类型来确定单一对象的大小。    

```cpp
#include <stdlib.h> 
#include <time.h> 
struct tm *make_tm(int year, int mon, int day, int hour, int min, int sec) { 
    struct tm *tmb; 
    tmb = (struct tm *)malloc(sizeof(*tmb)); 
    if (tmb == NULL) { 
        return NULL;
    }
    *tmb = (struct tm) { 
        .tm_sec = sec, .tm_min = min, .tm_hour = hour, 
        .tm_mday = day, .tm_mon = mon, .tm_year = year 
    }; 
    return tmb;
}
```



#### 9.5.6 风险评估

向内存分配函数提供无效的长度参数可能导致缓冲区溢出，并可能在具有潜在风险的进程的权限下执行任意代码。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| MEM35-C | 高       | 有可能     | 高        | P6      | L2     |




#### 9.5.7 相关指南

| **标准**                        | **条目**                                   |
| ----------------------------- | ---------------------------------------- |
| CERT C Secure Coding Standard | ARR01-C. Do not apply the sizeof operator to a pointer when taking the size of an array <br>INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data <br>INT32-C. Ensure that operations on signed in-tegers do not result in overflow <br>INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size <br>MEM04-C. Beware of zero-length allocations |
| ISO/IEC TR 24772:2013         | Buffer Boundary Violation (Buffer Overflow) [HCB] |
| ISO/IEC TS 17961:2013         | Taking the size of a pointer to determine the size of the pointed-to type [sizeofptr] |
| MITRE CWE                     | CWE-131, Incorrect Calculation of Buffer Size <br>CWE-190, Integer Overflow or Wraparound <br>CWE-467, Use of sizeof() on a Pointer Type |



#### 9.5.8 参考文献
| **文献**          | **条目**                                   |
| --------------- | ---------------------------------------- |
| [Coverity 2007] |                                          |
| [Drepper 2006]  | Section 2.1.1, “Respecting Memory Bounds” |
| [Seacord 2013]  | Chapter 4, “Dynamic Memory Management” <br>Chapter 5, “Integer Security” |
| [Viega 2005]    | Section 5.6.8, “Use of sizeof() on a Pointer Type” |
| [xorl 2009]     | CVE-2009-0587: Evolution Data Server Base64 Integer Overflows |




### 9.6 MEM36-C 不要使用realloc()修改对齐的内存

不要调用`realloc()`来修改已严格对齐的动态分配的内存大小。使用`aligned_alloc()`函数可以执行更严格的对齐，而`realloc()`函数只执行一般对齐。



#### 9.6.1 不合规代码示例

在这个不合规代码示例中，使用`aligned_alloc()`函数分配4096字节边界严格对齐的内存块。如果`resize`参数的大小大于`ptr`指向的内存块，`realloc()`函数将重新分配一般对齐的合适大小的内存，此时内存将不再保证4096字节边界对齐。       

```cpp
#include <stdlib.h> 
void func(void) { 
    size_t resize = 1024; 
    size_t alignment = 1 << 12; 
    int *ptr; 
    int *ptr1; 
    if (NULL == (ptr = (int *)aligned_alloc(alignment, sizeof(int)))) { 
        /* Handle error */ 
    }
    if (NULL == (ptr1 = (int *)realloc(ptr, resize))) { 
        /* Handle error */ 
    }
}
```



#### 9.6.2 合规解决方案

使用和原内存一致的对齐方式来重新分配内存，并将原内存的内容拷贝到新的内存块。然后释放老的内存。

```cpp
#include <stdlib.h> 
#include <string.h> 
void func(void) { 
    size_t resize = 1024; 
    size_t alignment = 1 << 12; 
    int *ptr; 
    int *ptr1;
    if (NULL == (ptr = (int *)aligned_alloc(alignment, sizeof(int)))) { 
        /* Handle error */ 
    }
    if (NULL == (ptr1 = (int *)aligned_alloc(alignment, resize))) { 
        /* Handle error */
    }
    if (NULL == (memcpy(ptr1, ptr, sizeof(int))) { 
        /* Handle error */ 
    }
    free(ptr);
}
```



#### 9.6.3 合规解决方案（Windows）

Windows定义了`_aligned_malloc()`函数用于分配边界对齐的内存块。以及`_aligned_realloc()`函数用于修改这块内存的大小。

```cpp
#include <malloc.h> 
void func(void) { 
    size_t alignment = 1 << 12; 
    int *ptr; 
    int *ptr1; 
    /* Original allocation */ 
    if (NULL == (ptr = (int *)_aligned_malloc(sizeof(int), alignment))) { 
        /* Handle error */ 
    } 
    /* Reallocation */ 
    if (NULL == (ptr1 = (int *)_aligned_realloc(ptr, 1024, alignment))) {
       _aligned_free(ptr); 
        /* Handle error */ 
    }
    _aligned_free(ptr1);
}
```



#### 9.6.4 风险评估

不适当的对齐操作可能会导致访问和写入任意位置的内存。

| **规则**  | **严重性** | **可能性** | **修补成本** | **优先级** | **级别** |
| ------- | ------- | ------- | -------- | ------- | ------ |
| MEM36-C | 低       | 有可能     | 高        | P2      | L3     |



#### 9.6.5 参考文献
| **文献**              | **条目**                                 |
| ------------------- | -------------------------------------- |
| [ISO/IEC 9899:2011] | 7.22.3.1, “The aligned_alloc Function” |
| [MSDN]              | aligned_malloc()                       |

## 10 输入/输出（FIO）

### 10.1 FIO30-C 排除格式字符串中的用户输入

永远不要使用包含[污染值][tainted value]的格式字符串调用格式化输入输出函数。一个能完全或部分控制格式字符串内容的攻击者能够使有缺陷的进程崩溃、查看堆栈的内容、查看内存的内容或写入到任意内存位置。因此，攻击者可以在有缺陷的进程的权限下执行任意代码[[Seacord 2013b][]]。格式化输出函数特别危险，因为许多程序员没有意识到它们的能力。例如，格式化输出函数可以被用来使用转换指示符`%n`把一个整数值写入到一个指定的地址。

#### 10.1.1 不合规代码示例

这个不合规代码示例中`incorrect_password()`函数是在识别和认证的时候被调用的，当指定的用户不存在或密码不正确时显示一条错误信息。函数接受`user`引用的字符串作为用户名。这是一个由未认证用户引入的[不可信数据][untrusted data]的例子。函数构造一条错误信息然后使用 C 标准的`fprintf()`函数输出到`stderr`。

```cpp
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

void incorrect_password(const char *user) { 
    int ret;
    /* User names are restricted to 256 or fewer characters */ 
    static const char msg_format[] = "%s cannot be authenticated.\n"; 
    size_t len = strlen(user) + sizeof(msg_format); 
    char *msg = (char *)malloc(len); 
    if (msg == NULL) { 
        /* Handle error */ 
    }
    ret = snprintf(msg, len, msg_format, user); 
    if (ret < 0) { 
        /* Handle error */ 
    } else if (ret >= len) { 
        /* Handle truncated output */ 
    }
    fprintf(stderr, msg); 
    free(msg); 
}
```

`incorrect_password()`函数计算消息长度、分配动态存储、然后用`snprintf()`函数在分配的内存中构造消息。加法运算之所以没有检查整数溢出，是因为`user`引用的字符串长度已知等于或小于256。由于在调用`snprintf()`时`%s`字符是被`user`引用的字符串替换的，所以生成的字符串比分配的内存需要少1个字节。`snprintf()`函数通常被用于在多个地方显示的消息或难以构造的消息。然而，生成的代码中包含一个格式字符串[缺陷][vulnerability]，因为`msg`含有不可信用户输入并被当作格式字符串参数传递给`fprintf()`。

#### 10.1.2 合规解决方案（`fputs()`）

这个合规解决方案通过将`fprintf()`调用替换为`fputs()`调用来修正了这个问题，`fputs()`会将`msg`直接输出到`stderr`而不计算其内容:

```cpp
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

void incorrect_password(const char *user) { 
    int ret; 
    /* User names are restricted to 256 or fewer characters */ 
    static const char msg_format[] = "%s cannot be authenticated.\n"; 
    size_t len = strlen(user) + sizeof(msg_format); 
    char *msg = (char *)malloc(len); 

    if (msg == NULL) { 
        /* Handle error */ 
    }

    ret = snprintf(msg, len, msg_format, user); 
    if (ret < 0) { 
        /* Handle error */ 
    } else if (ret >= len) { 
        /* Handle truncated output */ 
    }
    fputs(msg, stderr); 
    free(msg); 
}
```

#### 10.1.3 合规解决方案（`fprintf()`）

这个合规解决方案将不可信用户输入作为可变参数之一传递给`fprintf()`，而不作为格式字符串的一部分，从而排除了格式字符串缺陷的可能性：

```cpp
#include <stdio.h> 

void incorrect_password(const char *user) { 
    static const char msg_format[] = "%s cannot be authenticated.\n"; 
    fprintf(stderr, msg_format, user); 
}
```

#### 10.1.4 不合规代码示例（POSIX）

这个不合规代码示例和第一个不合规代码示例相似，但是它使用 POSIX 的函数`syslog()`[[IEEE Std 1003.1:2013][]]而不是`fprintf()`函数。`syslog()`函数同样易受格式字符串缺陷的影响。

```cpp
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <syslog.h> 

void incorrect_password(const char *user) { 
    int ret; 
    /* User names are restricted to 256 or fewer characters */ 
    static const char msg_format[] = "%s cannot be authenticated.\n"; 
    size_t len = strlen(user) + sizeof(msg_format); 
    char *msg = (char *)malloc(len); 

    if (msg != NULL) { 
        /* Handle error */ 
    }
    ret = snprintf(msg, len, msg_format, user); 
    if (ret < 0) { 
        /* Handle error */ 
    } else if (ret >= len) { 
        /* Handle truncated output */ 
    }
    syslog(LOG_INFO, msg); 
    free(msg); 
}
```

`syslog()`函数最早出现在 BSD 4.2 中并被 Linux 和其他现代的 UNIX 实现所支持。Windows 系统不支持这个函数。

#### 10.1.5 合规解决方案（POSIX）

这个合规解决方案把不可信用户输入作为可变参数之一传递给`syslog()`函数,而不是把它包含在格式字符串中：

```cpp
#include <syslog.h> 

void incorrect_password(const char *user) { 
    static const char msg_format[] = "%s cannot be authenticated.\n"; 
    syslog(LOG_INFO, msg_format, user); 
}
```

#### 10.1.6 风险评估

未能排除格式指示符中的用户输入可能允许一个攻击者使有缺陷的进程崩溃、查看堆栈的内容、查看内存的内容或写入到任意内存位置并因此在有缺陷的进程的权限下执行任意代码。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO30-C|高|很可能|中等|**P18**|**L1**|

##### 10.1.6.1 相关缺陷

两个违反这个规则导致格式字符串缺陷的例子包括[Ettercap][]和[Samba][]。

在 Ettercap v.NG-0.7.2 中，`ncurses`用户接口有一个格式字符串缺陷。`ec_curses.c`的函数`curses_msg()`调用了`wdg_scroll_print()`。`wdg_scroll_print()`接受一个格式字符串及其参数，并将其传递给了`vw_printw()`。`curses_msg()`函数使用了它的一个参数作为格式字符串。这个输入会包含用户数据，导致格式字符串缺陷。

Samba AFS ACL mapping VFS plug-in 未能恰当地[消除][sanitize]用户控制的用于提供给`snprintf()`的格式指示符的文件名。当用户能够写入到使用 Samba 的`afsacl.so`库对 AFS 文件系统的文件设置 Windows NT 访问控制列表的共享时这个[安全漏洞][security flaw]就变得可利用了。

#### 10.1.7 相关指南

|文献|条目|
|---|---|
|CERT Oracle Secure Coding Standard for Java |IDS06-J. Exclude unsanitized user input from format strings |
|CERT Perl Secure Coding Standard |IDS30-PL. Exclude user input from format strings |
|ISO/IEC TR 24772:2013 |Injection [RST] |
|ISO/IEC TS 17961:2013 |Including tainted or out-of-domain input in a format string [usrfmt] |
|MITRE CWE |CWE-134, Uncontrolled Format String |

### 10.2 FIO32-C 不要在设备上执行只适用于文件的操作

在许多操作系统中，包括 Windows 和 UNIX，文件名可能被用于访问特殊文件，这些特殊文件实际上是设备。被保留的微软 Windows 设备名包括`AUX`、`CON`、`PRN`、`COM1`和`LPT1`或使用`\\.\设备名字空间`的路径。UNIX 系统的设备文件被用于在恰当的设备驱动文件上申请访问权限和直接操作。

在设备文件上执行用于普通字符文件或二进制文件的操作会导致系统崩溃及[拒绝服务攻击][denial-of-service attacks]。例如，当 Windows 试图将设备名解释为一个文件资源时，它执行一个无效资源访问，通常导致系统崩溃[[Howard 2002][]]。

当攻击者能以未授权的方式访问 UNIX 设备文件时，设备文件会成为安全风险。例如，如果攻击者们能读取或写入`/dev/kmem`设备，他们可能能够修改他们进程的优先级、UID，或其他属性，或简单地使系统崩溃。类似的，访问磁盘设备、磁带设备、网络设备、及其他进程使用的终端都会导致问题[[Garfinkel 1996][]]。

在Linux系统中，试图打开设备而不是文件可能会锁定某些应用，考虑如下例子：

```
/dev/mouse 
/dev/console 
/dev/tty0 
/dev/zero 
```

一个未能检查这些设备的Web浏览器将允许一个攻击者使用诸如`<IMG src="file:///dev/mouse">`这样的图形标签创建网站，这个网站将锁定用户的鼠标。

#### 10.2.1 不合规代码示例

在这个不合规代码示例中，用户可以指定一个锁定的设备或 FIFO（先进先出）文件名，导致程序在调用`fopen()`函数时挂起：

```cpp
#include <stdio.h> 

void func(const char *file_name) { 
    FILE *file; 
    if ((file = fopen(file_name, "wb")) == NULL) { 
        /* Handle error */ 
    }

    /* Operate on the file */

    if (fclose(file) == EOF) { 
        /* Handle error */ 
    }
}
```

#### 10.2.2 合规解决方案（POSIX）

POSIX 为`open()`定义了`O_NONBLOCK`标志，它确保对一个文件的延时的操作不会导致程序挂起[[IEEE Std 1003.1:2013][]]。

> 当使用`O_RDONLY`或`O_WRONLY`打开 FIFO 时;
>
> 当打开支持非阻塞打开的块专用或字符专用文件时;
>
> 否则，`O_NONBLOCK`的行为是未指定的。

一旦文件被打开，程序员们就可以使用 POSIX 的`lstat()`和`fstat()`函数获取一个文件的信息，并使用`S_ISREG()`宏判断这个文件是否是一个常规文件。

由于`O_NONBLOCK`的行为在随后的`read()`或`write()`调用中是[未指定的][unspecified]，因此在断定有疑问的文件不是特殊设备后禁用这个标志是可取的。

如果可用（Linux2.1.126+, FreeBSD, Solaris 10, POSIX.1-2008），还应该使用`O_NOFOLLOW`标志。（参见[POS01-C. Check for the existence of links when dealing with files.][]）当`O_NOFOLLOW`不可用，符号链接的检查应该使用[POS35-C. Avoid race conditions while checking for the existence of a symbolic link][]提供的方法。

```cpp
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
#include <unistd.h> 

#ifdef O_NOFOLLOW 
    #define OPEN_FLAGS O_NOFOLLOW | O_NONBLOCK 
#else 
    #define OPEN_FLAGS O_NONBLOCK 
#endif 

void func(const char *file_name) { 
    struct stat orig_st; 
    struct stat open_st; 
    int fd; 
    int flags; 

    if ((lstat(file_name, &orig_st) != 0) || 
       (!S_ISREG(orig_st.st_mode))) { 
        /* Handle error */
    }

    /* Race window */ 

    fd = open(file_name, OPEN_FLAGS | O_WRONLY); 
    if (fd == -1) { 
        /* Handle error */ 
    }

    if (fstat(fd, &open_st) != 0) { 
        /* Handle error */ 
    }

    if ((orig_st.st_mode != open_st.st_mode) || 
        (orig_st.st_ino != open_st.st_ino) || 
        (orig_st.st_dev != open_st.st_dev)) { 
        /* The file was tampered with */ 
    }

    /* 
    * Optional: drop the O_NONBLOCK now that we are sure 
    * this is a good file. 
    */ 
    if ((flags = fcntl(fd, F_GETFL)) == -1) { 
        /* Handle error */ 
    }

    if (fcntl(fd, F_SETFL, flags & ~O_NONBLOCK) == -1) { 
        /* Handle error */ 
    }

    /* Operate on the file */

    if (close(fd) == -1) { 
        /* Handle error */ 
    } 
}
```

这段代码包含了一个棘手的的 TOCTOU （检查时间/使用时间）竞争条件，在这个竞争条件下攻击者可以在`lstat()`调用之后`open()`调用之前改变`file_name`引用的文件。这个转换将在文件打开后被发现，但打开文件在这种情况下是无法阻止的，这个行为本身导致不期望的行为。（参见 [FIO45-C.在访问文件时避免TOCTOU竞争条件][]来获得更多关于 TOCTOU 竞争条件的信息）

本质上讲，一个攻击者可以将一个文件替换为下表中的有指定效果的文件类型。

**文件类型和效果**

|类型|效果|
|---|---|
|另一个常规文件|`fstat()`验证失败。|
|FIFO|要么`open()`返回`-1`并设置`errno`为`ENXIO`,要么`open()`成功但是`fstat()`验证失败。|
|符号链接|如果`O_NOFOLLOW`可用则`open()`返回`-1`，否则`fstat()`验证失败。|
|特殊设备|通常`fstat()`验证`st_mode`时失败。如果设备是仅打开（或关闭）就产生副作用，这仍然会是个问题。如果`st_mode`相等，那么这个设备在打开之后就像一个常规文件。它将导致`fstat()`验证`st_dev`和`st_ino`时失败（除非它恰好是同一个文件，例如 Solaris 中的`/dev/fd/*`,但这不是个问题）。|

要想符合该规则并且防止TOCTOU竞争条件，`file_name`必须引用一个安全路径下的文件。（参见 [FIO15-C. Ensure that file operations are performed in a se-cure directory.][]）

#### 10.2.3 不合规代码示例（Windows）

这个不合规代码示例使用`GetFileType()`函数试图阻止打开一个特殊文件：

```cpp
#include <Windows.h> 

void func(const TCHAR *file_name) { 
    HANDLE hFile = CreateFile( 
        file_name, 
        GENERIC_READ | GENERIC_WRITE, 0, 
        NULL, OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL, NULL 
    ); 
    if (hFile == INVALID_HANDLE_VALUE) { 
        /* Handle error */ 
    } else if (GetFileType(hFile) != FILE_TYPE_DISK) { 
        /* Handle error */ 
        CloseHandle(hFile); 
    } else { 
        /* Operate on the file */ 
        CloseHandle(hFile); 
    } 
}
```

尽管很诱人，Win32 的`GetFileType()`函数在这种情况下是很危险的。如果这个给定的文件名标识一个正被读取请求阻塞的命名 pipe,那么`GetFileType()`函数调用将被阻塞直到读取请求完成。这为在该应用上进行[拒绝服务攻击][denial-of-service attack]提供了一个有效的攻击手段。此外，打开文件句柄的行为可能会导致副作用，比如打开一个串行设备时线路状态被设置为它们默认电压。

#### 10.2.4 合规解决方案（Windows）

微软记载了一个表示设备以及明确由设备使用的设备命名空间的保留标识符列表[[MSDN][]]。在这个合规解决方案中，`isReservedName()`函数可以用来判断指定的路径是否引用的是一个设备。在使用`isReservedName()`函数检测一个路径名和后续操作这个路径名时必须小心的规避 TOCTOU 竞争条件。

```cpp
#include <ctype.h> 
#include <stdbool.h> 
#include <stdlib.h> 
#include <string.h> 
#include <stdio.h> 

static bool isReservedName(const char *path) { 
    /* This list of reserved names comes from MSDN */ 
    static const char *reserved[] = { "nul", "con", "prn", "aux", "com1", "com2", "com3", 
        "com4", "com5", "com6", "com7", "com8", "com9", 
        "lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", 
        "lpt7", "lpt8", "lpt9" 
        }; 
    bool ret = false; 

    /*
     * First, check to see if this is a device namespace, which 
     * always starts with \\.\, because device namespaces are not 
     * valid file paths. 
     */

    if (!path || 0 == strncmp(path, "\\\\.\\", 4)) { 
        return true; 
    }

    /* Compare against the list of ancient reserved names */ 
    for (size_t i = 0; !ret && i < sizeof(reserved) / sizeof(*reserved); ++i) { 
        /*
         * Because Windows uses a case-insensitive file system, operate on 
         * a lowercase version of the given filename. Note: This ignores 
         * globalization issues and assumes ASCII characters. 
         */ 
        if (0 == _stricmp(path, reserved[i])) { 
            ret = true; 
        } 
    }
    return ret; 
}
```

#### 10.2.5 风险评估

允许在设备上执行只适用于常规文件的操作会导致[拒绝服务攻击][denial-of-service attacks]或依赖于平台的更严重的[漏洞][exploits]。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO32-C|中|不太可能|中等|**P4**|**L3**|

#### 10.2.6 相关指南

|文献|条目|
|---|---|
|CERT C Secure Coding Standard|FIO05-C. Identify files using multiple file at-tributes <br>FIO15-C. Ensure that file operations are per-formed in a secure directory <br>POS01-C. Check for the existence of links when dealing with files <br>POS35-C. Avoid race conditions while check-ing for the existence of a symbolic link |
|CERT Oracle Secure Coding Standard for Java |FIO00-J. Do not operate on files in shared di-rectories |
|MITRE CWE |CWE-67, Improper Handling of Windows De-vice Names |

### 10.3 FIO34-C 区分从文件中读取的字符和`EOF`或`WEOF`

`EOF`宏表示被用来在从文件中读取数据时指示文件结束且没有剩余数据的一个负数。`EOF`是一个[带内错误指示器][in-band error indicator]的例子。使用带内错误指示器是有问题的，并且创建新的带内错误指示器是受[ERR02-C. Avoid in-band error indicators][]劝阻的。

字节输入输出函数`fgetc()`、`getc()`和`getchar()`都是从一个流中读取一个字符并返一个`int`。（参见 [STR00-C. Represent characters using an appropriate type][]）如果这个流在文件尾，则该流的文件尾指示器被设置且函数返回`EOF`。如果发生读取错误，则该流的错误指示器被设置且函数返回`EOF`。如果这些函数执行成功，它们会将返回的字符转换为一个`unsigned char`。

由于`EOF`是负数，因此它不应该匹配任何一个无符号字符的值。然而，这个只有在`int`类型宽于`char`的[实现][implementations]下才正确。在一个`int`和`char`等宽的实现下，字符读取函数可能读取并返回一个和`EOF`拥有相同的位模式的有效的字符。这是可能发生的，例如，如果一个攻击者在文件或数据流中插入一个看上去像`EOF`的值来改变程序的行为。

C 语言标准只要求`int`类型能够代表最大值为+32767，且`char`类型不长于`int`。虽然罕见，`(int)(unsigned char)65535 == -1` 这种情形会导致整数常量表达式`EOF`和一个有效的字符无法区分。因此，在`sizeof(int) == sizeof(char)`这样稀有的实现下，未能使用`feof()`和`ferror()`来判断文件尾和文件错误会导致错误地识别`EOF`字符。

当读取宽字符的时候，这个问题更为常见。函数`fgetwc()`、`getwc()`和`getwchar()`返回一个`wint_t`类型的值。
这个值可以是下一个读取的宽字符或指示宽字符流的文件尾的`WEOF`。在大部分的实现中，`wchar_t`类型和`wint_t`类型拥有相同的宽度，故这些函数可以返回一个不能区别于`WEOF`的字符。

在 UTF-16字 符集中，`0xFFFF`不是一个字符是有保证的，这允许`WEOF`用`-1`来表示。类似的，所有 UTF-32 字符都是正数，虽然看起来是 32 位有符号整数。所有被广泛应该用的字符集都被设计了至少有一个值不表示一个字符。因此，这需要一个设计时没有考虑 C 编程语言的这个问题的自定义的字符集和宽字符或`int`同宽的普通字符同时出现。

C 语言标准的`feof()`和`ferror()`函数不受这个字符和整数大小关系问题的限制，并且它们应该被用于检查易受影响的实现的文件尾和文件错误[[Kettlewell 2002][]]。在每个循环迭代调用这两个函数增加大量的开销，所以一个好的策略是在循环中暂时信任`EOF`和`WEOF`，在循环后使用`feof()`和`ferror()`进行校验。

#### 10.3.1 不合规代码示例

这个不合规代码示例在字符`c`不为`EOF`时一直循环:

```cpp
#include <stdio.h> 

void func(void) { 
    int c; 

    do { 
        c = getchar(); 
    } while (c != EOF); 
}
```

尽管`EOF`担保是一个负数且和任何一个无符号字符都有区别，但是它不能确保和任意一个这样的被转换为`int`类型的值都不一样。因此，当`int`和`char`拥有同样的宽度时，这个循环可能提前终止。

#### 10.3.2 合规解决方案（可移植的）

这个合规解决方案使用`feof()`检测文件尾，使用`ferror()`检测错误码：

```cpp
#include <stdio.h> 

void func(void) { 
    int c; 

    do { 
        c = getchar(); 
    } while (c != EOF); 
    if (feof(stdin)) { 
        /* Handle end of file */ 
    } else if (ferror(stdin)) { 
        /* Handle file error */ 
    } else { 
        /* Received a character that resembles EOF; handle error */ 
    } 
}
```

#### 10.3.3 不合规代码示例（不可移植的）

这个不合规代码示例使用了一个断言来保证代码只在`int`宽于`char`并且`EOF`确保不为一个有效字符值的架构下执行。然而，这个代码例子是不合规的， 是因为变量`c`被定义为一个`char`而不是一个`int`，由于符号扩展的原因，当`char`是有符号的时候，就使得一个有效字符值和`EOF`宏的值相等成为可能：

```cpp
#include <assert.h> 
#include <limits.h> 
#include <stdio.h> 

void func(void) { 
    char c; 
    static_assert(UCHAR_MAX < UINT_MAX, "FIO34-C violation"); 

    do { 
        c = getchar(); 
    } while (c != EOF); 
}
```

假设一个`char`是一个有符号的 8 位类型，一个`int`是一个 32 位类型，如果`getchar()`返回的字符值是` ’\xff `（十进制255），那么它将被解释为`EOF`，因为这个值会被符号扩展为`0xFFFFFFFF`（EOF的值）来进行比较。（参见 [STR34-C 在转换为更大的整数长度时把字符转换为无符号类型][]）

#### 10.3.4 合规解决方案（不可移植的）

这个合规解决方案定义`c`为一个`int`。所以，循环只有在文件结束时终止：

```cpp
#include <assert.h> 
#include <stdio.h> 
#include <limits.h> 

void func(void) { 
    int c; 
    static_assert(UCHAR_MAX < UINT_MAX, "FIO34-C violation"); 

    do { 
        c = getchar(); 
    } while (c != EOF); 
}
```

#### 10.3.5 不合规代码示例（宽字符）

在这个不合规代码示例中，调用 C 标准库函数`getwc()`的结果被存到一个`wchar_t`类型的变量中并随后被和`WEOF`进行比较：

```cpp
#include <stddef.h> 
#include <stdio.h> 
#include <wchar.h>
enum { BUFFER_SIZE = 32 }; 

void g(void) { 
    wchar_t buf[BUFFER_SIZE]; 
    wchar_t wc; 
    size_t i = 0; 

    while ((wc = getwc(stdin)) != L'\n' && wc != WEOF) { 
        if (i < (BUFFER_SIZE - 1)) { 
            buf[i++] = wc; 
        } 
    }
    buf[i] = L'\0'; 
}
```

这段代码有两个问题。
第一，`getwc()`的返回值在与`WEOF`比较之前被立即转换为了`wchar_t`类型。
第二，没有确保`wint_t`类型宽于`wchar_t`类型的检查。
这两个问题使一个攻击者通过在文件中提供一个和`WEOF`匹配的宽字符值来提前终止循环成为可能。

#### 10.3.6 合规解决方案（可移植的）

这个合规解决方案将`c`定义为一个`wint_t`类型来匹配`getwc()`的整数返回值。此外，它最后不依赖于`WEOF`判定文件尾。

```cpp
#include <stddef.h> 
#include <stdio.h> 
#include <wchar.h> 

enum {BUFFER_SIZE = 32 } 

void g(void) { 
    wchar_t buf[BUFFER_SIZE]; 
    wint_t wc; 
    size_t i = 0; 

    while ((wc = getwc(stdin)) != L'\n' && wc != WEOF) { 
        if (i < BUFFER_SIZE - 1) { 
            buf[i++] = wc; 
        } 
    }
    if (feof(stdin) || ferror(stdin)) { 
        buf[i] = L'\0'; 
    } else { 
        /* Received a wide character that resembles WEOF; handle error */
    } 
}
```

#### 10.3.7 例外

**FIO34-C-EX1:** 一些 C 函数不返回字符但是可以返回`EOF`作为状态码。这些函数包括`fclose()`、`fflush()`、`fputs()`、`fscanf()`、`puts()`、`scanf()`、`sscanf()`、`vfscanf()`和`vscanf()`。这些返回值可以在不验证结果的情况下和`EOF`进行比较。

#### 10.3.8 风险评估

错误地假设文件中的字符不能匹配`EOF`或`WEOF`导致重大缺陷，包括命令注入攻击。（参考 [\*CA-1996-22][]报告）

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO34-C|高|有可能|中等|**P12**|**L1**|

#### 10.3.9 相关指南

|文献|条目|
|---|---|
|CERT C Secure Coding Standard|STR00-C. Represent characters using an appro-priate type <br>INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data |
|CERT Oracle Secure Coding Standard for Java |FIO08-J. Use an int to capture the return value of methods that read a character or byte |
|ISO/IEC TS 17961:2013 |Using character values that are indistinguisha-ble from EOF [chreof]|

### 10.4 FIO37-C 不要假设`fget()`或`fgetws()`在执行成功时返回一个非空字符串

错误地假设被读取的数据的类型时错误就会发生。这些假设可能是违规的，例如，当二进制数据被从文件中读出而不是从用户终端或被管道到`stdin`的进程输出的文本时。（参见 [FIO14-C. Understand the difference between text mode and binary mode with file streams.][]）在一些系统中，也可能能够从键盘输入`null`字节（就像输入其他的二进制码一样）。

C 语言标准[[ISO/IEC 9899:2011][]]章节 7.21.7.2 中讲：

> `fgets`函数如果成功则返回`s`。如果遇到文件尾且没有字符被读入到数组中，则数组中的内容保持不变并返回一个空指针。

用于宽字符的函数`fgetws()`也有同样的行为。所以，如果`fgets()`或`fgetws()`返回一个非空指针，那么假设数组有数据是安全的。然而，假设数组中包含一个非空字符串则是错误的，因为数据中可能包含空字符（null）。

#### 10.4.1 不合规代码示例

这个不合规代码示例试图删除一个输入行的行尾换行符（`\n`）。`fgets()`函数通常用于从一个输入流读取以换行符结尾的一行。它接受一个目标缓冲区的大小的参数`size`，并从一个流中拷贝最多`size - 1`个字符到字符数组中。

```cpp
#include <stdio.h> 
#include <string.h> 

enum { BUFFER_SIZE = 1024 }; 

void func(void) { 
    char buf[BUFFER_SIZE]; 

    if (fgets(buf, sizeof(buf), stdin) == NULL) { 
         /* Handle error */ 
    }
    buf[strlen(buf) - 1] = '\0'; 
}
```

`strlen()`通过确定在结束空字符`null`前面的字符个数来计算字符串长度。如果`fgets()`从输入中读入的第一个字符碰巧是一个空字符（`null`）问题就发生了。这是可能发生的，比如，如果`fgets()`读取一个二进制数据文件[[Lai2006][]]。如果`buf`中的第一个字符是空字符（`null`），`strlen(buf)`返回`0`，表达式`strlen(buf) – 1`回绕成一个巨大的正数，数组写越界错误就发生了。

#### 10.4.2 合规解决方案

这个合规解决方案使用`strchr()`来替换字符串中可能存在的换行符：

```cpp
#include <stdio.h> 
#include <string.h> 

enum { BUFFER_SIZE = 1024 }; 

void func(void) { 
    char buf[BUFFER_SIZE]; 
    char *p; 

    if (fgets(buf, sizeof(buf), stdin)) { 
        p = strchr(buf, '\n'); 
        if (p) { 
            *p = '\0'; 
        } 
    } else { 
        /* Handle error */ 
    } 
}
```

#### 10.4.3 风险评估

错误的假设被读取的字符数据会导致内存写越界或其他有缺陷的逻辑。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO37-C|高|有可能|中等|**P12**|**L1**|

#### 10.4.4 相关指南

|文献|条目|
|---|---|
|CERT C Secure Coding Standard|FIO14-C. Understand the difference between text mode and binary mode with file streams <br>FIO20-C. Avoid unintentional truncation when using fgets() or fgetws() |
|MITRE CWE|CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer <br>CWE-123, Write-what-where Condition <br>CWE-125, Out-of-bounds Read <br>CWE-241, Improper Handling of Unexpected Data Type|

### 10.5 FIO38-C 不要拷贝一个`FILE`对象

依据 C 语言标准 7.21.3 第6段[[ISO/IEC 9899:2011][]]：

> `FILE`对象的地址用来控制一个流可能有效；`FILE`对象的副本不需要服务于原对象。

因此，请不要拷贝一个`FILE`对象。

#### 10.5.1 不合规代码示例

这个不合规代码示例会失败，是因为在调用`fputs()`函数时使用了一个`stdout`的值拷贝副本：

```cpp
#include <stdio.h> 

int main(void) { 
    FILE my_stdout = *stdout; 
    if (fputs("Hello, World!\n", &my_stdout) == EOF) { 
        /* Handle error */ 
    }
    return 0; 
}
```

当在 Microsoft Visual Studio 2013 下编译并在 Windows 上运行时，这个不合规示例会得到一个运行期“访问违例”。

#### 10.5.2 合规解决方案

在这个合规解决方案里，调用`fputs()`函数时使用的是指向`FILE`对象的`stdout`指针的副本：

```cpp
#include <stdio.h> 

int main(void) { 
    FILE *my_stdout = stdout; 
    if (fputs("Hello, World!\n", my_stdout) == EOF) { 
        /* Handle error */ 
    }
    return 0; 
}
```

#### 10.5.3 风险评估

使用一个`FILE`对象的拷贝代替原对象可能导致系统崩溃，这可能被用于[拒绝服务攻击][denial-of-service attack]。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO38-C|低|有可能|中等|**P4**|**L3**|

#### 10.5.4 相关指南

|文献|条目|
|---|---|
|ISO/IEC TS 17961:2013 |Copying a FILE object [filecpy] |

### 10.6 FIO39-C 不要在没有介入冲刷或定位调用的情况下在对一个流交替地进行输入和输出操作

C 语言标准 7.21.5.3 第7段[[ISO/IEC 9899:2011][]]，更新流有以下限制：

> 当一个文件以更新模式打开时...，在关联流上，输入和输出操作都可能被执行。然而，在没有一个介入调用`fflush`函数或文件定位函数（`fseek`、`fsetpos`或`rewind`）情况下输出后不能紧接着输入操作，在没有一个介入调用文件定位函数的情况下输入后也不能紧接着输出操作，除非输入操作遇到了文件尾。在一些实现中，以更新模式打开（或创建）一个文本文件可能反而打开（或创建）一个二进制流。

以下情形会导致[未定义行为][undefined behavior]。（参见[未定义行为151][undefined behavior 151]）

- 如果文件不是文件尾，在没有一个介入调用`fflush()`、`fseek()`、`fsetpos()`或`rewind()`的情况下，从一个流接收输入紧跟在对那个流的输出之后
- 如果文件不是文件尾，在没有调用`fseek()`、`fsetpos()`或`rewind()`的情况下，在从一个流输入后输出到该流

因此，在对同一个流进行输入和输出之间需要调用`fseek()`、`fflush()`或`fsetpos()`。参见 [ERR07-C. Prefer functions that support error checking over equiva-lent functions that don’t][] 来获取更多关于为什么`fseek()`优于`rewind()`的信息。

#### 10.6.1 不合规代码示例

这个不合规代码示例向一个文件添加数据然后从同一文件中读取数据：

```cpp
#include <stdio.h> 

enum { BUFFERSIZE = 32 }; 

extern void initialize_data(char *data, size_t size); 

void func(const char *file_name) { 
    char data[BUFFERSIZE]; 
    char append_data[BUFFERSIZE]; 
    FILE *file; 

    file = fopen(file_name, "a+"); 
    if (file == NULL) { 
        /* Handle error */ 
    }

    initialize_data(append_data, BUFFERSIZE); 

    if (fwrite(append_data, 1, BUFFERSIZE, file) != BUFFERSIZE) {
        /* Handle error */ 
    }
    if (fread(data, 1, BUFFERSIZE, file) < BUFFERSIZE) { 
        /* Handle there not being data */ 
    }

    if (fclose(file) == EOF) { 
        /* Handle error */ 
    } 
}
```

由于在`fread()`和`fwrite()`之间没有介入冲刷或定位调用，它的行为是[未定义的][undefined]。

#### 10.6.2 合规解决方案

在这个合规解决方案中，在输入和输出之间调用了`fseek()`，消除了未定义行为：

```cpp
#include <stdio.h> 

enum { BUFFERSIZE = 32 }; 
extern void initialize_data(char *data, size_t size); 

void func(const char *file_name) { 
    char data[BUFFERSIZE]; 
    char append_data[BUFFERSIZE]; 
    FILE *file; 

    file = fopen(file_name, "a+"); 
    if (file == NULL) { 
        /* Handle error */ 
    }

    initialize_data(append_data, BUFFERSIZE); 
    if (fwrite(append_data, BUFFERSIZE, 1, file) != BUFFERSIZE) { 
        /* Handle error */ 
    }

    if (fseek(file, 0L, SEEK_SET) != 0) { 
        /* Handle error */ 
    }

    if (fread(data, BUFFERSIZE, 1, file) != 0) {
         /* Handle there not being data */ 
    }

    if (fclose(file) == EOF) {
        /* Handle error */
    } 
}
```

#### 10.6.3 风险评估

在没有介入冲刷或定位调用的情况下对一个流交替地执行输入和输出操作是[未定义行为][undefined behavior]。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO39-C|低|很可能|中等|**P6**|**L2**|

#### 10.6.4 相关指南

|文献|条目|
|---|---|
|SEI CERT C++ Coding Standard|FIO50-CPP. Do not alternately input and out-put from a file stream without an intervening positioning call|
|ISO/IEC TS 17961:2013|Interleaving stream inputs and outputs without a flush or positioning call [ioileave]|

### 10.7 FIO40-C 在`fgets()`或`fgetws()`失败时重置字符串

如果 C 标准函数`fgets()`或`fgetws()`失败，写入数组的内容是[不确定的][indeterminate]（参见[未定义行为 170][undefined behavior 170]）。将字符串重置为一个已知值来避免随后的字符串操作函数的错误是必要的。

#### 10.7.1 不合规代码示例

在这个不合规代码示例中，如`果fgets()`失败则设置一个错误标志。但是，`buf`没有被重置且有不确定的内容：

```cpp
#include <stdio.h> 

enum { BUFFER_SIZE = 1024 }; 
void func(FILE *file) { 
    char buf[BUFFER_SIZE]; 

    if (fgets(buf, sizeof(buf), file) == NULL) { 
       /* Set error flag and continue */ 
    } 
}
```

#### 10.7.2 合规解决方案

在这个合规解决方案中，如果`fgets()`失败，`buf`被设置为一个空字符串。同样的对`fgetws()`的解决方案是将`buf`设置为空的宽字符串。

```cpp
#include <stdio.h> 

enum { BUFFER_SIZE = 1024 }; 

void func(FILE *file) { 
    char buf[BUFFER_SIZE]; 

    if (fgets(buf, sizeof(buf), file) == NULL) { 
        /* Set error flag and continue */ 
        *buf = '\0'; 
    } 
}
```

#### 10.7.3 例外

**FIO40-C-EX1:** 如果字符串在调用`fgets()`或`fgetws()`后立即超出了作用域，或在失败的的情况下不会被引用，就不需要对它进行重置。

#### 10.7.4 风险评估

对被`fgets()`或`fgetws()`修改过的数组内容作无效的假设会导致[未定义行为][undefined behavior]及[程序异常终止][abnormal program termination]。

|规则|严重性|可能性|修补成本|优先级|级别|
|----|----|----|----|----|----|
|FIO40-C|低|有可能|中等|**P4**|**L3**|

### 10.8 FIO41-C 不要使用有副作用的流参数调用`getc()`、`putc()`、`getwc()`或`putwc()`

不要使用有副作用的流参数调用`getc()`或`putc()`或宽字符的`getwc()`和`putwc()`。如果这些函数是用不安全宏实现的话，这个传递给这些宏的流参数可能被计算不止一次。（参见 [PRE31-C 避免不安全宏的参数出现副作用][] 获取更多信息）

这个规则不适用于`putc()`的字符参数或`putwc()`的宽字符参数，它们担保只被计算一次。

#### 10.8.1 不合规代码示例（`getc()`）

这个不合规代码示例使用一个表达式作为流参数调用`getc()`函数。如果`getc()`是用宏实现的，那么文件可能会被打开多次。（参见 [FIO24-C. Do not open a file that is already open.][]）

```cpp
#include <stdio.h> 

void func(const char *file_name) { 
    FILE *fptr; 

    int c = getc(fptr = fopen(file_name, "r")); 
    if (feof(stdin) || ferror(stdin)) { 
        /* Handle error */ 
    }
    if (fclose(fptr) == EOF) { 
        /* Handle error */ 
    } 
}
```

因为没有检查`fopen()`的返回值是否存在错误，这个不合规代码示例也违反了 [ERR33-C 检查和处理标准库的错误][] 。

#### 10.8.2 合规解决方案（`getc()`）

在这个合规解决方案中，`fopen()`在`getc()`之前被调用，并且检查了其返回值是否存在错误：

```cpp
#include <stdio.h> 

void func(const char *file_name) { 
    int c; 
    FILE *fptr; 

    fptr = fopen(file_name, "r"); 
    if (fptr == NULL) {
        /* Handle error */ 
    }

    c = getc(fptr); 
    if (c == EOF) { 
        /* Handle error */ 
    }

    if (fclose(fptr) == EOF) { 
        /* Handle error */ 
    } 
}
```

#### 10.8.3 不合规代码示例（`putc()`）

在这个不合规代码示例中，使用一个表达式作为流参数调用`putc()`。如果`putc()`是用宏实现的，那么表达式可能会被计算多次。

```cpp
#include <stdio.h> 

void func(const char *file_name) { 
    FILE *fptr = NULL; 
    int c = 'a'; 

    while (c <= 'z') { 
        if (putc(c++, fptr ? fptr : (fptr = fopen(file_name, "w")) == EOF) {
            /* Handle error */ 
        } 
    }

    if (fclose(fptr) == EOF) { 
        /* Handle error */ 
    } 
}
```

这个不合规代码示例中，即使`putc()`宏多次计算它的流参数，看起来应该也是安全的，因为三元条件表达式表面上防止了多次调用`fopen()`。然而，给`fptr`赋值和三元条件表达式的控制表达式对`fptr`的计算在同一序列点之间顺序可以相互替换，从而导致[未定义行为][undefined behavior]。（违反了 [EXP30-C 不要依赖序列点之间的求值顺序][] ）。由于未能对`fopen()`的返回值进行检查, 因此该代码还违反了 [ERR33-C 检查和处理标准库的错误][]。

#### 10.8.4 合规解决方案（`putc()`）

在这个合规解决方案中，`putc()`的流参数不再有副作用：

```cpp
#include <stdio.h> 

void func(const char *file_name) { 
    int c = 'a'; 
    FILE *fptr = fopen(file_name, "w"); 

    if (fptr == NULL) { 
        /* Handle error */ 
    }

    while (c <= 'z') { 
        if (putc(c++, fptr) == EOF) { 
            /* Handle error */ 
        } 
    }

    if (fclose(fptr) == EOF) { 
        /* Handle error */ 
    } 
}
```

表达式`c++`是绝对安全的，因为`putc()`确保对其字符变量只计算一次。

注：这个合规解决方案的输出因字符集的不同而不同。例如，当运行在一台基于 ASCII 编码集（例如 ISO-8859 或 Unicode ）的计算机上，将打印出26个小写英文字母。但是，如果运行在一台基于 EBCDIC 编码集（例如 Codepage 037 或 Codepage 285 ）的计算机上，可能在字母之间输出标点符号或其他符号。

#### 10.8.5 风险评估

使用一个有副作用的表达式作为`getc()`、`putc()`或`getwc()`的流参数会导致[意外行为][unexpected behavior]和[程序异常终止][abnormal program termination]。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|---|
|FIO41-C|低|不太可能|中等|**P2**|**L3**|

#### 10.8.6 相关指南

|文献|条目|
|---|---|
|CERT C Secure Coding Standard|FIO24-C. Do not open a file that is already open EXP30-C. Do not depend on the order of eval-uation for side effects|

### 10.9 FIO42-C 当文件不再需要时将它们关闭

在保存调用返回值的最后一个指针的生命周期结束或程序正常退出之前，无论哪个先发生，`fopen()`或`freopen()`调用必须匹配一个`fclose()`调用。

一般来说，这个规则也应当应用到其他打开关闭资源的函数中，比如 POSIX 的`open()`和`close()`函数，或微软 Windows 的`CreateFile()`和`CloseHandle()`函数。

#### 10.9.1 不合规代码示例

这个代码示例是不合规的，是因为文件被调用`fopen()`打开了但是在`func()`函数返回之前没有被关闭：

```cpp
#include <stdio.h> 

int func(const char *filename) { 
    FILE *f = fopen(filename, "r"); 
    if (NULL == f) { 
        return -1; 
    }
    /* ... */ 
    return 0; 
}
```

#### 10.9.2 合规解决方案

在这个合规解决方案中，`f`指向的文件在返回调用者之前被关闭了：

```cpp
#include <stdio.h> 

int func(const char *filename) { 
    FILE *f = fopen(filename, "r"); 
    if (NULL == f) { 
        return -1; 
    }
    /* ... */ 
    if (fclose(f) == EOF) { 
        return -1; 
    }
    return 0; 
}
```

#### 10.9.3 不合规代码示例（`exit()`）

这个代码示例是不合规的，是因为调用`fopen()`申请的资源在程序结束之前没有被关闭。虽然`exit()`关闭文件，但是程序无法判断在冲刷和关闭文件的时候是否有错误发生。

```cpp
#include <stdio.h> 
#include <stdlib.h> 

int main(void) { 
    FILE *f = fopen(filename, "w"); 
    if (NULL == f) { 
        exit(EXIT_FAILURE); 
    }
    /* ... */ 
    exit(EXIT_SUCCESS); 
}
```

#### 10.9.4 合规解决方案（`exit()`）

在这个合规解决方案中，程序在调用`exit()`之前显式地关闭`f`，并允许妥善处理任何冲刷或关闭文件时产生的错误：

```cpp
#include <stdio.h> 
#include <stdlib.h> 

int main(void) { 
    FILE *f = fopen(filename, "w"); 
    if (NULL == f) { 
        /* Handle error */ 
    }
    /* ... */ 
    if (fclose(f) == EOF) { 
        /* Handle error */ 
    }
    exit(EXIT_SUCCESS); 
}
```

#### 10.9.5 不合规代码示例（POSIX）

这段代码示例是不合规的，是因为调用`open()`申请的资源在`func()`函数返回之前没有被关闭：

```cpp
#include <stdio.h> 
#include <fcntl.h> 

int func(const char *filename) { 
    int fd = open(filename, O_RDONLY, S_IRUSR); 
    if (-1 == fd) {
        return -1 
    }
    /* ... */ 
    return 0; 
}
```

#### 10.9.6 合规解决方案（POSIX）

在这个合规解决方案中，`fd`在函数返回调用者之前被关闭了：

```cpp
#include <stdio.h> 
#include <fcntl.h> 
#include <unistd.h> 

int func(const char *filename) { 
    int fd = open(filename, O_RDONLY, S_IRUSR); 
    if (-1 == fd) { 
        return -1 
    }
    /* ... */ 
    if (-1 == close(fd)) { 
        return -1; 
    }
    return 0; 
}
```

#### 10.9.7 不合规代码示例（Windows）

在这个不合规代码示例中，使用微软 Windows 的`CreateFile()`函数打开的文件在`func()`函数返回之前没有被关闭：

```cpp
#include <Windows.h> 

int func(LPCTSTR filename) { 
    HANDLE hFile = CreateFile(filename, GENERIC_READ, 0, NULL, 
                                OPEN_EXISTING, 
                                FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile) { 
        return -1; 
    }
    /* ... */ 
    return 0; 
}
```

#### 10.9.8 合规解决方案（Windows）

在这个合规解决方案中，在返回调用者之前调用了`CloseHandle()`函数将`hFile`关闭了：

```cpp
#include <Windows.h> 

int func(LPCTSTR filename) { 
    HANDLE hFile = CreateFile(filename, GENERIC_READ, 0, NULL, 
                                OPEN_EXISTING, 
                                FILE_ATTRIBUTE_NORMAL, NULL); 
    if (INVALID_HANDLE_VALUE == hFile) { 
        return -1; 
    } 
    /* ... */ 
    if (!CloseHandle(hFile)) { 
        return -1; 
    }

    return 0; 
}
```

#### 10.9.9 风险评估

未能正确地关闭文件可能会允许一个攻击者耗尽系统资源，并且会增加在[程序异常终止][abnormal program termination]的情况下被写到内存文件缓冲区的数据不被冲刷风险。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO42-C|中|不太可能|中等|**P4**|**L3**|

#### 10.9.10 相关指南

|文献|条目|
|---|---|
|SEI CERT C++ Coding Standard |FIO51-CPP. Close files when they are no longer needed |
|CERT Oracle Secure Coding Standard for Java |FIO04-J. Release resources when they are no longer needed |
|ISO/IEC TS 17961:2013 |Failing to close files or free dynamic memory when they are no longer needed [fileclose] |
|MITRE CWE |CWE-404, Improper Resource Shutdown or Release |

### 10.10 FIO44-C 只使用`fgetpos()`返回的值作为`fsetpos()`的参数

C 语言标准 7.21.9.3 [[ISO/IEC 9899:2011][]] 定义了`fsetpos()`的如下行为：

> `fsetpos`函数设置`mbstate_t`对象（如果有），并根据`pos`指向的对象的值设置`stream`指向的流的文件位置指示器，`pos`指向的对象的值应该是从前面在关联到相同文件的流上成功调用`fgetpos`函数获得的。

使用任何其他值作为`pos`调用`fsetpos()`函数都是[未定义行为][undefined behavior]。

#### 10.10.1 不合规代码示例

这个不合规代码示例试图从一个文件中读取三个值，然后把文件位置指针指回文件起始位置：

```cpp
#include <stdio.h> 
#include <string.h> 

int opener(FILE *file) { 
    int rc; 
    fpos_t offset; 

    memset(&offset, 0, sizeof(offset)); 

    if (file == NULL) { 
        return -1; 
    }

    /* Read in data from file */ 

    rc = fsetpos(file, &offset); 
    if (rc != 0 ) { 
        return rc; 
    }

    return 0; 
}
```

只有`fgetpos()`的返回值才是一个有效的`fsetpos()`参数。传递一个任意其他方法创建的`fpos_t`类型的值给`fsetpos()`都是[未定义行为][undefined behavior]。

#### 10.10.2 合规解决方案

在这个合规解决方案中，初始文件位置指示器在第一次调用`fgetpos()`时被保存下来，用于后面调用`fsetpos()`恢复到文件开始状态：

```cpp
#include <stdio.h> 
#include <string.h> 

int opener(FILE *file) { 
    int rc; 
    fpos_t offset; 

    if (file == NULL) { 
        return -1; 
    }

    rc = fgetpos(file, &offset); 
    if (rc != 0 ) { 
        return rc; 
    }

    /* Read in data from file */

    rc = fsetpos(file, &offset); 
    if (rc != 0 ) { 
        return rc; 
    }

    return 0; 
}
```

#### 10.10.3 风险评估

误用`fsetpos()`函数会把一个文件位置指示器设置为文件中一个意想不到的位置。


|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO44-C|中|不太可能|中等|**P4**|**L3**|

#### 10.10.4 相关指南

|文献|条目|
|---|---|
|ISO/IEC TS 17961:2013|Using a value for fsetpos other than a value re-turned from fgetpos [xfilepos]|

### 10.11 FIO45-C 在访问文件时避免 TOCTOU 竞争条件

当两个或多个并发进程操作一个共享文件系统时，[TOCTOU][]（检查时间/使用时间）竞争条件是可能的 [[Seacord 2013b][]] 。 典型地，前一次访问是检查核实文件的某些属性，随后使用这个文件。一个攻击者可以在两次访问间改变文件，或替换为一个不同的文件的符号链接或硬链接。当一个程序对一个相同的文件名或路径名执行两个或多个文件操作时，这些 TOCTOU 条件就能被利用。

一个在一个单一的文件名或路径名上执行两个或多个文件操作的程序在两个文件操作之间创建了一个竞争窗口。这个竞争窗口来自于对两次操作的文件名或路径名引用同一个资源的假设。如果一个攻击者能修改那个文件、删除那个文件、或替换成一个不同的文件，这个假设就不成立了。

#### 10.11.1 不合规代码示例

如果一个已存在的文件被使用`w`模式参数打开来进行写操作，那么这个文件以前的内容（如果有）就被破坏了。这个不合规代码示例尝试使用在打开进行写操作之前先打开进行读操作来防止已存在的文件被覆盖。一个攻击者可以利用在调用两个`fopen()`之间的竞争窗口来覆盖这个已存在的文件。

```cpp
#include <stdio.h> 

void open_some_file(const char *file) { 
    FILE *f = fopen(file, "r"); 
    if (NULL != f) { 
        /* File exists, handle error */ 
    } else { 
        if (fclose(f) == EOF) { 
            /* Handle error */ 
        }
        f = fopen(file, "w"); 
        if (NULL == f) { 
            /* Handle error */ 
        }
    
        /* Write to file */ 
        if (fclose(f) == EOF) { 
            /* Handle error */ 
        } 
    } 
}
```

#### 10.11.2 合规解决方案

这个合规解决方案使用 C11 引入`fopen()`的`x`模式在一个地方调用`fopen()`。这个模式在文件已存在时导致`fopen()`失败。这个检查和随后的打开的执行不会创建竞争窗口。`x`模式只在主机环境支持的情况下提供排外的文件访问。

```cpp
#include <stdio.h> 

void open_some_file(const char *file) { 
    FILE *f = fopen(file, "wx") 
    if (NULL == f) { 
        /* Handle error */ 
    }
    /* Write to file */ 
    if (fclose(f) == EOF) { 
        /* Handle error */ 
    } 
}
```

#### 10.11.3 合规解决方案（POSIX）

这个合规解决方案使用了 POSIX 的`open()`函数的`O_CREAT`和`O_EXCL`标志。这些标志在文件存在的时候导致`open()`失败。

```cpp
#include <stdio.h> 
#include <unistd.h> 
#include <fcntl.h> 

void open_some_file(const char *file) { 
    int fd = open(file, O_CREAT | O_EXCL | O_WRONLY); 
    if (-1 != fd) { 
        FILE *f = fdopen(fd, "w"); 
        if (NULL != f) { 
            /* Write to file */ 
            if (fclose(f) == EOF) { 
                /* Handle error */ 
            } 
        } else { 
            if (close(fd) == -1) { 
                /* Handle error */ 
            } 
        } 
    } 
}
```

#### 10.11.4 例外

**FIO45-C-EX1:** TOCTOU 竞争条件需要有缺陷的进程比攻击者有更多的特权，否则在一次成功的攻击中什么也的不到，一个没有特权的进程不受此规则限制。

**FIO45-C-EX2:** 如果一个文件名或路径名引用的是一个安全目录里的文件，就允许对这个文件名或路径名多次访问（获得更多信息请参见 [FIO15-C. Ensure that file opera-tions are performed in a secure directory][]）。

**FI045-C-EX3:** 如果程序能校验每一次操作都操作的是同一个文件，就允许对一个文件名或目录名进行多次访问。

这个 POSIX 代码示例校验了随后的文件操作都是在同一文件上。在 POSIX 中，每个文件都可以被用它们的`device`和`i-node`属性唯一标识。这个代码示例调用`lstat()`函数检查文件名引用了一个常规文件（不是目录、符号链接或其它特殊文件）。这个调用同样检索它的`device`和`i-node`属性。文件随后被打开。最后，程序校验被打开的文件是和被确认是一个常规文件的那个文件是同一个文件（匹配`device`和`i-node`）。

```cpp
#include <sys/stat.h> 
#include <fcntl.h> 

int open_regular_file(char *filename, int flags) { 
    struct stat lstat_info; 
    struct stat fstat_info; 
    int f; 

    if (lstat(filename, &lstat_info) == -1) { 
        /* File does not exist, handle error */ 
    }

    if (!S_ISREG(lstat_info.st_mode)) { 
        /* File is not a regular file, handle error */ 
    }

    if ((f = open(filename, flags)) == -1) { 
        /* File has disappeared, handle error */ 
    }

    if (fstat(f, &fstat_info) == -1) { 
        /* Handle error */ 
    }

    if (lstat_info.st_ino != fstat_info.st_ino || 
        lstat_info.st_dev != fstat_info.st_dev) { 
        /* Open file is not the expected regular file, handle error */ 
    }

    /* f is the expected regular open file */ 
    return f; 
}
```

#### 10.11.5 风险评估

[TOCTOU][]竞争条件会导致[意外行为][unexpected behavior]，包括权限提升。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO45-C|高|有可能|高|**P6**|**L2**|

### 10.12 FIO46-C 不要访问一个已关闭的文件

`FILE`对象关联的文件关闭后使用指向该对象的指针值是[未定义行为][undefined behavior]。（参见 [未定义行为 148][undefined behavior 148]）关闭标准流（特别是`stdout`、`stderr`和`stdin`）的程序必须注意在随后的函数调用中不要使用到这些流，特别是对它们隐式操作的那些函数（比如`printf()`，`perror()`和`getc()`）。

这个规则可以推广到其他的文件描述符。

#### 10.12.1 不合规代码示例

在这个不合规代码示例中，`stdout`流在其被关闭后被使用了：

```cpp
#include <stdio.h> 

int close_stdout(void) { 
    if (fclose(stdout) == EOF) { 
        return -1; 
    }

    printf("stdout successfully closed.\n"); 
    return 0; 
}
```

#### 10.12.2 合规解决方案

在这个合规解决方案中，`stdout`在其被关闭后没有再次被使用。这必须在其余的程序中保持，否则`stdout`必须被赋值一个打开的文件对象地址。

```cpp
#include <stdio.h> 

int close_stdout(void) { 
    if (fclose(stdout) == EOF) { 
        return -1; 
    }

    fputs("stdout successfully closed.", stderr); 
    return 0; 
}
```

#### 10.12.3 风险评估

`FILE`对象关联的文件关闭后使用指向该对象的指针值是[未定义行为][undefined behavior]。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO46-C|中|不太可能|中等|**P4**|**L3**|

### 10.13 FIO47-C 使用有效的格式字符串

格式化输出函数（`fprintf`及相关函数)在一个`format`字符串的控制下转换、格式化并输出他们的参数。C 语言标准 7.21.6.1 第3段[[ISO/IEC 9899:2011][]]中描述： 

> `format`应该是一个多字节字符序列，开始和结束于它的初始变换状态。`format`是由0个或多个指示符构成：普通多字节字符（非`%`），它们被原样拷贝到输出流；转换描述符，如果适用，依照每个相应的转换描述获取0个或多个后续参数并转换它们，然后将结果写到输出流。

每个转换描述符都是使用`%`字符引入并(按顺序)紧跟:
- 0 或多个标志（任意顺序），这些标志改变转换描述符的意图
- 1 个可选的最小域宽度
- 1 个可选的精度，用来给出某些转换描述符中出现的数字的最小个数
- 1 个可选的长度修饰符，用来描述参数的大小
- 1 个转换指示字符，用来指出被应用的转换类型

创建格式字符串的常见的错误包括：
- 为一个格式字符串提供的参数个数不正确
- 使用无效的转换指示符
- 使用一个和转换指示符不兼容的标志
- 使用一个和转换指示符不兼容的长度修饰符
- 参数类型和转换指示符不匹配
- 使用非`int`型的参数作为宽度或精度

下表总结了各种转换说明符的合规性。第一列包含了一个或多个转换指示字符。后面四列是考虑指示符和各种标志（撇号['], -, +, 空格， #和0）的组合。再后面的八列是考虑指示符和各种长度修饰符（h, hh, l, ll, j, z, t 和L）的组合。

有效的结合被用类型名作了标记，转换说明符匹配的参数被用这种类型进行解释。例如，一个参数被指示符`%hd`匹配被解释为一个`short`，当`d`和`h`结合使用的时候`short`类型的值就会出现在那个位置。最后一列指示使用原始指示符匹配的参数的期望类型。

有效且有意义的组合被符号标记出来（像前面描述的那样，在长度修饰符那一列中保存）。有效但是没有效果的组合被标注为`N/E`。使用一个被符号标记的组合、使用一个表中没有描述的规格，或使用一个不期望的类型的参数是[未定义行为][undefined behavior]（参见 未定义行为 [153][], [155][], [157][], [158][], [161][]和 [162][]）。

|转换说明字符|'XSI   |-,+,SPACE|#  |0  |h  |hh |l  |ll |j  |z  |t  |L  |参数类型|
|------------|-------|---------|---|---|---|---|---|---|---|---|---|---|--------|
|d,i|&radic;|&radic;|&times;|&radic;|short|signed char |long|long long|intmax_t|size_t|ptrdiff_t|&times;|Signed integer |
|o|&times;|&radic;|&radic;|&radic;|unsigned short|unsigned char|unsigned long|unsigned long long|uintmax_t|size_t|ptrdiff_t|&times;|Unsigned integer|
|u|&radic;|&radic;|&times;|&radic;|unsigned short|unsigned char|unsigned long|unsigned long long|uintmax_t|size_t|ptrdiff_t|&times;|Unsigned integer|
|x, X|&times;|&radic;|&radic;|&radic;|unsigned short|unsigned char|unsigned long|unsigned long long|uintmax_t|size_t|ptrdiff_t|&times;|Unsigned integer|
|f, F|&radic;|&radic;|&radic;|&radic;|&times;|&times;|N/E|N/E|&times;|&times;|&times;|long double|double或long double|
|e, E|&times;|&radic;|&radic;|&radic;|&times;|&times;|N/E|N/E|&times;|&times;|&times;|long double|double或long double|
|g, G|&radic;|&radic;|&radic;|&radic;|&times;|&times;|N/E|N/E|&times;|&times;|&times;|long double|double或long double|
|a, A|&radic;|&radic;|&radic;|&radic;|&times;|&times;|N/E|N/E|&times;|&times;|&times;|long double|double或long double|
|c|&times;|&radic;|&times;|&times;|&times;|&times;|wint_t|&times;|&times;|&times;|&times;|&times;|int或wint_t|
|s|&times;|&radic;|&times;|&times;|&times;|&times;|NTWS|&times;|&times;|&times;|&times;|&times;|NTBS或NTWS|
|p|&times;|&radic;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|void*|
|n|&times;|&radic;|&times;|&times;|short*|char*|long*|long long*|intmax_t*|size_t*|ptrdiff_t*|&times;|指向integer的指针|
|CXSI|&times;|&radic;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|wint_t|
|SXSI|&times;|&radic;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|NTWS|
|%|&times;|&radic;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|&times;|none|

SPACE：空格字符（""）
N/E：没有效果
NTBS：指向一个`null`结尾的字符串`char*`参数
NTWS：指向一个`null`结尾的宽字符串`wchar_t*`参数
XSI: [ISO/IEC 9945-2003][] XSI扩展

格式化输入函数（`fscanf()`及相关函数）使用类似说明的格式字符串，并在它们的格式字符串和参数上加以类似的限制条件。

不要提供一个未知或无效的格式说明符或一个无效的标志、精度、长度修饰符或转换指示符的组合给一个格式化输入输出函数。同样，不要提供一个参数的数量或类型和格式字符串中使用的转换描述符参数类型不匹配的参数。

格式字符串通常是在调用的位置说明的字符串文本，但这不是必须的。然而，它们不应该包含[污染值][tainted values]。（参见 [FIO30-C 排除格式字符串中的用户输入][]来获得更多信息）

#### 10.13.1 不合规代码示例

参数和转换说明符不匹配可能导致[未定义行为][undefined behavior]。编译器可能会诊断格式化输出函数调用中的类型不匹配。在这个不合规代码示例中，传递给`printf()`的参数`error_type`错误地使用`s`指示符而不是`d`指示符进行匹配。同样，`error_msg`参数错误地使用`d`指示符而不是`s`指示符进行匹配。这些用法导致[未定义行为][undefined behavior]。这个调用的一个可能的结果是`printf()`将`error_type`参数解释为一个指针并尝试从`error_type`的内容作为地址读取一个字符串，可能导致一个访问违例。

```cpp
#include <stdio.h> 

void func(void) { 
    const char *error_msg = "Resource not available to user."; 
    int error_type = 3; 
    /* ... */ 
    printf("Error (type %s): %d\n", error_type, error_msg); 
    /* ... */ 
}
```

#### 10.13.2 合规解决方案

这个合规解决方案确保传给`printf()`函数的参数匹配它们各自的转换描述符：

```cpp
#include <stdio.h> 

void func(void) { 
    const char *error_msg = "Resource not available to user."; 
    int error_type = 3; 
    /* ... */ 
    printf("Error (type %d): %s\n", error_type, error_msg); 
    /* ... */ 
}
```

#### 10.13.3 风险评估

错误描述的格式字符串会导致内存破坏或[程序异常终止][abnormal program termination]。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|FIO47-C|高|不太可能|中等|**P6**|**L2**|

#### 10.13.4 相关指南

|文献|条目|
|---|---|
|SEI CERT C++ Coding Standard |FIO00-CPP. Take care when creating format strings |
|ISO/IEC TS 17961:2013 |Using invalid format strings [invfmtstr] |
|MITRE CWE |CWE-686, Function Call with Incorrect Argu-ment Type |


## 11 环境（ENV）

### 11.1 ENV30-C.不要修改某些函数的返回值所引用的对象
有些函数返回一个指向某个对象的指针，而修改该对象的值会导致未定义的行为。这些函数包括getenv()，setlocale()，localeconv()，asctime()以及strerror()。在这种情况下，函数调用的结果必须当作const限定来进行对待。
C语言标准 7.22.4.6，段落4[ISO/IEC 9899:2011]对getenv()定义如下：
>getenv()函数返回一个指向一个字符串的指针，该字符串与匹配的列表成员相关。程序不能修改所指向的字符串，但下次调用getenv函数可能会覆盖该字符串。如果无法找到指定的名称，则返回一个null指针。

如果必须要对getenv()返回的字符串进行修改，应该创建一份本地的拷贝。修改getenv()返回的字符串是未定义行为（参见undefined behavior 184。）

类似地，7.11.1.1小节，段落8[ISO/IEC 9899:2011]，对setlocale()定义如下：
>setlocale函数返回指向字符串的指针，后续通过该字符串的值及其关联的类别来调用该函数，可以恢复那一部分程序的地区设置。程序不能修改指针所指向的字符串，但该字符串可能会被后续的setlocale函数调用所覆盖。

同时，7.11.2.1小节，段落8[ISO/IEC 9899:2011]对localeconv()定义如下：
>localeconv函数返回一个指向了已填写了内容的对象的指针。程序不能修改返回值所指向的结构体，但该结构体可能会被后续的localeconv函数调用覆盖。另外，使用类别LC_ALL，LC_MONETARY或LC_NUMERIC来调用setlocale函数可能会覆盖该结构体的内容。

修改setlocale()返回的字符串或者localeconv()返回的结构体是未定义的行为。（参见undefined behaviors 120和121。）此外，C语言标准没有对setlocale()返回的字符串内容做出任何要求。所以，无法对该字符串的内部内容或结构做任何假定。

最后，7.24.6.2小节，段落4[ISO/IEC 9899:2011]声明：
>strerror函数返回一个指向字符串的指针，字符串的内容与特定的区域设置有关。程序不能修改所指向的字符串内容，但可能会被后续的strerror函数调用所覆盖。

修改strerror返回的字符串是未定义行为(参见undefined behavior 184。)

#### 11.1.1 不合规的代码示例(getenv())
此不合规的代码示例修改了getenv()所返回的字符串内容，将所有的双引号(")替换成下划线(_)：

```
#include <stdlib.h>

void trstr(char *c_str, char orig, char rep) {
    while (*c_str != '\0') {
        if (*c_str == orig) {
            *c_str = rep;
        }
        ++c_str;
    }
}
                  
void func(void) {
    char *env = getenv("TEST_ENV");
    if (env == NULL) {
        /* Handle error */
    }
    trstr(env,'"', '_');
}
```

#### 11.1.2 合规的解决方案（getenv()）（未修改环境变量的值）
如果程序员不打算修改环境变量的值，此合规的解决方案演示了如何对返回值的一份拷贝进行修改：
```
#include <stdlib.h>
#include <string.h>
void trstr(char *c_str, char orig, char rep) {
    while (*c_str != '\0') {
        if (*c_str == orig) {
            *c_str = rep;
        }
        ++c_str;
    }
}

void func(void) {
    const char *env;
    char *copy_of_env;
    env = getenv("TEST_ENV");
    if (env == NULL) {
        /* Handle error */
    }
    copy_of_env = (char *)malloc(strlen(env) + 1);
    if (copy_of_env == NULL) {
        /* Handle error */
    }
    strcpy(copy_of_env, env);
    trstr(copy_of_env,'"', '_');
    /* ... */
    free(copy_of_env);
}
```

#### 11.1.3 合规的解决方案（getenv()）（使用POSIX接口修改环境变量的值）
如果程序员的意图就是修改环境变脸的值，可以采用此合规的解决方案，它使用POSIX的setenv()和strdup()函数将修改后的字符串存回到环境变量中：
```
#include <stdlib.h>
#include <string.h>
void trstr(char *c_str, char orig, char rep) {
    while (*c_str != '\0') {
        if (*c_str == orig) {
            *c_str = rep;
        }
        ++c_str;
    }
}

void func(void) {
    const char *env;
    char *copy_of_env;

    env = getenv("TEST_ENV");
    if (env == NULL) {
        /* Handle error */
    }

    copy_of_env = strdup(env);
    if (copy_of_env == NULL) {
        /* Handle error */
    }

    trstr(copy_of_env,'"', '_');

    if (setenv("TEST_ENV", copy_of_env, 1) != 0) {
        /* Handle error */
    }

    /* ... */
    free(copy_of_env);
}
```

#### 11.1.4 不合规的代码示例（localconv()）
在此不合规的代码示例中，直接修改了localeconv()返回的对象：
```
#include <locale.h>

void f2(void) {
    struct lconv *conv = localeconv();

    if ('\0' == conv->decimal_point[0]) {
        conv->decimal_point = ".";
    }
}
```

#### 11.1.5 合规的解决方案（localeconv()）（拷贝）
此合规的解决方案修改了localeconv()返回的对象的一份拷贝：
```
#include <locale.h>
#include <stdlib.h>
#include <string.h>

void f2(void) {
    const struct lconv *conv = localeconv();
    if (conv == NULL) {
        /* Handle error */
    }

    struct lconv *copy_of_conv = (struct lconv *)malloc(
        sizeof(struct lconv));
    if (copy_of_conv == NULL) {
        /* Handle error */
    }

    memcpy(copy_of_conv, conv, sizeof(struct lconv));

    if ('\0' == copy_of_conv->decimal_point[0]) {
        copy_of_conv->decimal_point = ".";
    }
    /* ... */
    free(copy_of_conv);
}
```

#### 11.1.6 风险评估



### 11.2 ENV31-C.在执行了某个可能导致环境变量指针无效的操作之后就不要再依赖于该指针
有些实现提供了一个不可移植的环境变量指针，该指针在调用main()时有效，但是可能会因为修改环境变量的操作而导致无效。

C语言标准J.5.1小节[ISO/IEC 9899:2011]规定：
>在托管环境中，main函数接受第三个参数，char *envp[]，指向一个以null终止的字符指针数组，其中的每个指针指向一个字符串，该字符串提供了用于程序本次执行的环境变量的相关信息。

因此，在支持此常见扩展的托管环境下，有可能通过此改良形式的main()来访问环境变量：
```
main(int argc, char *argv[], char *envp[]){ /* ... */ }
```
然而，通过任何手段修改环境变量都可能会导致重新分配存放环境变量值的内存，致使envp引用了错误的位置。例如，如果使用GCC 4.8.1编译并运行于32位GNU/Linux机器上，下面的代码，
```
#include <stdio.h>
#include <stdlib.h>

extern char **environ;

int main(int argc, const char *argv[], const char *envp[]) {
    printf("environ: %p\n", environ);
    printf("envp:    %p\n", envp);
    setenv("MY_NEW_VAR", "new_value", 1);
    puts("--Added MY_NEW_VAR--");
    printf("environ: %p\n", environ);
    printf("envp:    %p\n", envp);
    return 0;
}
```
输出结果如下：
```
% ./envp-environ
environ: 0xbf8656ec
envp:    0xbf8656ec
--Added MY_NEW_VAR--
environ: 0x804a008
envp:    0xbf8656ec
```
从这些结果很明显的看出，由于调用了setenv()，环境变量的存储位置被重新分配了。外部变量environ被更新以引用到当前的环境变量，而envp参数则没有更新。

指向环境变量的指针也可能会由于后续的getenv()调用而失效。（参见ENV34-C.Do not store pointers returned by certain functions。）

#### 11.2.1 不合规的代码示例（POSIX）
在调用POSIX setenv()函数或者其他的修改环境变量的函数之后，envp指针就有可能不再指向当前的环境变量了。《Portable Operating System Interface(POSIX), Base Specifications Issue 7>>[IEEE Std 1003.1:2013]中规定：
>如果setenv()修改了外部变量environ，会导致不可预期的结果。特别是，如果main()的可选参数envp存在，该参数不会被修改，所以可能会指向环境变量的一个过时的拷贝（因为environ可能会存在其他的拷贝）。

此不合格的代码示例在调用了setenv()之后访问了envp指针：
```
#include <stdio.h>
#include <stdlib.h>

int main(int argc, const char *argv[], const char *envp[]) {
    if (setenv("MY_NEW_VAR", "new_value", 1) != 0) {
        /* Handle error */
    }
    if (envp != NULL) {
        for (size_t i = 0; envp[i] != NULL; ++i) {
            puts(envp[i]);
        }
    }
    return 0;
}
```

因为envp可能不再指向当前的环境变量，该程序具有未定义的行为。

#### 11.2.2 合规的解决方案（POSIX）
如果定义了environ，则使用environ来替换envp：
```
#include <stdio.h>
#include <stdlib.h>

extern char **environ;

int main(void) {
    if (setenv("MY_NEW_VAR", "new_value", 1) != 0) {
        /* Handle error */
    }

    if (environ != NULL) {
        for (size_t i = 0; environ[i] != NULL; ++i) {
            puts(environ[i]);
        }
    }

    return 0;
}
```

#### 11.2.3 不合规的代码示例（Windows）
在调用Windows的_putenv_s()函数或者其他的修改环境变量的函数之后，envp指针就可能不再指向环境变量。
根据Visual C++参考资料[MSDN]：
>传递到main和wmain的环境变量块是当前环境变量的一份“冻结的”拷贝。如果你后续通过调用_putenv或者_wputenv来修改环境变量，当前的环境变量（由getenv/_wgetenv函数返回的值以及_environ/_wenviron变量的值）会发生改变，但是envp指向的内存块的内容则不会发生变化。

此不合规的代码示例在调用_putenv_s()之后访问envp指针：
```
#include <stdio.h>
#include <stdlib.h>

int main(int argc, const char *argv[], const char *envp[]) {
    if (_putenv_s("MY_NEW_VAR", "new_value") != 0) {
        /* Handle error */
    }

    if (envp != NULL) {
        for (size_t i = 0; envp[i] != NULL; ++i) {
            puts(envp[i]);
        }
    }

    return 0;
}
```

因为envp不再指向当前的环境变量，该程序具有未定义的行为。

#### 11.2.4 合规的解决方案（Windows）
此合规的解决方案使用_environ变量来代替envp：
```
#include <stdio.h>
#include <stdlib.h>

_CRTIMP extern char **_environ;

int main(int argc, const char *argv[]) {
    if (_putenv_s("MY_NEW_VAR", "new_value") != 0) {
        /* Handle error */
    }

    if (_environ != NULL) {
        for (size_t i = 0; _environ[i] != NULL; ++i) {
            puts(_environ[i]);
        }
    }

    return 0;
}
```

#### 11.2.5 合规的解决方案
在存在大量的不合规的envp代码时，本合规的解决方案可以减少补救所需的时间。它将
```
int main(int argc, char *argv[], char *envp[]) {
    /* ... */
}
```
替换为
```
#if defined (_POSIX_) || defined (__USE_POSIX)
    extern char **environ;
    #define envp environ
#elif defined(_WIN32)
    _CRTIMP extern char **_environ;
    #define envp _environ
#endif

int main(int argc, char *argv[]) {
    /* ... */
}
```

此合规的解决方案可能需要进行扩展，以支持其他形式的外部变量environ的实现。

#### 11.2.6 风险评估


### 11.3 所有的退出处理程序必须正常返回
C语言标准提供了3个导致应用程序正常终止的函数：_Exit()，exit()，以及quick_exit()。这些函数统称为退出函数。在调用exit()函数，或者控制流程转移到main()入口点函数之外时，会调用由atexit()（而不是at_quick_exit()）所注册的函数。在调用quick_exit()函数时，会调用由at_quick_exit()（而不是atexit)所注册的函数。这些函数统称为退出处理程序。在调用_Exit()函数时，不会调用退出处理程序或者信号处理程序。
退出处理程序必须通过返回来进行终止。对于所有的退出处理程序来说，能够执行他们的清理操作，是很重要的，同时在潜在的安全性方面也是非常关键的。而由于应用程序开发人员并不总是了解由支持库所安装的处理程序，这一点就变得尤其重要了。这方面有两个特定的问题，包括嵌套调用退出函数，和通过调用longjmp来终止退出处理程序的调用。
嵌套调用退出处理函数是未定义的行为。（参见undefined behavior 182。）这种行为只可能发生在从退出处理程序中调用退出函数，或者在信号处理程序中调用退出函数。（参见SIG30-C. Call only asynchronous-safe functions within signal handlers。）
如果longjmp()函数的调用，将会终止由atexit()注册的函数的调用，则该行为是未定义的。

#### 11.3.1 不合规的代码示例
在该不合规的代码示例中，通过atexit()注册了exit1()和exit2()函数，以在程序终止时执行所需的清理操作。然而，如果some_condition运算的结果为真，exit()会被二次调用，产生未定义的行为。

```
#include <stdlib.h>

void exit1(void) {
    /* ... Cleanup code ... */
    return;
}

void exit2(void) {
    extern int some_condition;
    if (some_condition) {
        /* ... More cleanup code ... */
        exit(0);
    }
    return;
}

int main(void) {
    if (atexit(exit1) != 0) {
        /* Handle error */
    }
    if (atexit(exit2) != 0) {
        /* Handle error */
    }
    /* ... Program code ... */
    return 0;
}
```
通过atexit()函数注册的函数，会以注册时的顺序相反的次序进行调用。因此，如果exit2()通过除返回之外的任何方式退出，exit1()就不会被执行。由支持库安装的atexit()处理程序同样如此。

#### 11.3.2 合规的解决方案
通过atexit()注册为退出处理程序的函数必须以返回的方式退出，如下面的合规解决方案：
```
#include <stdlib.h>

void exit1(void) {
    /* ... Cleanup code ... */
    return;
}

void exit2(void) {
    extern int some_condition;
    if (some_condition) {
        /* ... More cleanup code ... */
    }
    return;
}

int main(void) {
    if (atexit(exit1) != 0) {
        /* Handle error */
    }
    if (atexit(exit2) != 0) {
        /* Handle error */
    }
    /* ... Program code ... */
    return 0;
}
```

#### 11.3.3 不合规的代码示例
在该不合规的代码示例中，通过atexit()注册了exit1()，所以在程序终止时会调用exit1()。而exit1()函数跳转回到main()来返回，产生了未定义的结果。
```
#include <stdlib.h>
#include <setjmp.h>

jmp_buf env;
int val;

void exit1(void) {
    longjmp(env, 1);
}

int main(void) {
    if (atexit(exit1) != 0) {
        /* Handle error */
    }
    if (setjmp(env) == 0) {
        exit(0);
    } else {
        return 0;
    }
}
```

#### 11.3.4 合规的解决方案
本合规的解决方案没有调用longjmp()，而是从退出处理程序中正常返回：
```
#include <stdlib.h>

void exit1(void) {
    return;
}

int main(void) {
    if (atexit(exit1) != 0) {
        /* Handle error */
    }
    return 0;
}
```

#### 11.3.5 风险评估


### 11.4 不要调用system()
C语言标准system()函数通过调用实现定义的命令处理器来执行一个指定的命令，例如UNIX的shell，或者Microsoft Windows下的CMD.EXE。POSIX的popen()和Windows的_popen()函数同样调用命令处理器，但是会在调用程序和被执行的命令之间创建一个管道，并返回一个指向流的指针，该指针可用于从管道中读取数据或者向管道写入数据[IEEE Std 1003.1:2013]。

使用system()函数可能会导致可被利用的漏洞，最坏的情况是允许执行任意的系统命令。
调用system()具有高风险的场景如下：
* 传递的命令字符串来自于受污染的源，而该字符串没有经过合法性检查或者检查不当
* 命令没有指定路径名称，而攻击者可以访问命令处理器路径名称解析机制
* 指定了可执行程序的相对路径，而攻击者有当前工作目录的控制权限
* 攻击者可以伪造指定的可执行程序

不要通过system()或其他类似的函数来调用命令处理器执行命令。

#### 11.4.1 不合规的代码示例
在此不合规的代码示例中，使用了system()函数在主机环境中执行any_cmd。调用命令处理器不是必需的。
```
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

enum { BUFFERSIZE = 512 };

void func(const char *input) {
    char cmdbuf[BUFFERSIZE];
    int len_wanted = snprintf(cmdbuf, BUFFERSIZE,
                              "any_cmd '%s'", input);
    if (len_wanted >= BUFFERSIZE) {
        /* Handle error */
    } else if (len_wanted < 0) {
        /* Handle error */
    } else if (system(cmdbuf) == -1) {
        /* Handle error */
    }
}
```

如果此段代码在Linux系统上编译，并以提升后的权限进行运行，则攻击者可以通过输入下面的字符串来创建一个账户：
```
happy'; useradd 'attacker
```
shell会将上面的字符串解释为两条单独的命令：
```
any_cmd 'happy';
useradd 'attacker'
```
并创建一个新的用户账户，攻击者可以使用此账户来访问被入侵的系统。
此不合规的代码示例同时也违背了 STR02-C. Sanitize data passed to complex subsystems。

#### 11.4.2 合规的解决方案（POSIX)
在此合规的解决方案中，用execve()调用来替换system()调用。exec函数系列不使用完整的shell解释器，所以不容易遭受命令行注入攻击，诸如不合规的代码示例中所展示的情况。<br>
如果指定的文件名称不包含正斜杠字符（/），execlp()，execvp()，以及（非标准的）execvP()函数会按照与shell完全相同的操作方式来搜索可行性文件。因此，正如in ENV03-C. Sanitize the environment when invoking external programs中所描述，只有在PATH环境变量被设置为一个安全的值时，它们才能在没有正斜杠字符（/）的情况下使用。<br>
execl()，execle()，execv()，以及execve()函数不会执行路径名称替换操作。<br>
此外，需要小心的是，确保外部可执行程序不会被非信任用户修改，比如说，确保可执行程序对于此用户来说没有写入权限。

```
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>

void func(char *input) {
    pid_t pid;
    int status;
    pid_t ret;
    char *const args[3] = {"any_exe", input, NULL};
    char **env;

    extern char **environ;

    /* ... Sanitize arguments ... */
    pid = fork();
    if (pid == -1) {
        /* Handle error */
    } else if (pid != 0) {
        while ((ret = waitpid(pid, &status, 0)) == -1) {
            if (errno != EINTR) {
                /* Handle error */
                break;
            }
        }
        if ((ret != -1) &&
            (!WIFEXITED(status) || !WEXITSTATUS(status)) ) {
                /* Report unexpected child status */
        }
    } else {
        /* ... Initialize env as a sanitized copy of environ ... */
        if (execve("/usr/bin/any_cmd", args, env) == -1) {
            /* Handle error */
            _Exit(127);
        }
    }
}
```
此合规的解决方案明显不同于前面的不合规代码示例。首先，input被合并到args数组中并作为一个参数传递给execve()，就不需要考虑在格式化命令字符串时遇到的缓冲区溢出或者字符串截断的问题了。其次，该合规解决方案先创建了一个新的进程，然后在子进程中执行"/usr/bin/any_cmd"。尽管这种方法比调用system()要复杂很多，但为了获得加强的安全性，付出的这些额外的工作是值得的。<br>
在未找到命令时，shell会将退出状态的值设置为127，并且POSIX建议应用程序也应该采用同样的做法。XCU, Section 2.8.2, of Standard for Information
Technology—Portable Operating System Interface (POSIX®), Base Specifications, Issue 7 [IEEE
Std 1003.1:2013],指出
>如果命令没有找到，退出状态应该为127。如果命令名称找到了，但不是一个可执行的实用程序，退出状态应该为126。使用shell来调用实用程序的应用程序应该使用这些退出状态值来报告类似的错误。

#### 11.4.3 合规的解决方案（Windows）
本合规的解决方案采用Microsoft Windows的CreateProcess() API:
```
#include <Windows.h>

void func(TCHAR *input) {
    STARTUPINFO si = { 0 };
    PROCESS_INFORMATION pi;

    si.cb = sizeof(si);
    if (!CreateProcess(TEXT("any_cmd.exe"), input, NULL, NULL, FALSE,
                       0, 0, 0, &si, &pi)) {
        /* Handle error */
    }

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
}
```
此合规的解决方案依赖于input参数为非const值。如果input为const，该解决方案就需要创建此参数的一个拷贝，因为CreateProcess()函数可能会修改传递给新创建进程的命令行参数。<br>
本解决方案创建的进程，子进程不会继承父进程的任何句柄，遵循 WIN03-C. Understand HANDLE inheritance。

#### 11.4.4 不合规的代码示例（POSIX）
此不合规的代码调用C语言system()函数来删除用户主文件夹中的.config文件。
```
#include <stdlib.h>

void func(void) {
    system("rm ~/.config");
}
```
如果此易受攻击的程序具有提升的执行权限，则攻击者就可以通过操纵HOME环境变量的值来删除系统中任何位置的任何一个名为.config的文件。

#### 11.4.5 合规的解决方案（POSIX）
调用system()来执行外部程序进行必须的操作的一种替代方式是，使用现有的库接口调用在程序中直接实现其功能。此合规的解决方案调用POSIX unlink()函数删除一个文件，没有调用system()函数[IEEE Std 1003.1:2013]：
```
#include <pwd.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

void func(void) {
    const char *file_format = "%s/.config";
    size_t len;
    char *pathname;
    struct passwd *pwd;

    /* Get /etc/passwd entry for current user */
    pwd = getpwuid(getuid());
    if (pwd == NULL) {
        /* Handle error */
    }

    /* Build full path name home dir from pw entry */

    len = strlen(pwd->pw_dir) + strlen(file_format) + 1;
    pathname = (char *)malloc(len);
    if (NULL == pathname) {
        /* Handle error */
    }
    int r = snprintf(pathname, len, file_format, pwd->pw_dir);
    if (r < 0 || r >= len) {
        /* Handle error */
    }
    if (unlink(pathname) != 0) {
        /* Handle error */
    }

    free(pathname);
}
```
在pathname(文件名称)的最后一部分为符号链接的情况下，unlink()函数也不容易遭受到符号链接攻击，因为unlink()会删除符号链接，同时不会影响任何以符号链接内容命名的文件或者目录。（参见 FIO01-C. Be careful using functions that use file names for identification。）虽然unlink()函数降低了受攻击的可能性，但无法完全避免。如果包含在pathname中的一个目录名称为符号链接，unlink()函数仍然可能遭受到攻击。这种情况可能会导致unlink()函数删除另外一个文件夹中的同名文件。

#### 11.4.6 合规的解决方案（Windows）
此合规的解决方案采用Microsoft Windows的 SHGetKnownFolderPath() API来获取当前用户的“我的文档”文件夹，然后将其与文件名组合以产生待删除文件的路径。然后使用DeleteFile() API来删除该文件。
```
#include <Windows.h>
#include <ShlObj.h>
#include <Shlwapi.h>

#if defined(_MSC_VER)
#pragma comment(lib, "Shlwapi")
#endif

void func(void) {
    HRESULT hr;
    LPWSTR path = 0;
    WCHAR full_path[MAX_PATH];

    hr = SHGetKnownFolderPath(&FOLDERID_Documents, 0, NULL, &path);
    if (FAILED(hr)) {
        /* Handle error */
    }
    if (!PathCombineW(full_path, path, L".config")) {
        /* Handle error */
    }
    CoTaskMemFree(path);
    if (!DeleteFileW(full_path)) {
        /* Handle error */
    }
}
```

#### 11.4.7 例外情况
ENV33-C-EX1：允许使用一个空指针参数来调用system()以判断用于该系统的命令处理程序是否存在。

#### 11.4.8 风险评估


### 11.5 ENV34-C. 不要保存某些函数返回的指针
C语言标准，7.22.4.6小节，第4段 [ISO/IEC 9899:2011]规定：
>getenv函数返回一个指向字符串的指针，该字符串与匹配的列表成员相关。程序不要修改所指向的字符串，该字符串可能会被后续的getenv函数调用所覆盖。

此段规定给具体实现提供了余地，比如说，可以返回一个指向静态分配的缓冲区的指针。因此，不要保存此指针，因为它指向的字符串数据可能会被下一次调用getenv()函数所覆盖，或者会由于修改了环境变量而失效。该字符串应该立即引用然后丢弃。如果预料到后面还会使用到该字符串，应该就其拷贝下来，使得在需要的时候可以安全的应用该拷贝。<br>
getenv()函数不是线程安全的。务必处理好使用此函数所带来的任何竞争条件。<br>
asctime()，localconv()，setlocale()，以及strerror()函数具有类似的限制。在后续的调用之后，就不要再访问前一次调用所返回的对象了。

#### 11.5.1 不合规的代码示例
此不合规的代码示例试图比较TMP和TEMP环境变量的值是否相同：
```
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

void func(void) {
    char *tmpvar;
    char *tempvar;
    tmpvar = getenv("TMP");
    if (!tmpvar) {
        /* Handle error */
    }
    tempvar = getenv("TEMP");
    if (!tempvar) {
        /* Handle error */
    }
    if (strcmp(tmpvar, tempvar) == 0) {
        printf("TMP and TEMP are the same.\n");
    } else {
        printf("TMP and TEMP are NOT the same.\n");
    }
}
```
此代码示例不合规是因为tmpvar所引用的字符串可能会被覆盖为第二次调用getenv()函数所得到的结果。因此，即使这两个环境变量的值不同，但tmpvar和tempvar比较得到的结果仍然可能是相等的。<br>

#### 11.5.2 合规的解决方案
此合规的解决方案使用malloc()和strcpy()函数将getenv()返回的字符串拷贝到一个动态分配的缓冲区中：
```
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

void func(void) {
    char *tmpvar;
    char *tempvar;

    const char *temp = getenv("TMP");
    if (temp != NULL) {
        tmpvar = (char *)malloc(strlen(temp)+1);
        if (tmpvar != NULL) {
            strcpy(tmpvar, temp);
        } else {
            /* Handle error */
        }
    } else {
        /* Handle error */
    }

    temp = getenv("TEMP");
    if (temp != NULL) {
        tempvar = (char *)malloc(strlen(temp)+1);
        if (tempvar != NULL) {
            strcpy(tempvar, temp);
        } else {
            /* Handle error */
        }
    } else {
        /* Handle error */
    }

    if (strcmp(tmpvar, tempvar) == 0) {
        printf("TMP and TEMP are the same.\n");
    } else {
        printf("TMP and TEMP are NOT the same.\n");
    }

    free(tmpvar);
    free(tempvar);
}
```

#### 11.5.3 合规的解决方案（Annex K）
C语言标准，Annex K，提供了getenv_s()函数用于从当前的环境中获取一个值。然而，getenv_s()函数仍然可能会与修改环境变量列表的其他线程执行存在着数据竞争。
```
#define __STDC_WANT_LIB_EXT1__ 1
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

void func(void) {
    char *tmpvar;
    char *tempvar;
    size_t requiredSize;
    errno_t err;

    err = getenv_s(&requiredSize, NULL, 0, "TMP");
    if (err) {
        /* Handle error */
    }
    tmpvar = (char *)malloc(requiredSize);
    if (!tmpvar) {
        /* Handle error */
    }

    err = getenv_s(&requiredSize, tmpvar, requiredSize, "TMP" );
    if (err) {
        /* Handle error */
    }

    err = getenv_s(&requiredSize, NULL, 0, "TEMP");
    if (err) {
        /* Handle error */
    }
    tempvar = (char *)malloc(requiredSize);
    if (!tempvar) {
        /* Handle error */
    }
    err = getenv_s(&requiredSize, tempvar, requiredSize, "TEMP" );
    if (err) {
        /* Handle error */
    }

    if (strcmp(tmpvar, tempvar) == 0) {
        printf("TMP and TEMP are the same.\n");
    } else {
        printf("TMP and TEMP are NOT the same.\n");
    }

    free(tmpvar);
    tmpvar = NULL;
    free(tempvar);
    tempvar = NULL;
}
```

#### 11.5.4 合规的解决方案（Windows）
Microsoft Windows提供了_dupenv_s()和wdupenv_s()函数用于从当前的环境变量中获取某一个值【MSDN】。_dupenv_s()函数用指定的环境变量名称查找环境变量列表。如果找到了该名称，则分配一个缓冲区，将变量的值拷贝到缓冲区中，然后将缓冲区的地址和元素的个数返回。_dupenv_s()和_wdupenv_s()函数为getenv_s()和_wgetenv_s()提供了更加方便的替代手段，因为他们直接处理了缓冲区的分配。<br>
调用者负责调用free()，来释放由这些函数所返回的任何已分配缓冲区。
```
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>

void func(void) {
    char *tmpvar;
    char *tempvar;
    size_t len;

    errno_t err = _dupenv_s(&tmpvar, &len, "TMP");
    if (err) {
        /* Handle error */
    }

    err = _dupenv_s(&tempvar, &len, "TEMP");
    if (err) {
        /* Handle error */
    }

    if (strcmp(tmpvar, tempvar) == 0) {
        printf("TMP and TEMP are the same.\n");
    } else {
        printf("TMP and TEMP are NOT the same.\n");
    }

    free(tmpvar);
    tmpvar = NULL;
    free(tempvar);
    tempvar = NULL;
}
```

#### 11.5.5 合规的解决方案（POSIX）
POSIX提供了strdup()函数，该函数可以创建环境变量字符串的一份拷贝 [IEEE Std 1003.1:2013]。《Extensions to the C Library—Part II 》 [ISO/IEC TR 24731-2:2010]中也同样包含了strdup()函数。
```
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

void func(void) {
    char *tmpvar;
    char *tempvar;

    const char *temp = getenv("TMP");
    if (temp != NULL) {
        tmpvar = strdup(temp);
        if (tmpvar == NULL) {
            /* Handle error */
        }
    } else {
        /* Handle error */
    }

    temp = getenv("TEMP");
    if (temp != NULL) {
        tempvar = strdup(temp);
        if (tempvar == NULL) {
            /* Handle error */
        }
    } else {
        /* Handle error */
    }

    if (strcmp(tmpvar, tempvar) == 0) {
        printf("TMP and TEMP are the same.\n");
    } else {
        printf("TMP and TEMP are NOT the same.\n");
    }

    free(tmpvar);
    tmpvar = NULL;
    free(tempvar);
    tempvar = NULL;
}
```

#### 11.5.6 风险评估
保存getenv()，loacalenv()，setlocale()，或strerror()返回的字符串指针可能会导致数据被覆盖。

|规则|严重性|可能性|修补成本|优先级|级别|
|---|---|---|---|---|---|
|ENV34-C|低|可能|中|P4|L3|

## 12 信号 (SIG)
### 12.1 SIG30-C 在信号处理程序中仅调用异步安全函数
在信号处理程序中仅调用异步安全函数。对于严格限制的程序，只有C标准库函数的abort()，_Exit()，quick_exit()和signal()可以安全地在信号处理程序中被调用。 
在C标准的7.14.1.1的第5段[ ISO/IEC 9899:2011 ]指出，如果不是因为调用 abort() 或  raise() 函数而产生信号，该行为是 不确定的，如果
> ...信号处理程序调用标准库中除 abort函数， _Exit函数，quick_exit函数或signal函数的第一个参数等于信号对应的数值时，都会触发信号处理函数。

实施过程中，可以定义一系列额外的异步安全函数。这些函数也可以在信号处理程序内被调用。此限制适用于库函数以及应用函数。
根据C Rationale的7.14.1.1 [ C99 Rationale 2003 ]
> 当信号发生时，程序的正常控制流程中断。如果信号处理程序对应的信号发生时，会触发该信号处理程序。当它执行完成时，程序在信号发生时的地方继续执行。如果在信号发生时，一个库函数正在被执行，而信号处理函数运行时会触发这个库函数，这种设计会导致问题。

一般来说，从信号处理程序中调用I / O函数是不安全的。程序员需要确保在信号处理函数中使用的函数是所有执行代码中是异步安全的。
#### 12.1.1 不合规代码示例
在这个不合规的例子中，信号处理程序通过函数log_message()调用C标准库函数fprintf()和free()。这两个函数都不是异步安全的。
```c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
 
enum { MAXLINE = 1024 };
char *info = NULL;
 
void log_message(void) {
  fputs(info, stderr);
}
 
void handler(int signum) {
  log_message();
  free(info);
  info = NULL;
}
 
int main(void) {
  if (signal(SIGINT, handler) == SIG_ERR) {
    /* Handle error */
  }
  info = (char *)malloc(MAXLINE);
  if (info == NULL) {
    /* Handle Error */
  }
 
  while (1) {
    /* Main loop program code */
 
    log_message();
 
    /* More program code */
  }
  return 0;
}
```
#### 12.1.2 合规方案
信号处理程序应尽可能简洁，比较理想的是标志设置采用无条件判断并返回。此合规方案中，给volatile sig_atomic_t类型变量设置标志位并返回; main函数再调用log_message()和free()函数：
```c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
 
enum { MAXLINE = 1024 };
volatile sig_atomic_t eflag = 0;
char *info = NULL;
 
void log_message(void) {
  fputs(info, stderr);
}
 
void handler(int signum) {
  eflag = 1;
}
 
int main(void) {
  if (signal(SIGINT, handler) == SIG_ERR) {
    /* Handle error */
  }
  info = (char *)malloc(MAXLINE);
  if (info == NULL) {
    /* Handle error */
  }
 
  while (!eflag) {
    /* Main loop program code */
 
    log_message();
 
    /* More program code */
  }
 
  log_message();
  free(info);
  info = NULL;
 
  return 0;
}
```
#### 12.1.3 不合规代码示例（longjmp()）
如果信号处理程序是在非异步安全 函数内被调用，那么在信号处理函数内部调用 longjmp() 函数可能导致未定义的行为。因此，不应该在信号处理程序内调用longjmp()或POSIX  siglongjmp()函数。
这不合规代码示例类似于一个在老版本Sendmail [VU＃834865 ] 中的漏洞 。它打算在main() 循环中执行代码，并记录一些数据。一旦接收到  SIGINT，程序跳出循环，记录错误，并终止。
然而，攻击者可以利用这个不合规代码，他在log_message()的第二个if语句前面产生一个SIGINT信号  。结果是longjmp() 切换程序返回main()，log_message()再次被调用时。但是，第一个if 语句在这次将不会被执行（因为中断的原因，buf 没有被设置为NULL），程序将写入buf0引用的无效内存空间中。
```c
#include <setjmp.h>
#include <signal.h>
#include <stdlib.h>
 
enum { MAXLINE = 1024 };
static jmp_buf env;
 
void handler(int signum) {
  longjmp(env, 1);
}
 
void log_message(char *info1, char *info2) {
  static char *buf = NULL;
  static size_t bufsize;
  char buf0[MAXLINE];
 
  if (buf == NULL) {
    buf = buf0;
    bufsize = sizeof(buf0);
  }
 
  /*
   * Try to fit a message into buf, else reallocate
   * it on the heap and then log the message.
   */
 
  /* Program is vulnerable if SIGINT is raised here */
 
  if (buf == buf0) {
    buf = NULL;
  }
}
 
int main(void) {
  if (signal(SIGINT, handler) == SIG_ERR) {
    /* Handle error */
  }
  char *info1;
  char *info2;
 
  /* info1 and info2 are set by user input here */
 
  if (setjmp(env) == 0) {
    while (1) {
      /* Main loop program code */
      log_message(info1, info2);
      /* More program code */
    }
  } else {
    log_message(info1, info2);
  }
 
  return 0;
}
```
#### 12.1.4 合规方案
在此合规方案中，longjmp()调用被移除; 取而代之的是，信号处理程序设置一个错误标志：
```c
#include <signal.h>
#include <stdlib.h>
 
enum { MAXLINE = 1024 };
volatile sig_atomic_t eflag = 0;
 
void handler(int signum) {
  eflag = 1;
}
 
void log_message(char *info1, char *info2) {
  static char *buf = NULL;
  static size_t bufsize;
  char buf0[MAXLINE];
 
  if (buf == NULL) {
    buf = buf0;
    bufsize = sizeof(buf0);
  }
 
  /*
   * Try to fit a message into buf, else reallocate
   * it on the heap and then log the message.
   */
  if (buf == buf0) {
    buf = NULL;
  }
}
 
int main(void) {
  if (signal(SIGINT, handler) == SIG_ERR) {
    /* Handle error */
  }
  char *info1;
  char *info2;
 
  /* info1 and info2 are set by user input here */
 
  while (!eflag) {
    /* Main loop program code */
    log_message(info1, info2);
    /* More program code */
  }
 
  log_message(info1, info2);
 
  return 0;
}
```
#### 12.1.5 不合规代码示例（raise()）
在这个不合规的代码示例中，int_handler() 函数用于执行和SIGINT相关的任务，然后触发SIGTERM。但是，在信号处理函数中调用raise() 函数，这是一个未定义的行为。
```c
#include <signal.h>
#include <stdlib.h>
 
void term_handler(int signum) {
  /* SIGTERM handler */
}
  
void int_handler(int signum) {
  /* SIGINT handler */
  if (raise(SIGTERM) != 0) {
    /* Handle error */
  }
}
  
int main(void) {
  if (signal(SIGTERM, term_handler) == SIG_ERR) {
    /* Handle error */
  }
  if (signal(SIGINT, int_handler) == SIG_ERR) {
    /* Handle error */
  }
  
  /* Program code */
  if (raise(SIGINT) != 0) {
    /* Handle error */
  }
  /* More code */
  
  return EXIT_SUCCESS;
}
```
#### 12.1.6 合规方案
在这个合规方案中，  int_handler()直接调用term_handler()而不是触发SIGTERM：
```c
#include <signal.h>
#include <stdlib.h>
  
void term_handler(int signum) {
  /* SIGTERM handler */
}
  
void int_handler(int signum) {
  /* SIGINT handler */
  /* Pass control to the SIGTERM handler */
  term_handler(SIGTERM);
}
  
int main(void) {
  if (signal(SIGTERM, term_handler) == SIG_ERR) {
    /* Handle error */
  }
  if (signal(SIGINT, int_handler) == SIG_ERR) {
    /* Handle error */
  }
  
  /* Program code */
  if (raise(SIGINT) != 0) {
    /* Handle error */
  }
  /* More code */
  
  return EXIT_SUCCESS;
}
```

#### 12.1.7 执行细节
##### 12.1.7.1 POSIX
下表来自POSIX标准[IEEE Std 1003.1:2013]，定义了一系列异步信号安全的函数。应用程序可以没有限制的在信号处理函数中触发这些函数。

||||
--|--|--|--
_Exit()|fexecve()|posix_trace_event()|sigprocmask()
_exit()|fork()|pselect()|sigqueue()
abort()|fstat()|pthread_kill()|sigset()
accept()|fstatat()|pthread_self()|sigsuspend()
access()|fsync()|pthread_sigmask()|sleep()
aio_error()|ftruncate()|raise()|sockatmark()
aio_return()|futimens()|read()|socket()
aio_suspend()|getegid()|readlink()|socketpair()
alarm()|geteuid()|readlinkat()|stat()
bind()|getgid()|recv()|symlink()
cfgetispeed()|getgroups()|recvfrom()|symlinkat()
cfgetospeed()|getpeername()|recvmsg()|tcdrain()
cfsetispeed()|getpgrp()|rename()|tcflow()
cfsetospeed()|getpid()|renameat()|tcflush()
chdir()|getppid()|rmdir()|tcgetattr()
chmod()|getsockname()|select()|tcgetpgrp()
chown()|getsockopt()|sem_post()|tcsendbreak()
clock_gettime()|getuid()|send()|tcsetattr()
close()|kill()|sendmsg()|tcsetpgrp()
connect()|link()|sendto()|time()
creat()|linkat()|setgid()|timer_getoverrun()
dup()|listen()|setpgid()|timer_gettime()
dup2()|lseek()|setsid()|timer_settime()
execl()|lstat()|setsockopt()|times()
execle()|mkdir()|setuid()|umask()
execv()|mkdirat()|shutdown()|uname()
execve()|mkfifo()|sigaction()|unlink()
faccessat()|mkfifoat()|sigaddset()|unlinkat()
fchdir()|mknod()|sigdelset()|utime()
fchmod()|mknodat()|sigemptyset()|utimensat()
fchmodat()|open()|sigfillset()|utimes()
fchown()|openat()|sigismember()|wait()
fchownat()|pause()|signal()|waitpid()
fcntl()|pipe()|sigpause()|write()
fdatasync()|poll()|sigpending()

考虑到信号，所有不在上述表格中的函数都可以认为是不安全的。在信号存在的情况下，所有POSIX函数被信号处理函数调用或被中断，都会表现得和定义一样。只有一个例外，当一个信号中断了一个不安全的函数且信号处理函数调用了一个不安全的函数，这个行为是不确定的。
C标准,7.14.1.1第4段[ISO/IEC 9899:2011]陈述到：
> 如果一个信号是因为调用了abort或raise函数而产生的，信号处理函数不应该调用raise函数

然而，在POSIX [IEEE Std 1003.1:2013]的signal函数的描述中写到：
> 这个限制不适用于POSIX应用程序，因为POSIX.1-2008需要raise函数是异步安全的。
同时参考未确定行为131。

#### 12.1.8 风险评估
在信号处理函数中触发一个非异步安全的函数会产生未定义的行为。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| SIG30-C | 高 | 很可能 | 中 | P18 | L1 |

##### 12.1.8.1 相关脆弱性
关于不恰当的信号处理所导致的软件脆弱性的全貌，可以参看Michal
Zalewski的论文《Delivering Signals for Fun and Profit》[Zalewski 2001]
CERT 脆弱性条目 VU #834865，“Sendmail signal I/O race condition,”描述了违反这个条目所导致的脆弱性。另外一个非常有名的在信号处理函数中使用longjmp函数导致的严重脆弱性是wu-ftpd 2.4 [Greenman 1997]。有效用户ID在一个信号处理函数中被设置0。如果第二个信号中断了第一个，调用了longjmp函数，在没有降低用户权限的情况下将程序返回到主线程中。这些被扩大的权限被用于进一步的攻击。

### 12.2 SIG31-C 不要在信号处理程序中访问共享对象
在信号处理程序中访问或修改共享对象可能会导致竞争，使数据处于不一致状态。本规则的两个例外（C标准，5.1.2.3，第5段），读写免锁原子对象和volatile sig_atomic_t类型变量。在信号处理程序中访问任何其他类型的对象是未定义的行为。
在DCL22-C中描述了需要volatile关键字的原因：对无法缓存的数据使用volatile类型。
sig_atomic_t类型是一个整数型对象，即使在异步中断的情况下也可以作为原子实体访问。虽然提供一些保障，但sig_atomic_t类型是由实现定义的。从SIG_ATOMIC_MIN到SIG_ATOMIC_MAX范围内的整数值可以安全地存储到该类型的变量中。此外，如果sig_atomic_t是一个有符号整数类型，SIG_ATOMIC_MIN必须不小于−127且SIG_ATOMIC_MAX不大于127。否则，SIG_ATOMIC_MIN必须为0且SIG_ATOMIC_MAX必须不大于255。在头文件<stdint.h>中定义了宏SIG_ATOMIC_MIN和SIG_ATOMIC_MAX。

#### 12.2.1 不合规代码示例
在此不合规代码示例中，SIGINT信号已被投递通过更新err_msg来记录。该err_msg变量是一个字符指针，而不是volatile sig_atomic_t类型的变量。
```c
#include <signal.h>
#include <stdlib.h>
#include <string.h>
 
enum { MAX_MSG_SIZE = 24 };
char *err_msg;
 
void handler(int signum) {
  strcpy(err_msg, "SIGINT encountered.");
}
 
int main(void) {
  signal(SIGINT, handler);
 
  err_msg = (char *)malloc(MAX_MSG_SIZE);
  if (err_msg == NULL) {
    /* Handle error */
  }
  strcpy(err_msg, "No errors yet.");
  /* Main code loop */
  return 0;
}
```
#### 12.2.2 合规解决方案（写volatile sig_atomic_t）
这合规方案中，为了有最大的可移植性，信号处理程序应该只能做无条件判断地volatile sig_atomic_t类型变量设置并返回。
```c
#include <signal.h>
#include <stdlib.h>
#include <string.h>
 
enum { MAX_MSG_SIZE = 24 };
volatile sig_atomic_t e_flag = 0;
 
void handler(int signum) {
  e_flag = 1;
}
 
int main(void) {
  char *err_msg = (char *)malloc(MAX_MSG_SIZE);
  if (err_msg == NULL) {
    /* Handle error */
  }
 
  signal(SIGINT, handler);
  strcpy(err_msg, "No errors yet.");
  /* Main code loop */
  if (e_flag) {
    strcpy(err_msg, "SIGINT received.");
  }
  return 0;
}
```
#### 12.2.3 合规方案（无锁原子访问）
这合规方案中，信号处理程序可以引用静态或线程存储持续期内的无锁原子对象：
```c
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <stdatomic.h>
 
#ifdef __STDC_NO_ATOMICS__
#error "Atomics are not supported"
#elif ATOMIC_INT_LOCK_FREE == 0
#error "int is never lock-free"
#endif
 
atomic_int e_flag = ATOMIC_VAR_INIT(0);
 
void handler(int signum) {
  e_flag = 1;
}
 
int main(void) {
  enum { MAX_MSG_SIZE = 24 };
  char err_msg[MAX_MSG_SIZE];
#if ATOMIC_INT_LOCK_FREE == 1
  if (!atomic_is_lock_free(&e_flag)) {
    return EXIT_FAILURE;
  }
#endif
  if (signal(SIGINT, handler) == SIG_ERR) {
    return EXIT_FAILURE;
  }
  strcpy(err_msg, "No errors yet.");
  /* Main code loop */
  if (e_flag) {
    strcpy(err_msg, "SIGINT received.");
  }
  return EXIT_SUCCESS;
}
```
#### 12.2.4 例外
SIG31-C-EX1：C标准的7.14.1.1第5段[ ISO / IEC 9899：2011 ]有一个errno的特殊例外，signal()函数调用会返回SIG_ERR信号，这会允许errno取一个不确定值（参见ERR32-C 不要依赖errno的不确定值）

#### 12.2.5 风险评估
在一个信号处理函数中访问或修改共享对象会导致正在访问的数据处于不一致的状态。 Michal Zalewski的论文 “Delivering Signals for Fun and Profit” [Zalewski 2001] 提供了一些因违反该条目和其他信号处理原则的脆弱性例子。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| SIG31-C | 高 | 很可能 | 高 | P9 | L2 |

### 12.3 SIG34-C 不要从可中断的信号处理程序中调用signal()
信号处理程序不应该再次声明自己要处理信号的欲望。再次声明通常在非持久性平台上完成，非持久性平台指的是，在接收到信号后，并在调用信号处理程序之前，将信号的处理程序重置为SIG_DFL 。在这些条件下调用signal()会呈现竞争条件。（参见SIG01-C了解有关信号处理程序持久性的具体实现细节。）
只有当信号处理程序不需要是异步安全的，信号处理程序才可以调用signal()（即，如果所有相关信号都被屏蔽，使得处理程序不能被中断）。
### 12.4 不合规代码示例（POSIX）
在非持久性平台上，此不合规代码示例包含一个竞争窗口，从主机环境复位信号开始，并在处理程序调用signal()时结束。在该期间，发送到程序的第二个信号将触发信号的默认行为，因此无法完成信号和处理函数的再次绑定，从而破坏其持续行为。
如果环境是持久的（即，当接收到信号时不重置处理程序），则在handler()函数内调用signal()是冗余的。
```c
#include <signal.h>
 
void handler(int signum) {
  if (signal(signum, handler) == SIG_ERR) {
    /* Handle error */
  }
  /* Handle signal */
}
 
void func(void) {
  if (signal(SIGUSR1, handler) == SIG_ERR) {
    /* Handle error */
  }
}
```
#### 12.4.1 合规方案（POSIX）
对于持久性平台，从信号处理程序中调用函数signal()来重新绑定是不必要的：
```c
#include <signal.h>
 
void handler(int signum) {
  /* Handle signal */
}
 
void func(void) {
  if (signal(SIGUSR1, handler) == SIG_ERR) {
    /* Handle error */
  }
}
```
#### 12.4.2 合规方案（POSIX）
POSIX定义了sigaction()函数，它以类似signal()的方式为信号分配处理程序，但允许调用者明确地设置持久性。因此，该sigaction()函数可用于消除非持久性平台上的竞争窗口：
```c
#include <signal.h>
#include <stddef.h>
 
void handler(int signum) {
  /* Handle signal */
}
 
void func(void) {
  struct sigaction act;
  act.sa_handler = handler;
  act.sa_flags = 0;
  if (sigemptyset(&act.sa_mask) != 0) {
    /* Handle error */
  }
  if (sigaction(SIGUSR1, &act, NULL) != 0) {
    /* Handle error */
  }
}
```
在这个例子中的处理程序虽然不调用signal()，它之所以可以安全地这样做，是因为信号被屏蔽，处理程序不能被中断。如果为相同的处理程序安装了多个信号，则必须在act.sa_mask中明确得屏蔽这些信号，以确保处理程序不会被中断，因为系统仅屏蔽正在被投递的信号。
POSIX建议新的应用程序使用sigaction()而不是signal()。但该sigaction()函数未被C标准定义，并且在某些平台（包括Windows）上不受支持。
#### 12.4.3 合规方案（Windows）
在Windows平台上没有安全的方式实现持久的信号处理程序行为，因此不应该尝试。如果设计取决于这种行为，并且设计不能改变，则可能有必要在完成适当的风险分析之后声明与该规则的偏离。
其原因是Windows是如上所述的非持久平台。在调用当前处理程序函数之前，Windows将重置等待下个相同信号的处理程序为SIG_DFL。如果处理程序调用signal()以重新安装本身，仍然会有一个竞争窗口。在处理程序的开始和调用signal()之间可能会产生信号，这将调用默认行为，而不是所需的处理程序。
#### 12.4.4 例外
SIG34-C-EX1：对于具有持久信号处理程序的实现，处理程序可以安全地修改其自身信号的行为。行为修改包括忽略信号，重置为默认行为，并使信号由不同的处理程序处理。处理程序重新声明它的绑定也是安全的，但不必要。
以下代码示例将信号处理程序重置为系统的默认行为：
```c
#include <signal.h>
 
void handler(int signum) {
#if !defined(_WIN32)
  if (signal(signum, SIG_DFL) == SIG_ERR) {
    /* Handle error */
  }
#endif
  /* Handle signal */
}
 
void func(void) {
  if (signal(SIGUSR1, handler) == SIG_ERR) {
    /* Handle error */
  }
}
```

#### 12.4.5 风险评估
在非持久性平台上，两个紧密连着的信号会触发一个竞争窗口，会引起信号的默认行为，即使处理函数试图覆盖这个默认行为。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| SIG34-C | 低 | 不太可能 | 低 | P3 | L3 |


### 12.5 SIG35-C 不要从处理计算异常的信号处理程序中返回
根据C标准，7.14.1.1 [ISO/IEC 9899：2011]，因为一个计算异常的原因而执行信号处理程序在返回时（即，其入参值是SIGFPE，SIGILL，SIGSEGV，或者任何对应这样异常的应用定义值），其行为是未定义的。（参见未定义的行为130）
可移植操作系统接口（POSIX）基本规范的第7个问题 [IEEE Std 1003.1：2013]，把SIGBUS加入到计算异常信号处理程序的列表：
> 不是由kill()，sigqueue()或raise()触发的SIGBUS，SIGFPE，SIGILL，或SIGSEGV信号所引起的信号处理函数在正常返回时，进程的行为是未定义的。
无论信号是怎么产生的，都不要从SIGFPE，SIGILL，SIGSEGV，或其他计算异常对应的自定义值（如POSIX系统中的SIGBUS)中返回。

#### 12.5.1 不合规代码示例
在这个不合规的代码示例中，如果denom等于0，除法运算具有未定义的行为，并可能对程序产生SIGFPE信号.（见INT33-C。确保除法和余数运算不会导致除零错误）。
```cpp
#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <stdlib.h>
 
volatile sig_atomic_t denom;
 
void sighandle(int s) {
  /* Fix the offending volatile */
  if (denom == 0) {
    denom = 1;
  }
}
 
int main(int argc, char *argv[]) {
  if (argc < 2) {
    return 0;
  }
 
  char *end = NULL;
  long temp = strtol(argv[1], &end, 10);
 
  if (end == argv[1] || 0 != *end ||
      ((LONG_MIN == temp || LONG_MAX == temp) && errno == ERANGE)) {
    /* Handle error */
  }
 
  denom = (sig_atomic_t)temp;
  signal(SIGFPE, sighandle);
 
  long result = 100 / (long)denom;
  return 0;
}
```

在和一些代码编译后，如果输入0，这个不合规的代码示例将会无限循环。
在遵循所有其他信号处理规则的情况在，即使SIGFPE的处理函数尝试修复错误条件，程序仍然不能如预期那样工作。

#### 12.5.2 合规解决方案
唯一可移植的离开SIGFPE，SIGILL或SIGSEGV处理函数的安全方法，就是触发abort()，quick_exit()，_Exit()。在SIGFPE的例子中，默认行为是异常终止，因此，用户的处理函数是不需要的

```cpp
#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <stdlib.h>
 
int main(int argc, char *argv[]) {
  if (argc < 2) {
    return 0;
  }
 
  char *end = NULL;
  long denom = strtol(argv[1], &end, 10);
 
  if (end == argv[1] || 0 != *end ||
      ((LONG_MIN == denom || LONG_MAX == denom) && errno == ERANGE)) {
    /* Handle error */
  }
 
  long result = 100 / denom;
  return 0;
}
```

##### 12.5.2.1 实现细节
一些实现为程序定义了针对这些信号处理函数退出的有用的行为。Solaris提供了sigfpe函数专门用于程序能从SIGFPE处理函数中安全的返回。Oracle为SIGTRAP，SIGBUS和SIGEMT提供了平台特定的计算异常。最后，GNU的ligsigsegv库利用SIGSEGV处理函数返回的能力，在用户模式下实现了页面级的内存管理。

#### 12.5.3 风险评估
从计算异常信号处理程序中返回是未定义的行为。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| SIG35-C | 低 | 不太可能 | 高 | P1 | L3 |

## 13 错误处理（ERR）

### 13.1 ERR30-C. 调用设置errno的库函数之前将errno设置为0，并且在函数返回一个提示失败的之后才去检查errno

errno的值在程序启动时为0，但是任何库函数都不会在之后将errno设置为0。不管是否出现错误，一个库函数调用时很可能将errno设置为一个非0值，只要errno的用法没有记录在这个C标准函数的描述中。errno的值只对在报告错误之后对errno的内容进行检查的程序中才有意义。更准确而言，errno只有在一个设置errno的库函数返回一个错误代码之后才有意义。

根据C-FAQ的问题20.4 [[Summit 2005](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-Summit05)]：
> 一般而言，应该通过检查返回值检查错误，并且只用errno区分错误的各种起因。例如：“文件未找到”或者“权限被拒绝”（一般情况下可以使用perror或者strerror打印这些不同的错误信息）。只有当一个函数没有唯一的，无歧义的带外返回值（也就是说，由于所有的返回值都是合法的。atoi是一个例子）时，才有必要检查errno。在这些情况下（也只有在这些情况下。应该检查文档，确保函数允许这种做法），可以通过把errno设置为0，再调用这个函数，然后测试errno来检查错误。（首先把errno设置为0是非常重要的，因为没有任何库函数会完成这个任务。）

#### 13.1.1 库函数和errno

库函数可以分为如下几种类型：
- 设置errno并返回一个带外错误指示符的库函数。
- 设置errno并返回一个带内错误指示符的库函数。
- 不保证设置errno的库函数。
- 具有不同标准文档的库函数。

#### 13.1.2 设置errno并返回一个带外错误指示符的库函数
C标准指定下表中所列的函数会设置errno并返回一个带外错误指示符。即：在发生错误时返回的值绝对不会是成功调用时返回的值。
程序在调用这些库函数时可以设置并检查errno，但是并不一定要这样做。程序不应该只检查errno的值，而不首先验证函数所返回的错误指示符。例如：在调用signal()之后，如果不能保证signal()函数实际返回了SIG_ERR，就不应该去检查errno的值。

| 函数名称 | 返回值 | errno |
| -- | -- | -- |
| c16rtomb(), cr32rtomb() | (size_t)(-1) | EILSEQ |
| fgetpos(), fsetpos() | Nonzero | Positive |
| ftell() | -1L | Positive |
| mbrtoc16(), mbrtoc32() | (size_t)(-1) | EILSEQ |
| mbrtowc(), mbsrtowcs() | (size_t)(-1) | EILSEQ |
| signal() | SIG_ERR | Positive |
| wcrtomb(), wcsrtombs() | (size_t)(-1) | EILSEQ |

#### 13.1.3 设置errno并返回一个带内错误指示符的库函数

C标准指定下表中所列的函数会设置errno并返回一个带内错误指示符。即：在发生错误时返回的值仍然会是成功调用时合法返回值。

strtoul()函数在发生错误时返回ULONG_MAX，并把errno设置为ERANGE。由于ULONG_MAX也是合法的返回值，因此必须检查errno，才能确定是否实际发生了错误。

fgetwc()和fputwc()函数在大多数情况下返回WEOF，仅仅在一种情况下需要设置errno。如果数据类型无法表达转换的数据时，函数会返回最大或者最小的数并且设置errno为ERANGE。当然，如果输入非法导致转换无法完成，函数将会返回0，并且会将输入指针参数赋值给输出指针参数，保证输出为非NULL。

| 函数名称 | 返回值 | errno |
| -- | -- | -- |
| fgetwc(), fputwc() | WEOF | EILSEQ |
| strtol(), wcstol() | LONG_MIN orLONG_MAX | ERANGE |
| strtoll(), wcstoll() | LLONG_MIN orLLONG_MAX | ERANGE |
| strtoul(), wcstoul() | ULONG_MAX | ERANGE |
| strtoull(), wcstoull() | ULLONG_MAX | ERANGE |
| strtoumax(), wcstoumax() | UINTMAX_MAX | ERANGE |
| strtod(), wcstod() | 0 or ±HUGE_VAL | ERANGE |
| strtof(), wcstof() | 0 or ±HUGE_VALF | ERANGE |
| strtold(), wcstold() | 0 or ±HUGE_VALL | ERANGE |
| strtoimax(), wcstoimax() | INTMAX_MIN,INTMAX_MAX | ERANGE |

#### 13.1.4 不保证设置errno的库函数

C标准中，有些库函数缺乏与errno有关的描述，例如：setlocale()函数在发生错误时一般返回NULL，但并不保证设置errno。
在调用这些函数之后，程序不应该完全依赖errno来确定是否发生了错误。这个函数可能会更改errno，但是并不保证errno会正确的提示错误条件。

#### 13.1.5 具有不同标准文档的库函数

有些函数在不同标准中在errno方面具有不同的行为。fopen()函数就是一个例子。根据C标准，当fopen()遇到一个错误时，它返回NULL。C标准并没有描述fopen()时提到errno。但是，POSIX.1声明了当fopen()遇到一个错误时返回NULL，并且为errno设置一个值以提示这个错误。严格的说，这暗示一个遵循C标准但是不遵循POSIX的程序不应该在调用fopen()之后检查errno，但是POSIX程序可以在fopen()返回NULL时检查errno。

#### 13.1.6 库函数和errno
- 在 `<complex.h>` 中定义的函数可能会设置errno，但是并没有强制要求。
- 对于 `strtod，strtol，wcstod，wcstol` 函数群中的数值转换函数，如果正确的结果位于可表示值得范围之外，就返回一个适当的最小值和最大值，并且在errno中存储ERANGE这个值。但对于strtod和wcstod函数群中的浮点转换函数，如果发生了下溢，errno是否需要设置为ERANGE由编译器定义的。
- 数值转换函数atof、atoi函数群中的函数“不需要影响errno的值”。
- 对于 `<math.h>` 中的数学函数，如果整型表达式math_errhandling & MATH_ERRNO非0，在发生定义域错误时，errno要求为EDOM值；如果在默认的四舍五入时产生溢出或者从有限的实数所产生的结果是无限的，errno要求为ERANGE值；在发生下溢时，errno是否要求设置为ERANGE由编译器定义。
- 如果调用signal()宏所进行的一个请求无法得到满足，就返回一个SIG_ERR值，并把一个正值存储在errno中。
- 字节和宽字符输入输出函数以及多字节转换函数，当且仅当发生一个编码错误时，才把EILSEQ宏的值存储在errno中。
- 在失败时，fgetpos()和fsetpos()函数返回一个非0值，并把一个编译器定义的正值存储在errno中。
- 在失败时，ftell函数返回-lL，并把一个编译器定义的正值存储在errno中。
- perror()函数把errno中的错误码映射到一条消息中，并把它写入到stderr。

POSIX.1标准定义了errno被其他更多函数使用的方法。还有一小部分函数对这个规则例外。这些函数并没有保留用于提示错误的返回值，但是仍然在发生错误时设置errno。为了检测错误，应用程序在调用这些函数之前把errno设置为0，并在调用之后检查它是否为非0值。受影响的函数包括： `strcoll(),strxfrm(), strerror(), wcscoll(), wcsxfrm(), fwide()` 。C标准允许这些函数在成功时把errno设置为非0值。因此，这种类型的错误检查只应该在POSIX系统中执行。

#### 13.1.7 不合规代码示例 (strtoul())

如下示例中，没有在调用strtoul()之前把errno设置为0。记住，如果发生了一个溢出错误，strtoul()返回一个合法值（ULONG_MAX），因此errno是判断函数是否成功运行的唯一方法。
  
```cpp
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
  
void func(const char *c_str) {
  unsigned long number;
  char *endptr;
    
  number = strtoul(c_str, &endptr, 0);
  if (endptr == c_str || (number == ULONG_MAX
                         && errno == ERANGE)) {
    /* Handle error */
  } else {
    /* Computation succeeded */
  }
}
```
按照这种方法检测到的任何错误可能在程序中很早就出现，或者可能并不代表真正的错误。

#### 13.1.8 合规解决方案 (strtoul())
  
```cpp
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
  
void func(const char *c_str) {
  unsigned long number;
  char *endptr;
  
  errno = 0;
  number = strtoul(c_str, &endptr, 0);
  if (endptr == c_str || (number == ULONG_MAX
                         && errno == ERANGE)) {
    /* Handle error */
  } else {
    /* Computation succeeded */
  }
}
```

#### 13.1.9 不合规代码示例 (fopen())

如下示例中可能报告虚假的错误，因为即使在没有发生错误的情况下，fopen也可能设置errno。
  
```cpp
#include <errno.h>
#include <stdio.h>
  
void func(const char *filename) {
  FILE *fileptr;
  
  errno = 0;
  fileptr = fopen(filename, "rb");
  if (errno != 0) {
    /* Handle error */
  }
}
```

#### 13.1.10 合规解决方案 (fopen(), C)
  
```cpp
#include <stdio.h>
  
void func(const char *filename) {
  FILE *fileptr = fopen(filename, "rb");
  if (fileptr == NULL)  {
    /* An error occurred in fopen() */
  }
}
```

#### 13.1.11 合规解决方案 (fopen(), POSIX)
  
```cpp
#include <errno.h>
#include <stdio.h>
  
void func(const char *filename) {
  FILE *fileptr;
  
  errno = 0;
  fileptr = fopen(filename, "rb");
  if (fileptr == NULL)  {
    /*
     * An error occurred in fopen(); now it's valid
     * to examine errno.
     */
    perror(filename);
  }
}
```
#### 13.1.12 风险评估

errno的不正确使用可能导致无法检测错误条件，或者在不存在错误的情况下不正确地标识一个错误条件。
  
| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| ERR30-C | 中 | 有可能 | 中 | P8 | L2 |

##### 13.1.12.1 自动检查

尽管有些例子可以通过简单的等效函数的方式扫描到，这个规则通常不能被探测到。
  
| 工具 | 版本 | 检查 | 描述 |
| -- | -- | -- | -- |
| [Compass/ROSE](https://www.securecoding.cert.org/confluence/display/c/Rose) |  |  | Could detect violations of this rule by ensuring that each library function is accompanied by the proper treatment of errno |
| [Coverity](https://www.securecoding.cert.org/confluence/display/c/Coverity) | 6.5 | UNCAUGHT_EXCEPT | Fully implemented |
| [LDRA tool suite](https://www.securecoding.cert.org/confluence/display/c/LDRA) | 9.5.6 |     111 D, 121 D, 122 D, 132  D, 134 D | Fully implemented |
| [Parasoft C/C++test](https://www.securecoding.cert.org/confluence/display/c/Parasoft) | 9.5 | MRM-39 | Partially implemented |

##### 13.1.12.2 相关的缺陷
如果要查找因为违反这条规则而照成的漏洞，请参见[CERT](https://www.kb.cert.org/vulnotes/bymetric?searchview&query=FIELD+KEYWORDS+contains+INT06-Cebsite.)的网站。

#### 13.1.13 相关参考

| - | - |
| -- | -- |
| CERT C Secure Coding Standard | EXP12-C. Do not ignore values returned by functions  |
| ISO/IEC TS 17961:2013 | Incorrectly setting and using errno[inverrno] |
| MITRE CWE | CWE-456, Missing Initialization of a Variable |



#### 13.1.14 参考书目

| - | - |
| -- | -- |
|[Brainbell.com] | Macros and Miscellaneous Pitfalls |
| [Horton 1990] | Section 11, p. 168 |
| [Horton 1990] | Section 14, p. 254 |
| [IEEE Std 1003.1-2013] | XSH, System Interfaces, fopen |
| [Koenig 1989] | Section 5.4, p. 73 |
| [Summit 2005] | |


### 13.2 ERR32-C. 不要依赖errno的不确定值

信号处理函数允许调用signal()，如果调用失败，signal()返回SIG_ERR，并把errno设置为一个正值。但是，如果触发一个信号的事件都是外部的（不是abort或者raise），信号处理函数唯一可以调用的函数是_Exit()或abort()，或者在当前处理的信号上调用signal()。如果signal()失败，errno的值就是不确定的。

这个规则是SIG31-C. Do not access shared objects in signal handlers的一种特殊情况。errno所指定大的对象具有静态持久性，而不是volatile sig_atomic_t类型。因此，执行任何要求设置errno的操作一般会导致未定义的行为。C标准在这种情况下为errno创建了一个特殊的例外，表示唯一允许出错的情况是errno取一个不确定的值。这就允许在信号处理函数内部调用signal()，而不会出现不受限制的未定义行为的风险。但是，这个处理函数以及在这个处理函数返回后所执行的任何代码，必须不能依赖有意义的errno值。

#### 13.2.1 不合规代码示例

如果可以满足把信号设置为默认的请求，对于指定信号大的大多数最近的signal()的成功调用，signal()函数将返回信号处理函数的值。否则，它就返回SIG_ERR值，并且把一个正值存储在errno中。
  
```cpp
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
  
typedef void (*pfv)(int);
  
void handler(int signum) {
  pfv old_handler = signal(signum, SIG_DFL);
  if (old_handler == SIG_ERR) {
    perror("SIGINT handler"); /* Undefined behavior */
    /* Handle error */
  }
}
  
int main(void) {
  pfv old_handler = signal(SIGINT, handler);
  if (old_handler == SIG_ERR) {
    perror("SIGINT handler");
    /* Handle error */
  }
  
  /* Main code loop */
  
  return EXIT_SUCCESS;
}
```
在handler()中调用perror()还违背了SIG30-C. Call only asynchronous-safe functions within signal handlers。

#### 13.2.2 合规解决方案

示例中并没有引用errno。如果signal()调用失败，它并不会从信号处理函数返回。
  
```cpp
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
  
typedef void (*pfv)(int);
  
void handler(int signum) {
  pfv old_handler = signal(signum, SIG_DFL);
  if (old_handler == SIG_ERR) {
    abort();
  }
}
  
int main(void) {
  pfv old_handler = signal(SIGINT, handler);
  if (old_handler == SIG_ERR) {
    perror("SIGINT handler");
    /* Handle error */
  }
  
  /* Main code loop */
  
  return EXIT_SUCCESS;
}
```

#### 13.2.3 非合规解决方案(POSIX)

在POSIX中，应用程序在信号处理函数所面临的限制要少于C标准。它有一个常常的可以调用的异步安全函数列表（SIG30-C. Call only asynchronous-safe functions within signal handlers）。这些函数有很多在遇到错误时设置errno。这可能导致一种情况，就是如果一个信号处理函数是在一次失败的函数调用和后面对errno的检查之间执行的，检查所得的errno值就不是由那个失败的函数设置的，而是由这个信号处理函数内部的一个函数调用设置的。POSIX应用程序可以通过让更改errno的信号处理函数在进入时保存errno值，并在恢复之后恢复它的值来避免这个问题。

如下实例中的信号处理函数更改了errno的值，因此如果他是在一次失败的函数调用和后续对errno的检查之间执行的，就可能导致不正确的错误处理。
  
```cpp
#include <signal.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/wait.h>
  
void reaper(int signum) {
  errno = 0;
  for (;;) {
    int rc = waitpid(-1, NULL, WNOHANG);
    if ((0 == rc) || (-1 == rc && EINTR != errno)) {
      break;
    }
  }
  if (ECHILD != errno) {
    /* Handle error */
  }
}
  
int main(void) {
  struct sigaction act;
  act.sa_handler = reaper;
  act.sa_flags = 0;
  if (sigemptyset(&act.sa_mask) != 0) {
    /* Handle error */
  }
  if (sigaction(SIGCHLD, &act, NULL) != 0) {
    /* Handle error */
  }
  
  /* ... */
  
  return EXIT_SUCCESS;
}
```

#### 13.2.4 合规解决方案(POSIX)

如下合规解决方案中展示了信号处理过程中保存和恢复errno的例子。
  
```cpp
#include <signal.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/wait.h>
  
void reaper(int signum) {
  errno_t save_errno = errno;
  errno = 0;
  for (;;) {
    int rc = waitpid(-1, NULL, WNOHANG);
    if ((0 == rc) || (-1 == rc && EINTR != errno)) {
      break;
    }
  }
  if (ECHILD != errno) {
    /* Handle error */
  }
  errno = save_errno;
}
  
int main(void) {
  struct sigaction act;
  act.sa_handler = reaper;
  act.sa_flags = 0;
  if (sigemptyset(&act.sa_mask) != 0) {
    /* Handle error */
  }
  if (sigaction(SIGCHLD, &act, NULL) != 0) {
    /* Handle error */
  }
  
  /* ... */
  
  return EXIT_SUCCESS;
}
```

#### 13.2.5 风险评估

errno的不正确使用可能导致无法检测错误条件，或者在不存在错误的情况下不正确地标识一个错误条件。
  
| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| ERR32-C | 低 | 不太可能 | 低 | P3 | L3 |

##### 13.2.5.1 自动检查

尽管有些例子可以通过简单的等效函数的方式扫描到，这个规则通常不能被探测到。
  
| 工具 | 版本 | 检查 | 描述 |
| -- | -- | -- | -- |
| [Compass/ROSE](https://www.securecoding.cert.org/confluence/display/c/Rose) |  |  | Could detect violations of this rule by looking for signal handlers that themselves callsignal(). A violation is reported if the call fails and the handler therefore checks errno. A violation also exists if the signal handler modifies errnowithout first copying its value elsewhere |
| [LDRA tool suite](https://www.securecoding.cert.org/confluence/display/c/LDRA) | 9.5.6 |     44 S | Enhanced enforcement |

##### 13.2.5.2 相关的缺陷
如果要查找因为违反这条规则而照成的漏洞，请参见[CERT](https://www.kb.cert.org/vulnotes/bymetric?searchview&query=FIELD+KEYWORDS+contains+INT06-Cebsite.)的网站。

#### 13.2.6 相关参考

| - | - |
| -- | -- |
| CERT C Secure Coding Standard | SIG30-C. Call only asynchronous-safe functions within signal handlers |
| CERT C Secure Coding Standard | SIG31-C. Do not access shared objects in signal handlers  |



#### 13.2.7 参考书目

| - | - |
| -- | -- |
|[ISO/IEC 9899:2011] | Subclause 7.14.1.1, "The signalFunction" |

### 13.3 ERR33-C. 检查和处理标准库的错误

大多数标准库函数，包括I/O系列函数和内存分配函数，都能够通过返回一个有效值或正确的返回类型，来指示一个错误(例如，−1或NULL指针)。假设所有调用这些函数都会返回成功而不去检查能够指示错误的返回值，是危险的做法，当一个错误产生时，它将会导致无法预期的行为。因此，采用和实现一致的，全面的错误处理策略是至关重要的，参见：ERR00-C. 采用和实现一致的，全面的错误处理策略。
下表所列的C标准库函数完整的列出了正常和失败返回的内容，它们的出错内容可以通过调用脚注中的函数(ferror() 和 feof() )比较“错误返回列”的数据。

| Function |     Successful Return |     Error Return |
| -- | -- | -- |
| wscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| wscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| wprintf_s() |     Number of wide characters (nonnegative) |     Negative |
| wmemchr() |     Pointer to located wide character |     NULL |
| wctype() |     Valid argument to iswctype |     0 |
| wctrans() |     Valid argument to towctrans |     0 |
| wctomb_s(), s != NULL |     Number of bytes stored |     −1 |
| wctomb(), s != NULL |     Number of bytes stored |     −1 |
| wctob() |     Converted character |     EOF |
| wcsxfrm() |     Length of transformed wide string |     >= n |
| wcstoumax() |     Converted value |     UINTMAX_MAX, errno == ERANGE |
| wcstoull() |     Converted value |     ULLONG_MAX, errno == ERANGE |
| wcstoul() |     Converted value |     ULONG_MAX, errno == ERANGE |
| wcstombs_s() |     0 |     Nonzero |
| wcstombs() |     Number of non-null bytes |     (size_t)(-1) |
| wcstoll() |     Converted value |     LLONG_MAX or LLONG_MIN, errno == ERANGE |
| wcstold() |     Converted value |     0, errno == ERANGE |
| wcstol() |     Converted value |     LONG_MAX or LONG_MIN, errno == ERANGE |
| wcstok_s() |     Pointer to first wide character of a token |     NULL |
| wcstok() |     Pointer to first wide character of a token |     NULL |
| wcstoimax() |     Converted value |     INTMAX_MAX or INTMAX_MIN, errno == ERANGE |
| wcstof() |     Converted value |     0, errno == ERANGE |
| wcstod() |     Converted value |     0, errno == ERANGE |
| wcsstr() |     Pointer to located wide string |     NULL |
| wcsrtombs_s() |     0 |     Nonzero |
| wcsrtombs() |     Number of non-null bytes |     (size_t)(-1), errno == EILSEQ |
| wcsrchr() |     Pointer to located wide character |     NULL |
| wcspbrk() |     Pointer to located wide character |     NULL |
| wcsftime() |     Number of non-null wide characters |     0 |
| wcschr() |     Pointer to located wide character |     NULL |
| wcrtomb() |     Number of bytes stored |     (size_t)(-1) |
| vwscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| vwscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| vwprintf_s() |     Number of wide characters (nonnegative) |     Negative |
| vswscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| vswscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| vswprintf_s() |     Number of non-null wide characters |     Negative |
| vswprintf() |     Number of non-null wide characters |     Negative |
| vsscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| vsscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| vsprintf_s() |     Number of non-null characters (nonnegative) |     Negative |
| vsprintf() |     Number of non-null characters (nonnegative) |     Negative |
| vsnprintf_s() |     Number of characters that would be written (nonnegative) |     Negative |
| vsnprintf() |     Number of characters that would be written (nonnegative) |     Negative |
| vscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| vscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| vprintf_s() |     Number of characters (nonnegative) |     Negative |
| vfwscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| vfwscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| vfwprintf_s() |     Number of wide characters (nonnegative) |     Negative |
| vfwprintf() |     Number of wide characters (nonnegative) |     Negative |
| vfscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| vfscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| vfprintf_s() |     Number of characters (nonnegative) |     Negative |
| vfprintf() |     Number of characters (nonnegative) |     Negative |
| ungetwc() |     Character pushed back |     WEOF |
| ungetc() |     Character pushed back |     EOF (see below) |
| tss_set() |     thrd_success |     thrd_error |
| tss_get() |     Value of thread-specific storage |     0 |
| tss_create() |     thrd_success |     thrd_error |
| tmpnam_s() |     0 |     Nonzero |
| tmpnam() |     Non-null pointer |     NULL |
| tmpfile_s() |     0 |     Nonzero |
| tmpfile() |     Pointer to stream |     NULL |
| timespec_get() |     Base |     0 |
| time() |     Calendar time |     (time_t)(-1) |
| thrd_sleep() |     0 |     Negative |
| thrd_join() |     thrd_success |     thrd_error |
| thrd_detach() |     thrd_success |     thrd_error |
| thrd_create() |     thrd_success |     thrd_nomem or thrd_error |
| swscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| swscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| swprintf_s() |     Number of non-null wide characters |     Negative |
| swprintf() |     Number of non-null wide characters |     Negative |
| strxfrm() |     Length of transformed string |     >= n |
| strtoumax() |     Converted value |     UINTMAX_MAX, errno == ERANGE |
| strtoull() |     Converted value |     ULLONG_MAX, errno == ERANGE |
| strtoul() |     Converted value |     ULONG_MAX, errno == ERANGE |
| strtoll() |     Converted value |     LLONG_MAX or LLONG_MIN, errno == ERANGE |
| strtold() |     Converted value |     0, errno == ERANGE |
| strtol() |     Converted value |     LONG_MAX or LONG_MIN, errno == ERANGE |
| strtok_s() |     Pointer to first character of a token |     NULL |
| strtok() |     Pointer to first character of a token |     NULL |
| strtoimax() |     Converted value |     INTMAX_MAX or INTMAX_MIN, errno == ERANGE |
| strtof() |     Converted value |     0, errno == ERANGE |
| strtod() |     Converted value |     0, errno == ERANGE |
| strstr() |     Pointer to located string |     NULL |
| strrchr() |     Pointer to located character |     NULL |
| strpbrk() |     Pointer to located character |     NULL |
| strftime() |     Number of non-null characters |     0 |
| strerror_s() |     0 |     Nonzero |
| strchr() |     Pointer to located character |     NULL |
| sscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| sscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| sprintf_s() |     Number of non-null characters written |     Negative |
| sprintf() |     Number of non-null characters written |     Negative |
| snprintf_s() |     Number of characters that would be written (nonnegative) |     Negative |
| snprintf() |     Number of characters that would be written (nonnegative) |     Negative |
| signal() |     Pointer to previous function |     SIG_ERR, errno > 0 |
| setvbuf() |     0 |     Nonzero |
| setlocale() |     Pointer to string |     NULL |
| scanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| scanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| rename() |     0 |     Nonzero |
| remove() |     0 |     Nonzero |
| realloc() |     Pointer to space |     NULL |
| raise() |     0 |     Nonzero |
| putwc() |     Wide character written |     WEOF |
| putc() |     Character written |     EOF2 |
| printf_s() |     Number of characters (nonnegative) |     Negative |
| mtx_unlock() |     thrd_success |     thrd_error |
| mtx_trylock() |     thrd_success |     thrd_busy or thrd_error |
| mtx_timedlock() |     thrd_success |     thrd_timedout or thrd_error |
| mtx_lock() |     thrd_success |     thrd_error |
| mtx_init() |     thrd_success |     thrd_error |
| mktime() |     Calendar time |     (time_t)(-1) |
| memchr() |     Pointer to located character |     NULL |
| mbtowc(), s != NULL |     Number of bytes |     −1 |
| mbstowcs_s() |     0 |     Nonzero |
| mbstowcs() |     Number of non-null elements |     (size_t)(-1) |
| mbsrtowcs_s() |     0 |     Nonzero |
| mbsrtowcs() |     Number of non-null elements |     (size_t)(-1), errno == EILSEQ |
| mbrtowc(), s != NULL |     Number of bytes or status |     (size_t)(-1), errno == EILSEQ |
| mbrtoc32() |     Number of bytes or status |     (size_t)(-1), errno == EILSEQ |
| mbrtoc16() |     Number of bytes or status |     (size_t)(-1), errno == EILSEQ |
| mbrlen(), s != NULL |     Number of bytes or status |     (size_t)(-1) |
| mblen(), s != NULL |     Number of bytes |     −1 |
| malloc() |     Pointer to space |     NULL |
| localtime_s() |     Pointer to broken-down time |     NULL |
| localtime() |     Pointer to broken-down time |     NULL |
| gmtime_s() |     Pointer to broken-down time |     NULL |
| gmtime() |     Pointer to broken-down time |     NULL |
| getwchar() |     Wide character read |     WEOF |
| getwc() |     Wide character read |     WEOF |
| gets_s() |     Pointer to string |     NULL |
| getenv_s() |     Pointer to string |     NULL |
| getenv() |     Pointer to string |     NULL |
| getchar() |     Character read |     EOF1 |
| getc() |     Character read |     EOF1 |
| fwscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| fwscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| fwrite() |     Elements written |     Elements written |
| fwprintf_s() |     Number of wide characters (nonnegative) |     Negative |
| fwprintf() |     Number of wide characters (nonnegative) |     Negative |
| ftell() |     File position |     −1L, errno > 0 |
| fsetpos() |     0 |     Nonzero, errno > 0 |
| fseek() |     0 |     Nonzero |
| fscanf_s() |     Number of conversions (nonnegative) |     EOF (negative) |
| fscanf() |     Number of conversions (nonnegative) |     EOF (negative) |
| freopen_s() |     0 |     Nonzero |
| freopen() |     Pointer to stream |     NULL |
| fread() |     Elements read |     Elements read |
| fputws() |     Nonnegative |     EOF (negative) |
| fputwc() |     Wide character written  |     WEOF |
| fputs() |     Nonnegative |     EOF (negative) |
| fputc() |     Character written |     EOF2 |
| fprintf_s() |     Number of characters (nonnegative) |     Negative |
| fprintf() |     Number of characters (nonnegative) |     Negative |
| fopen_s() |     0 |     Nonzero |
| fopen() |     Pointer to stream |     NULL |
| fgetwc() |     Wide character read |     WEOF1 |
| fgets() |     Pointer to string |     NULL |
| fgetpos() |     0 |     Nonzero, errno > 0 |
| fgetc() |     Character read |     EOF1 |
| fflush() |     0 |     EOF (negative) |
| fclose() |     0 |     EOF (negative) |
| ctime_s() |     0 |     Nonzero |
| cnd_wait() |     thrd_success |     thrd_error |
| cnd_timedwait() |     thrd_success |     thrd_timedout or thrd_error |
| cnd_signal() |     thrd_success |     thrd_error |
| cnd_init() |     thrd_success |     thrd_nomem or thrd_error |
| cnd_broadcast() |     thrd_success |     thrd_error |
| clock() |     Processor time |     (clock_t)(-1) |
| calloc() |     Pointer to space |     NULL |
| c32rtomb() |     Number of bytes |     (size_t)(-1) |
| c16rtomb() |     Number of bytes |     (size_t)(-1) |
| btowc() |     Converted wide character |     WEOF |
| bsearch_s() |     Pointer to matching element |     NULL |
| bsearch() |     Pointer to matching element |     NULL |
| atexit() |     0 |     Nonzero |
| at_quick_exit() |     0 |     Nonzero |
| asctime_s() |     0 |     Nonzero |
| aligned_alloc() |     Pointer to space |     NULL |

注意：依据FIO35-C. Use feof() and ferror() to detect end-of-file and file errors when sizeof(int) == sizeof(char) ，调用者应该使用如下函数校验文件的结束和文件的错误：
1 By calling ferror() and feof()
2 By calling ferror()
ungetc()函数在返回失败时并没有设置错误指示符，因此它不可能可靠的检查到错误，除非它知道它的参数非EOF
C 标准 [ISO/IEC 9899:2011] ："one character of pushback is guaranteed," so this should not be an issue if, at most, one character is ever pushed back before reading again. (See FIO13-C. Never push back anything other than one read character.)

#### 13.3.1 不合规代码示例 (setlocale())

如下示例中，utf8_to_wcs()函数将一个UTF8字符序列转换为宽字符串。它首先调用setlocale()函数设置全局locale为 en_US.UTF-8，但是却没有用检查失败的情况。setlocale有可能会返回失败并且返回一个NULL指针，例如：locale未被安装；也可能由于资源限制而返回失败。依赖于函数输入的utf8(参数)字符串序列，调用mbstowcs()可能会失败，并导致wcs中存储一个意想不到的宽字符串序列。
  
```cpp
#include <locale.h>
#include <stdlib.h>
  
int utf8_to_wcs(wchar_t *wcs, size_t n, const char *utf8,
                size_t *size) {
  if (NULL == size) {
    return -1;
  }
  setlocale(LC_CTYPE, "en_US.UTF-8");
  *size = mbstowcs(wcs, utf8, n);
  return 0;
}
```

#### 13.3.2 合规解决方案 (setlocale())

在这个合规解决方案中，函数会去检查setlocale()的返回值，并在函数返回失败时不去调用mbstowcs()函数。然后函数还负责把locale恢复到初始状态并返回给调用者。
  
```cpp
#include <locale.h>
#include <stdlib.h>
  
int utf8_to_wcs(wchar_t *wcs, size_t n, const char *utf8,
                size_t *size) {
  if (NULL == size) {
    return -1;
  }
  const char *save = setlocale(LC_CTYPE, "en_US.UTF-8");
  if (NULL == save) {
    return -1;
  }
  
  *size = mbstowcs(wcs, utf8, n);
  if (NULL == setlocale(LC_CTYPE, save)) {
    return -1;
  }
  return 0;
}
```

#### 13.3.3 不合规代码示例 (calloc())

```cpp
#include <stdlib.h>
#include <string.h>
  
enum { SIG_DESC_SIZE = 32 };
  
typedef struct {
  char sig_desc[SIG_DESC_SIZE];
} signal_info;
  
void func(size_t num_of_records, size_t temp_num,
          const char *tmp2, size_t tmp2_size_bytes) {
  signal_info *start = (signal_info *)calloc(num_of_records,
                                          sizeof(signal_info));
  
  if (tmp2 == NULL) {
    /* Handle error */
  } else if (temp_num > num_of_records) {
    /* Handle error */
  } else if (tmp2_size_bytes < SIG_DESC_SIZE) {
    /* Handle error */
  }
  
  signal_info *point = start + temp_num - 1;
  memcpy(point->sig_desc, tmp2, SIG_DESC_SIZE);
  point->sig_desc[SIG_DESC_SIZE - 1] = '\0';
  /* ... */
  free(start);
}
```
在这个不合规示例中，入侵者可以很轻松的通过提供一个较大的num_of_records来导致calloc()失败。

当calloc()失败时，它会返回一个NULL给start。如果start为NULL，入侵者可以给temp_num提供一个sizeof(signal_info)大小的值，并映射到一个可写的地址以实现控制转移：tmp2指向的字符串会被写入到这个新地址，并导致代码执行漏洞。

#### 13.3.4 合规解决方案 (calloc())
  
```cpp
#include <stdlib.h>
#include <string.h>
  
enum { SIG_DESC_SIZE = 32 };
  
typedef struct {
  char sig_desc[SIG_DESC_SIZE];
} signal_info;
   
void func(size_t num_of_records, size_t temp_num,
          const char *tmp2, size_t tmp2_size_bytes) {
  signal_info *start = (signal_info *)calloc(num_of_records,
                                           sizeof(signal_info));
  if (start == NULL) {
    /* Handle allocation error */
  } else if (tmp2 == NULL) {
    /* Handle error */
  } else if (temp_num > num_of_records) {
    /* Handle error */
  } else if (tmp2_size_bytes < SIG_DESC_SIZE) {
    /* Handle error */
  }
  
  signal_info *point = start + temp_num - 1;
  memcpy(point->sig_desc, tmp2, SIG_DESC_SIZE);
  point->sig_desc[SIG_DESC_SIZE - 1] = '\0';
  /* ... */
  free(start);
}
```
为了解决这个问题，确保调用calloc()的返回值不是NULL指针。

#### 13.3.5 不合规代码示例 (realloc())

如下示例中，调用realloc()函数修改p指向内存的大小。如果realloc()返回失败，将会返回一个NULL指针，p原来指向的指针丢失，导致内存泄露。参见：MEM04-C. Do not perform zero-length allocations.
  
```cpp
#include <stdlib.h>
  
void *p;
void func(size_t new_size) {
  if (new_size == 0) {
    /* Handle error */
  }
  p = realloc(p, new_size);
  if (p == NULL) {
   /* Handle error */
  }
}
```
#### 13.3.6 合规解决方案 (realloc())
  
```cpp
#include <stdlib.h>
  
void *p;
void func(size_t new_size) {
  void *q;
  
  if (new_size == 0) {
    /* Handle error */
  }
  
  q = realloc(p, new_size);
  if (q == NULL) {
   /* Handle error */
  } else {
    p = q;
  }
}
```

#### 13.3.7 不合规代码示例 (fseek())

```cpp
#include <stdio.h>
  
size_t read_at(FILE *file, long offset,
               void *buf, size_t nbytes) {
  fseek(file, offset, SEEK_SET);
  return fread(buf, 1, nbytes, file);
}
```

#### 13.3.8 合规解决方案 (fseek())
  
```cpp
#include <stdio.h>
  
size_t read_at(FILE *file, long offset,
               void *buf, size_t nbytes) {
  if (fseek(file, offset, SEEK_SET) != 0) {
    /* Indicate error to caller */
    return 0;
  }
  return fread(buf, 1, nbytes, file);
}
```

#### 13.3.9 不合规代码示例 (snprintf())
  
```cpp
#include <stdio.h>
  
extern void log_message(const char *);
  
void f(int i, int width, int prec) {
  char buf[40];
  snprintf(buf, sizeof(buf), "i = %*.*i", width, prec, i);
  log_message(buf);
  /* ... */
}
```

#### 13.3.10 合规解决方案 (snprintf())
  
```cpp
#include <stdio.h>
#include <string.h>
  
extern void log_message(const char *);
  
void f(int i, int width, int prec) {
  char buf[40];
  int n;
  n = snprintf(buf, sizeof(buf), "i = %*.*i", width, prec, i);
  if (n < 0 || n >= sizeof(buf)) {
    /* Handle snprintf() error */
    strcpy(buf, "unknown error");
  }
  log_message(buf);
}
```

#### 13.3.11 合规解决方案 (snprintf(null))

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
  
extern void log_message(const char *);
  
void f(int i, int width, int prec) {
  char buffer[20];
  char *buf = buffer;
  int n  = sizeof(buffer);
  const char fmt[] = "i = %*.*i";
  
  n = snprintf(buf, n, fmt, width, prec, i);
  if (n < 0) {
    /* Handle snprintf() error */
    strcpy(buffer, "unknown error");
    goto write_log;
  }
  
  if (n < sizeof(buffer)) {
    goto write_log;
  }
  
  buf = (char *)malloc(n + 1);
  if (NULL == buf) {
    /* Handle malloc() error */
    strcpy(buffer, "unknown error");
    goto write_log;
  }
  
  n = snprintf(buf, n, fmt, width, prec, i);
  if (n < 0) {
    /* Handle snprintf() error */
    strcpy(buffer, "unknown error");
  }
  
write_log:
  log_message(buf);
  
  if (buf != buffer) {
    free(buf);
  }
}
```

#### 13.3.12 例外

ERR33-C-EX1：
如果一个函数不会失败，或者返回值是不重要的，或者错误状态不需要被检查，忽视返回值是可以接受的。
函数的返回值应该明确为void类型以表明程序员的意图。
如下表格中的函数由于历史原因忽略了错误检查和安全，它们的返回值不需要检查。 

| Function |     Successful Return |     Error Return |
| -- | -- | -- |
| kill_dependency() |     The input parameter  |     NA |
| memcpy(), wmemcpy() |     The destination input parameter |     NA |
| memmove(), wmemmove() |     The destination input parameter  |     NA |
| memset(), wmemset() |     The destination input parameter |     NA  |
| printf(), vprintf() |     Number of characters (nonnegative) |     Negative |
| putchar() |     Character written |     EOF |
| puts() |     Nonnegative |     EOF (negative) |
| putwchar() |     Wide character written |     WEOF |
| strcat(), wcscat() |     The destination input parameter  |     NA  |
| strcpy(), wcscpy() |     The destination input parameter  |     NA |
| strncat(), wcsncat() |     The destination input parameter  |     NA |
| strncpy(), wcsncpy() |     The destination input parameter  |     NA  |
| wprintf(), vwprintf() |     Number of wide characters (nonnegative) |     Negative |

#### 13.3.13 风险评估

errno的不正确使用可能导致无法检测错误条件，或者在不存在错误的情况下不正确地标识一个错误条件。
  
| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| ERR33-C | 高 | 可能 | 中 | P18 | L1 |

##### 13.3.13.1 自动检查

尽管有些例子可以通过简单的等效函数的方式扫描到，这个规则通常不能被探测到。
  
| 工具 | 版本 | 检查 | 描述 |
| -- | -- | -- | -- |
| [CodeSonar](https://www.securecoding.cert.org/confluence/display/c/CodeSonar) | 4.4 | LANG.FUNCS.IRV | Ignored return value |
| [Compass/ROSE](https://www.securecoding.cert.org/confluence/display/c/Rose) |  |  | Can detect violations of this recommendation when checking for violations of EXP12-C. Do not ignore values returned by functions and EXP34-C. Do not dereference null pointers |
| [Coverity](https://www.securecoding.cert.org/confluence/display/c/Coverity) | 7.5.0 | CHECKED_RETURN | Finds inconsistencies in how function call return values are handled. Coverity Prevent cannot discover all violations of this recommendation, so further verification is necessary |
| [LDRA tool suite](https://www.securecoding.cert.org/confluence/display/c/LDRA) | 9.5.6 |     80 D | Partially implemented |
| [Parasoft C/C++test](https://www.securecoding.cert.org/confluence/display/c/Parasoft) | 9.5 | CODSTA-122{a,b}, BD-PB-NP | Partially implemented |
| [PRQA QA-C](https://www.securecoding.cert.org/confluence/display/c/PRQA+QA-C) | 8.2 | 3200 | Partially implemented |

##### 13.3.13.2 相关的缺陷
Adobe Flash [ [VU#159523](https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-VU#159523) ] 的一个缺陷就是由于没有去检查calloc()函数的返回值。甚至在该函数返回NULL时，应该会根据返回值写入一个量。野指针常常会导致程序崩溃，但是一个无法确定的值虽然不会导致程序奔溃，但会导致漏洞。

如果要查找因为违反这条规则而照成的漏洞，请参见[CERT](https://www.kb.cert.org/vulnotes/bymetric?searchview&query=FIELD+KEYWORDS+contains+INT06-Cebsite.)的网站。

#### 13.3.14 相关参考

| - | - |
| -- | -- |
| CERT C Secure Coding Standard | ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy |
| CERT C Secure Coding Standard | EXP34-C. Do not dereference null pointers |
| CERT C Secure Coding Standard | FIO13-C. Never push back anything other than one read character |
| CERT C Secure Coding Standard | MEM04-C. Do not perform zero-length allocations |
| CERT C Secure Coding Standard | MEM12-C. Consider using a goto chain when leaving a function on error when using and releasing resources |
| SEI CERT C++ Secure Coding Standard | ERR10-CPP. Check for error conditions |
| SEI CERT C++ Secure Coding Standard | FIO04-CPP. Detect and handle input and output errors |
| ISO/IEC TS 17961:2013 | Failing to detect and handle standard library errors [liberr] |
| MITRE CWE | CWE-252, Unchecked Return Value; CWE-253, Incorrect Check of Function Return Value; CWE-390, Detection of Error Condition without Action; CWE-391, Unchecked Error Condition; CWE-476, NULL Pointer Dereference |

#### 13.3.15 参考书目

| - | - |
| -- | -- |
| [DHS 2006] | Handle All Errors Safely |
| [Henricson 1997] | Recommendation 12.1, "Check for All Errors Reported from Functions" |
| [ISO/IEC 9899:2011] | Subclause 7.21.7.10, "The ungetc Function" |
| [VU#159523] |  |

### 13.4 ERR34-C. 字符串转为数字时检查错误

把字符串转换为整型数或者浮点型数据的过程中会产生许多的错误：字符串可能没有包含数字；字符串数据超限（例如int超过了INT_MAX）；字符串可能包含可能有用或者无用的额外信息。使用C标准库进行字符串和数字转换时这些错误都必须被检查到并且被标示出来。
` strtol()，strtoll()，strtoimax()，strtoul()，strtoull()，strtoumax()，strtof()，strtod()和strtold()` 函数把一个null结尾的字符串分别转换为：
` long int，long long int，intmax_t，unsigned long int，unsigned long long int，uintmax_t，float，double和long double` 形式。

C标准库函数中的strto*()系列函数把字符串转换为整型或者浮点型数据，这些函数提供了更加鲁棒的错误处理能力。其中，使用strtol()函数转换一个小一点的有符号整型数（如 signed int, signed short, and signed char），测试其结果是否超出了数据范围；使用strtoul()函数转换一个小一点的无符号整型数（如 unsigned int, unsigned short, and unsigned char），测试其结果是否超出了数据范围。如果数据类型较小并且刚好有相同的大小时，范围测试表现为特定的实现并且不会有任何动作。

#### 13.4.1 不合规代码示例 (atoi())

如下示例展示了通过atoi函数转换一个有符号整型数。
  
```cpp
#include <stdlib.h>
  
void func(const char *buff) {
  int si;
  
  if (buff) {
    si = atoi(buff);
  } else {
    /* Handle error */
  }
}
```

` atoi(), atol(), atoll(), and atof()` 函数分别把一个字符串转换为 ` int，long int, long long int, 和double` 类型，如果不进行错误检查，它跟如下函数具有等价性：
  
```cpp
atoi: (int)strtol(nptr, (char **)NULL, 10)
atol: strtol(nptr, (char **)NULL, 10)
atoll: strtoll(nptr, (char **)NULL, 10)
atof: strtod(nptr, (char **)NULL)
```

不幸的是，atoi()系列函数缺乏处理/报告无效数据的机制：
  
- 出现错误时未设置errno值。
- 当结果值无法表达时，行为不明。（参见Annex J of the C Standard undefined behavior 119）
- 当字符串无法转换成一个整数时返回0（同0字符串的正确形式相区分），但是C标准认为这种行为是正确的。

#### 13.4.2 不合规代码示例 (sscanf())

如下示例展示了使用sscanf()函数将一个字符串转换为一个整型数，sscanf()函数同atoi()函数有着类似的限制：
  
```cpp
#include <stdio.h>
  
void func(const char *buff) {
  int matches;
  int si;
  
  if (buff) {
    matches = sscanf(buff, "%d", &si);
    if (matches != 1) {
      /* Handle error */
    }
  } else {
    /* Handle error */
  }
}
```
sscanf()函数返回同输入匹配成功的数量和buff，它可能比输入的要少，甚至可能为0。sscanf()函数不会报告strtol()函数的其他错误，比如：数字溢出。

#### 13.4.3 合规解决方案 (strtol())

strtol()，strtoll()，strtoimax()，strtoul()，strtoull()，strtoumax()，strtof()，strtod()和strtold()函数把一个null结尾的字符串分别转换为：
long int，long long int，intmax_t，unsigned long int，unsigned long long int，uintmax_t，float，double和long double形式。
如下例子展示了strtol()将一个字符串转换为整型并确保输出值在int范围内的合规用法：
  
```cpp
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
  
void func(const char *buff) {
  char *end;
  int si;
  
  errno = 0;
  
  const long sl = strtol(buff, &end, 10);
  
  if (end == buff) {
    fprintf(stderr, "%s: not a decimal number\n", buff);
  } else if ('\0' != *end) {
    fprintf(stderr, "%s: extra characters at end of input: %s\n", buff, end);
  } else if ((LONG_MIN == sl || LONG_MAX == sl) && ERANGE == errno) {
    fprintf(stderr, "%s out of range of type long\n", buff);
  } else if (sl > INT_MAX) {
    fprintf(stderr, "%ld greater than INT_MAX\n", sl);
  } else if (sl < INT_MIN) {
     fprintf(stderr, "%ld less than INT_MIN\n", sl);
  } else {
    si = (int)sl;
  
    /* Process si */
  }
}
```

#### 13.4.4 风险评估

errno的不正确使用可能导致无法检测错误条件，或者在不存在错误的情况下不正确地标识一个错误条件。
  
| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| ERR34-C | 中 | 不有可能 | 中 | P4 | L3 |

##### 13.4.4.1 自动检查

尽管有些例子可以通过简单的等效函数的方式扫描到，这个规则通常不能被探测到。
  
| 工具 | 版本 | 检查 | 描述 |
| -- | -- | -- | -- |
| [clang](https://www.securecoding.cert.org/confluence/display/c/Clang) | 3.9 | -cert-err34-c | Checked by clang-tidy |
| [CodeSonar](https://www.securecoding.cert.org/confluence/display/c/CodeSonar) | 4.4 | BADFUNC.ATOF;BADFUNC.ATOI;BADFUNC.ATOL;BADFUNC.ATOLL;(customization) | Use of atof;Use of atoi;Use of atol;Use of atoll;Users can add custom checks for uses of other undesirable conversion functions. |
| [Compass/ROSE](https://www.securecoding.cert.org/confluence/display/c/Rose) |  |  | Can detect violations of this recommendation by flagging invocations of the following functions: atoi() scanf(), fscanf(), sscanf() Others? |
| [Klocwork](https://www.securecoding.cert.org/confluence/display/c/Klocwork) | 2017 | MISRA.STDLIB.ATOI | |
| [LDRA tool suite](https://www.securecoding.cert.org/confluence/display/c/LDRA) |
 9.5.6 | 44 S | Fully implemented |
| [Parasoft C/C++test](https://www.securecoding.cert.org/confluence/display/c/Parasoft) | 9.5 | MISRA2004-20_10 | Fully implemented |
| [PRQA QA-C](https://www.securecoding.cert.org/confluence/display/c/PRQA+QA-C) | 8.2 | Warncall -wc atoi -wc atol | Partially implemented |

##### 13.4.4.2 相关的缺陷
如果要查找因为违反这条规则而照成的漏洞，请参见[CERT](https://www.kb.cert.org/vulnotes/bymetric?searchview&query=FIELD+KEYWORDS+contains+INT06-Cebsite.)的网站。

#### 13.4.5 相关参考

| - | - |
| -- | -- |
| CERT C Secure Coding Standard | INT06-CPP. Use strtol() or a related function to convert a string token to an integer  |
| ISO/IEC TS 17961:2013 | Incorrectly setting and using errno[inverrno] |
| MITRE CWE | CWE-676, Use of potentially dangerous function; CWE-20, Insufficient input validation |

#### 13.4.6 参考书目

| - | - |
| -- | -- |
| [ISO/IEC 9899:2011] | Subclause 7.22.1, "Numeric conversion functions"; Subclause 7.21.6, "Formatted input/output functions" |
| [Klein 2002] |  |

## 14 并发性 ( CON )

### 14.1 CON30-C 清除线程相关存储

`tss_create()` 函数创建一个由 Key 标识的线程相关存储指针。线程分配线程相关存储，通过调用 tss_set() 函数使其与一个Key关联，该 Key 唯一标识该线程存储。如果没有正确地释放线程相关存储，其对应内存就会被泄漏。确保线程相关存储被正确释放 。

#### 14.1.1 不合规代码示例

在该代码示例中，每个线程首先在 `get_data()` 函数中动态地分配存储，然后在 `add_data()` 函数中，调用 `tss_set()` 将其与全局 Key 关联。随后当线程终止时，该内存就被泄漏了。

```cpp
#include <threads.h>
#include <stdlib.h>
 
/* Global key to the thread-specific storage */
tss_t key;
enum { MAX_THREADS = 3 };
 
int *get_data(void) {
  int *arr = (int *)malloc(2 * sizeof(int));
  if (arr == NULL) {
    return arr;  /* Report error  */
  }
  arr[0] = 10;
  arr[1] = 42;
  return arr;
}
 
int add_data(void) {
  int *data = get_data();
  if (data == NULL) {
    return -1;  /* Report error */
  }
 
  if (thrd_success != tss_set(key, (void *)data)) {
    /* Handle error */
  }
  return 0;
}
 
void print_data(void) {
  /* Get this thread's global data from key */
  int *data = tss_get(key);
 
  if (data != NULL) {
    /* Print data */
  }
}
 
int function(void *dummy) {
  if (add_data() != 0) {
    return -1;  /* Report error */
  }
  print_data();
  return 0;
}
 
int main(void) {
  thrd_t thread_id[MAX_THREADS];
 
  /* Create the key before creating the threads */
  if (thrd_success != tss_create(&key, NULL)) {
    /* Handle error */
  }
 
  /* Create threads that would store specific storage */
  for (size_t i = 0; i < MAX_THREADS; i++) {
    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {
      /* Handle error */
    }
  }
 
  for (size_t i = 0; i < MAX_THREADS; i++) {
    if (thrd_success != thrd_join(thread_id[i], NULL)) {
      /* Handle error */
    }
  }
 
  tss_delete(key);
  return 0;
}
```
#### 14.1.2 合规解决方案

在该解决方案中，每个线程在终止前明确地释放由 `tss_get()` 函数返回的线程相关存储。

```cpp
#include <threads.h>
#include <stdlib.h>
  
/* Global key to the thread-specific storage */
tss_t key;
  
int function(void *dummy) {
  if (add_data() != 0) {
    return -1;  /* Report error */
  }
  print_data();
  free(tss_get(key));
  return 0;
}
 
/* ... Other functions are unchanged */
```
#### 14.1.3 合规解决方案

该解决方案触发在调用 `tss_create()` 时注册的析构函数来自动释放任何线程相关存储。

```cpp
#include <threads.h>
#include <stdlib.h>
 
/* Global key to the thread-specific storage */
tss_t key;
enum { MAX_THREADS = 3 };
 
/* ... Other functions are unchanged */
 
void destructor(void *data) {
  free(data);
}
 
int main(void) {
  thrd_t thread_id[MAX_THREADS];
 
  /* Create the key before creating the threads */
  if (thrd_success != tss_create(&key, destructor)) {
    /* Handle error */
  }
 
  /* Create threads that would store specific storage */
  for (size_t i = 0; i < MAX_THREADS; i++) {
    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {
      /* Handle error */
    }
  }
 
  for (size_t i = 0; i < MAX_THREADS; i++) {
    if (thrd_success != thrd_join(thread_id[i], NULL)) {
      /* Handle error */
    }
  }
 
  tss_delete(key);
  return 0;
}
```

#### 14.1.4 风险评估

无法释放线程相关的对象会导致内存泄漏，还会导致拒绝服务攻击。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON30-C | 中 | 不太可能 | 中 | P4 | L3 |

### 14.2 CON31-C 在锁状态下禁止销毁一个互斥体

互斥体用于保护被同时访问的共享数据。当线程因等待某互斥体而被阻塞，如果此时销毁该互斥体，则临界区和共享数据将不再受到保护。

C标准[[ISO/IEC 9899:2011][]]7.26.4.1，第2段中描述：
> `mtx_destroy` 函数释放由 `mtx` 指向的互斥体所使用的任何资源，任何等待该互斥体 `mtx` 的线程都不能被阻塞。

该描述意味着释放一个正由某个线程等待的互斥体是一种是未明确定义的行为。

#### 14.2.1 不合规代码示例

该代码示例创建几个线程，每个线程传递一个唯一数值的 ID 来调用`do_work()`函数。如果该参数值为0，则`do_work()`函数初始化一个锁互斥体；如果该参数值为`max_threads-1`，则`do_work()`函数销毁一个互斥体；当该参数值等于其他值时，`do_work()`函数执行正常处理流程。除了最后一个清理线程，每个线程在完成时均增加原子变量 `completed` 值。

不幸的是，该代码包含几个竞争条件，允许互斥体在解锁之前销毁掉。而且，不能保证在传递给`mtx_lock()`之前锁被初始化。这些行为都是未明确定义的。

```cpp
#include <stdatomic.h>
#include <stddef.h>
#include <threads.h>
 
mtx_t lock;
/* Atomic so multiple threads can modify safely */
atomic_int completed = ATOMIC_VAR_INIT(0);
enum { max_threads = 5 };
 
int do_work(void *arg) {
  int *i = (int *)arg;
 
  if (*i == 0) { /* Creation thread */
    if (thrd_success != mtx_init(&lock, mtx_plain)) {
      /* Handle error */
    }
    atomic_store(&completed, 1);
  } else if (*i < max_threads - 1) { /* Worker thread */
    if (thrd_success != mtx_lock(&lock)) {
      /* Handle error */
    }
    /* Access data protected by the lock */
    atomic_fetch_add(&completed, 1);
    if (thrd_success != mtx_unlock(&lock)) {
      /* Handle error */
    }
  } else { /* Destruction thread */
    mtx_destroy(&lock);
  }
  return 0;
}
  
int main(void) {
  thrd_t threads[max_threads];
   
  for (size_t i = 0; i < max_threads; i++) {
    if (thrd_success != thrd_create(&threads[i], do_work, &i)) {
      /* Handle error */
    }
  }
  for (size_t i = 0; i < max_threads; i++) {
    if (thrd_success != thrd_join(threads[i], 0)) {
      /* Handle error */
    }
  }
  return 0;
}
```
#### 14.2.2 合规解决方案

该解决方法在 `main()` 中创建线程之前初始化互斥体和 `join` 线程之后销毁互斥体来消除竞争条件。

```cpp
#include <stdatomic.h>
#include <stddef.h>
#include <threads.h>
 
mtx_t lock;
/* Atomic so multiple threads can increment safely */
atomic_int completed = ATOMIC_VAR_INIT(0);
enum { max_threads = 5 };
 
int do_work(void *dummy) {
  if (thrd_success != mtx_lock(&lock)) {
    /* Handle error */
  }
  /* Access data protected by the lock */
  atomic_fetch_add(&completed, 1);
  if (thrd_success != mtx_unlock(&lock)) {
    /* Handle error */
  }
 
  return 0;
}
 
int main(void) {
  thrd_t threads[max_threads];
   
  if (thrd_success != mtx_init(&lock, mtx_plain)) {
    /* Handle error */
  }
  for (size_t i = 0; i < max_threads; i++) {
    if (thrd_success != thrd_create(&threads[i], do_work, NULL)) {
      /* Handle error */
    }
  }
  for (size_t i = 0; i < max_threads; i++) {
    if (thrd_success != thrd_join(threads[i], 0)) {
      /* Handle error */
    }
  }
 
  mtx_destroy(&lock);
  return 0;
}
```

#### 14.2.3 风险评估

在加锁状态时销毁一个互斥体可能会导致非法控制流和数据破坏。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON31-C | 中 | 很可能 | 高 | P4 | L3 |

#### 14.2.4 相关指南

| 文献 |  条款 |
| -- | -- |
| MITRE CWE | CWE-667, Improper Locking |

#### 14.2.5 参考文献

| 文献 |  条款 |
| -- | -- |
|[ISO/IEC 9899:2011]    |7.26.4.1, "The mtx_destroy Function"|

### 14.3 CON32-C 多线程访问位域时防止数据冲突

在访问一个位域时，一个线程可能会无意地访问临近内存区中一个单独的位域。这是因为编译器在填充一个存储单元时按要求在一个存储单元中存储多个临近位域。因此，数据冲突可能不仅存在于多线程访问一个位域，而且可能存在于共享一个字节或双字节访问其他位域。一个类似问题[CON43-C 多线程代码不允许数据竞争[]]讨论过，但是本规则描述的问题是更难于诊断，因为相同的内存位置多个线程都能够修改而导致该问题原因不是显而易见。

一个避免数据冲突的方法是在并发程序设计中使用一个互斥体。当所有线程都正确遵守时，互斥体能够对共享对象提供安全可靠的访问。然而，如果访问线程在没有获取到互斥体时而访问被（互斥体所）保护的对象，那么该互斥体是无法给该对象提供任何保证。不幸的是，没有一个跨平台的方法来判断临近位域是否存储在合适位域的附近。

另一个方法是在任何两个位域之间插入一个非位域成员来保证每个位域在其存储单元中都是唯一访问对象。这个技术有效地保证没有两个位域可以同时访问。

#### 14.3.1 不合规代码示例（位域）

临近位域可能存储在一个单独的内存单元。因此在不同线程中修改一个临近位域是一个未定义的行为，如下面代码所示：

```cpp
struct multi_threaded_flags {
  unsigned int flag1 : 2;
  unsigned int flag2 : 2;
};
 
struct multi_threaded_flags flags;
 
int thread1(void *arg) {
  flags.flag1 = 1;
  return 0;
}
 
int thread2(void *arg) {
  flags.flag2 = 2;
  return 0;
}
```

在C标准[[ISO/IEC 9899:2011][]]第三章，3.14描述：

>提示2：位域及其临近非位域成员位于独立的存储单元中。该规则同样应用于这样两个位域：如果一个位域在嵌套数据结构中定义，而另一个位域不是；或者两个位域由0长度位域隔离开；或者两个位域由非位域成员隔离开。如果相同数据结构的两个非原子位域之间所有成员也是位域（长度非0）的，不管这些成员大小，并发更新两个非原子位域是不安全的。

例如，下面指令顺序也是可能的：

>Thread 1: register 0 = flags
Thread 1: register 0 &= ~mask(flag1)
Thread 2: register 0 = flags
Thread 2: register 0 &= ~mask(flag2)
Thread 1: register 0 |= 1 << shift(flag1)
Thread 1: flags = register 0
Thread 2: register 0 |= 2 << shift(flag2)
Thread 2: flags = register 0

#### 14.3.2 合规解决方案（位域, C11, 互斥体）

该解决方案使用互斥体保护 `flags` 的所有访问，因此可以避免任何数据冲突。

```cpp
#include <threads.h>
 
struct multi_threaded_flags {
  unsigned int flag1 : 2;
  unsigned int flag2 : 2;
};
 
struct mtf_mutex {
  struct multi_threaded_flags s;
  mtx_t mutex;
};
 
struct mtf_mutex flags;
 
int thread1(void *arg) {
  if (thrd_success != mtx_lock(&flags.mutex)) {
    /* Handle error */
  }
  flags.s.flag1 = 1;
  if (thrd_success != mtx_unlock(&flags.mutex)) {
    /* Handle error */
  }
  return 0;
}
  
int thread2(void *arg) {
  if (thrd_success != mtx_lock(&flags.mutex)) {
    /* Handle error */
  }
  flags.s.flag2 = 2;
  if (thrd_success != mtx_unlock(&flags.mutex)) {
    /* Handle error */
  }
  return 0;
}
```
#### 14.3.3 合规解决方案（C11）

在该解决方法中，两个线程同时修改结构体中两个不同的非位域成员。因为成员占用内存不同字节，因此并发保护是不需要的。

```cpp
struct multi_threaded_flags {
  unsigned char flag1;
  unsigned char flag2;
};
  
struct multi_threaded_flags flags;
  
int thread1(void *arg) {
  flags.flag1 = 1;
  return 0;
}
 
int thread2(void *arg) {
  flags.flag2 = 2;
  return 0;
}
```

与C99不同，C11 [[ISO/IEC 9899:2011][]] 显式地定义内存位置，而且在副条款 3.14.2 中给出如下提示：

>**提示1**：两个线程的执行能够更新和访问不同内存位置而不互相干扰。

几乎可以肯定 `flag1` 和 `flag2` 存在一个相同的双字节中。使用遵守 C99 或更早标准的编译器，如果两个内存分配发生在线程调度交叉时，那么两个存储会相邻，那么仍然存在仅有一个 flag 会按要求被设置的可能。另一个 `flag` 会存储其以前值因为两个成员是由一个双字节表示的，这是处理器工作的最小存储单元。在 C 标准修改至 C11 之前，没有方法保证这些 `flag` 能够并发修改。

#### 14.3.4 风险评估

尽管冲突窗口较窄，因为错误数据解析导致一个损坏运行状态或一次非预期信息暴露，内存可能会错误分配或者表达式可能被错误计算。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON32-C | 中 | 很可能 | 中 | P8 | L2 |

#### 14.3.5 参考文献

| 文献 | 条款 |
| -- | -- | 
|[ISO/IEC 9899:2011]|    3.14, "Memory Location"|

### 14.4 CON33-C 使用库函数时避免竞争条件
某些 C 标准库函数不能保证对于线程是可重入的。比如 `strtok()` 和 `asctime()` 函数返回一个指针，该指针指向的结果存储在函数所申请内存中，该内存是基于每个进程的。其他函数比如 `rand()` 将状态信息存储在函数申请内存中，该内存也是基于每个进程的。多个线程调用相同函数会导致并发问题，该问题经常导致异常行为，而且可能会导致更严重缺陷，比如异常退出、拒绝服务攻击和数据完整性不一致。

根据 C 标准，下表列举库函数在多线程调用时可能会导致数据竞争：

| Functions |    Remediation |
| -- | -- |
|rand(), srand()|    MSC30-C. 禁止使用rand()生成伪随机数|
|getenv(), getenv_s()|    ENV34-C. 禁止存储某些函数返回的指针|
|strtok()|    C11 Annex K中的strtok_s()<br>POSIX中的strtok_r()|
|strerror()|    C11 Annex K中的strerror_s()<br>POSIX中的strerror_r()|
|asctime(), ctime(),<br>localtime(), gmtime()|    C11 AnnexK中的asctime_s(), ctime_s(),<br>localtime_s(), gmtime_s()|
|setlocale()|    用一个互斥锁保护多线程访问特定于本地特性的函数|
|ATOMIC_VAR_INIT, atomic_init()|    禁止多线程试图初始化同一个原子变量|
|tmpnam()|    C11 Annex K中tmpnam_s()<br>POSIX中的tmpnam_r()|
|mbrtoc16(), c16rtomb(),<br>mbrtoc32(), c32rtomb()|    禁止调用mbstate_t*类型NULL参数|

在可移植性操作系统接口（POSIX）2.9.1章节，基本规范问题7[[IEEE Std 1003.1:2013][]]扩展函数列表，这些函数不要求线程安全。

#### 14.4.1 不合规代码示例

在该代码示例中，函数 `f()` 是在一个多线程进程中被调用，但是f()调用一个系统函数时遇到一个错误。`strerror()` 函数返回一个错误码对应的可读字符串。在C标准[[ISO/IEC 9899:2011][]]第7.24.6.2节，明确描述 `strerror()` 不需要避免数据冲突。`strerror()` 一种实现可以将错误字符串写入一个静态数组并返回一个指针指向该静态数组，该数组可被其他线程读取和修改。

```cpp
#include <errno.h>
#include <stdio.h>
#include <string.h>
 
void f(FILE *fp) {
  fpos_t pos;
  errno = 0;
 
  if (0 != fgetpos(fp, &pos)) {
    char *errmsg = strerror(errno);
    printf("Could not get the file position: %s\n", errmsg);
  }
}
```

该代码首先设置 `errno` 为 0 以遵守 ERR30-C。在调用会设置错误码的库函数之前，设置 `errno` 为 0 。只有在函数返回一个值提示错误之后再检查 `errno` 值。

#### 14.4.2 合规解决方案（Annex K, strerror_s()）

该解决方法采用 C 标准附录K使用 `strerror_s()` 函数，该函数功能与 `strerror()`相同但保证线程安全。

```cpp
#define __STDC_WANT_LIB_EXT1__ 1
#include <errno.h>
#include <stdio.h>
#include <string.h>
 
enum { BUFFERSIZE = 64 };
void f(FILE *fp) {
  fpos_t pos;
  errno = 0;
 
  if (0 != fgetpos(fp, &pos)) {
    char errmsg[BUFFERSIZE];
    if (strerror_s(errmsg, BUFFERSIZE, errno) != 0) {
      /* Handle error */
    }
    printf("Could not get the file position: %s\n", errmsg);
  }
}
```

附录K是可选的，因此`strerror_s()`不一定在所有库实现中都可用。

#### 14.4.3 合规解决方案（POSIX,strerror_r()）

该解决方法使用POSIX `strerror_r()` 函数，该函数与 `strerror()` 功能相同但保证线程安全。

```cpp
#include <errno.h>
#include <stdio.h>
#include <string.h>
 
enum { BUFFERSIZE = 64 };
 
void f(FILE *fp) {
  fpos_t pos;
  errno = 0;
 
  if (0 != fgetpos(fp, &pos)) {
    char errmsg[BUFFERSIZE];
    if (strerror_r(errno, errmsg, BUFFERSIZE) != 0) {
      /* Handle error */
    }
    printf("Could not get the file position: %s\n", errmsg);
  }
}
```

Linux提供两个版本的 `strerror_r()`，XSI（X/Open System Interface）兼容版本和GNU指定版本。该解决方法假定是XSI兼容版本，当应用程序要求按POSIX进行编译时（也就是由 `_POSIX_C_SOURCE` 或 `_XOPEN_SOURCE` 合适地定义），`strerror_r()`是默认具备的。`strerror_r()`操作页面列举在特定操作系统可用的版本。

#### 14.4.4 风险评估

多线程调用相同库函数引起的竞争条件可能会导致进程异常退出、数据完整性破坏或拒绝服务攻击。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON33-C | 中 | 很可能 | 高 | P4 | L3 |

#### 14.4.5 相关指南

| 文献 | 条款|
| -- | -- | 
|CERT C Secure Coding Standard|    ERR30-C. Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure |
|SEI CERT C++ Coding Standard|    CON00-CPP. Avoid assuming functions are thread safe unless otherwise specified|

#### 14.4.6 参考文献

| 文献 | 条款 |
| -- | -- | 
|[IEEE Std 1003.1:2013]    |Section 2.9.1, "Thread Safety"|
|[ISO/IEC 9899:2011]    |Subclause 7.24.6.2, "The strerror Function" |
|[Open Group 1997b]    |Section 10.12, "Thread-Safe POSIX.1 and| C-Language Functions"

### 14.5 CON34-C 为线程共享对象声明恰当的存储生命周期

从一个线程访问另一个线程自动变量或者线程本地变量的行为是由实现定义的，因为多线程在同步模型约束下可能是相互交叉运行，该行为会引起非法内存访问。因此，当其他线程试图访问本线程的栈指针或线程本地变量时，本线程的栈指针或线程本地变量可能不再合法。共享静态变量可以由线程同步机制保护。

然而，因为被引用的栈指针的线程可能被停止执行，自动（本地）变量是无法以相同方式来共享的，或者通过其他机制来保证被引用栈指针一直合法。线程不要访问其他线程的自动或者本地对象，除非该线程的对象已经被本线程所关联。当数据在线程间未共享时，可以查看DCL30-C.声明恰当存储生命周期的对象来获取如何声明恰当存储生命周期的对象。

#### 14.5.1 不合规代码示例（自动存储周期）

该错误代码示例将变量地址传递给子线程，子线程将变量值打印出来。该变量有自动存储周期。依赖于线程执行顺序，子线程可能在父线程的变量声明周期之后引用该变量地址。这样就会导致子线程访问非法内存位置。

```cpp
#include <threads.h>
#include <stdio.h>
 
int child_thread(void *val) {
  int *res = (int *)val;
  printf("Result: %d\n", *res);
  return 0;
}
 
void create_thread(thrd_t *tid) {
  int val = 1;
  if (thrd_success != thrd_create(tid, child_thread, &val)) {
    /* Handle error */
  }
}
 
int main(void) {
  thrd_t tid;
  create_thread(&tid);
   
  if (thrd_success != thrd_join(tid, NULL)) {
    /* Handle error */
  }
  return 0;
}
```

#### 14.5.2 不合规代码示例（自动存储周期）

一个解决方案是保证线程间共享的具有自动存储周期的所有对象在其声明时要求将其生命周期扩展至所有线程生命周期。使用线程同步机制比如 `thrd_join()`可以实现这个要求。在该代码示例中，`main()`函数声明`val`，然后调用 `thrd_join()`。父线程在继续执行前等待子线程完成，因此该共享对象至少拥有与该子线程相同的生命周期。然而，该示例依赖于实现定义行为而且不可移植。

```cpp
#include <threads.h>
#include <stdio.h>
 
int child_thread(void *val) {
  int *result = (int *)val;
  printf("Result: %d\n", *result);  /* Correctly prints 1 */
  return 0;
}
  
void create_thread(thrd_t *tid, int *val) {
  if (thrd_success != thrd_create(tid, child_thread, val)) {
    /* Handle error */
  }
}
  
int main(void) {
  int val = 1;
  thrd_t tid;
  create_thread(&tid, &val);
  if (thrd_success != thrd_join(tid, NULL)) {
    /* Handle error */
  }
  return 0;
}
```

#### 14.5.3 合规解决方案（静态存储生命周期）

该解决方法将值存储在具有静态存储生命周期对象中。该对象声明周期是进程的整个执行过程，因此，它可被任何线程安全访问。

```cpp
#include <threads.h>
#include <stdio.h>
 
int child_thread(void *v) {
  int *result = (int *)v;
  printf("Result: %d\n", *result);  /* Correctly prints 1 */
  return 0;
}
  
void create_thread(thrd_t *tid) {
  static int val = 1;
  if (thrd_success != thrd_create(tid, child_thread, &val)) {
    /* Handle error */
  }
}
  
int main(void) {
  thrd_t tid;
  create_thread(&tid);
  if (thrd_success != thrd_join(tid, NULL)) {
    /* Handle error */
  }
  return 0;
}
```

#### 14.5.4 合适解决方法（已分配存储生命周期）

该解决方法将传递给子线程的值存储在动态申请的对象中。该对象在释放前会一直存在，因此子线程能够安全访问该值。

```cpp
#include <threads.h>
#include <stdio.h>
#include <stdlib.h>
 
int child_thread(void *val) {
  int *result = (int *)val;
  printf("Result: %d\n", *result); /* Correctly prints 1 */
  return 0;
}
  
void create_thread(thrd_t *tid, int *value) {
  *value = 1;
  if (thrd_success != thrd_create(tid, child_thread,
                                  value)) {
    /* Handle error */
  }
}
  
int main(void) {
  thrd_t tid;
  int *value = (int *)malloc(sizeof(int));
  if (!value) {
    /* Handle error */
  }
  create_thread(&tid, value);
  if (thrd_success != thrd_join(tid, NULL)) {
    /* Handle error */
  }
  free(value);
  return 0;
}
```

#### 14.5.5 不合规代码示例（线程相关存储）

在该示例代码中，将值存储在父线程的线程相关存储中。但是线程相关存储数据仅对存储数据的线程可用，因此`child_thread()`函数会将 `result` 设置为 NULL 值。

```cpp
#include <threads.h>
#include <stdio.h>
#include <stdlib.h>
 
static tss_t key;
 
int child_thread(void *v) {
  void *result = tss_get(*(tss_t *)v);
  printf("Result: %d\n", *(int *)result);
  return 0;
}
  
int create_thread(void *thrd) {
  int *val = (int *)malloc(sizeof(int));
  if (val == NULL) {
    /* Handle error */
  }
  *val = 1;
  if (thrd_success != tss_set(key, val)) {
    /* Handle error */
  }
  if (thrd_success != thrd_create((thrd_t *)thrd,
                                  child_thread, &key)) {
    /* Handle error */
  }
  return 0;
}
 
int main(void) {
  thrd_t parent_tid, child_tid;
 
  if (thrd_success != tss_create(&key, free)) {
    /* Handle error */
  }
  if (thrd_success != thrd_create(&parent_tid, create_thread,
                                  &child_tid)) {
    /* Handle error */
  }
  if (thrd_success != thrd_join(parent_tid, NULL)) {
    /* Handle error */
  }
  if (thrd_success != thrd_join(child_tid, NULL)) {
    /* Handle error */
  }
  tss_delete(key);
  return 0;
} 
```

#### 14.5.6 合规解决方案（线程相关存储）

该解决方案举例说明线程相关存储如何与线程机制的函数调用相结合，比如`thrd_join()`。父线程会在继续执行之前等待子线程完成，因此子线程能够保证访问到合法的对象。

```cpp
#include <threads.h>
#include <stdio.h>
#include <stdlib.h>
 
static tss_t key;
 
int child_thread(void *v) {
  int *result = v;
  printf("Result: %d\n", *result); /* Correctly prints 1 */
  return 0;
}
 
int create_thread(void *thrd) {
  int *val = (int *)malloc(sizeof(int));
  if (val == NULL) {
    /* Handle error */
  }
  *val = 1;
  if (thrd_success != tss_set(key, val)) {
    /* Handle error */
  }
  /* ... */
  void *v = tss_get(key);
  if (thrd_success != thrd_create((thrd_t *)thrd,
                                   child_thread, v)) {
    /* Handle error */
  }
  return 0;
}
 
int main(void) {
  thrd_t parent_tid, child_tid;
 
  if (thrd_success != tss_create(&key, free)) {
  /* Handle error */
  }
  if (thrd_success != thrd_create(&parent_tid, create_thread,
                                  &child_tid)) {
    /* Handle error */
  }
  if (thrd_success != thrd_join(parent_tid, NULL)) {
    /* Handle error */
  }
  if (thrd_success != thrd_join(child_tid, NULL)) {
    /* Handle error */
  }
  tss_delete(key);
return 0;
} 
```

该解决方案使用指针向整数（pointer-to-integer）和整数向指针（integer-to-pointer）转换，这是实现定义行为。（参考INT36-C.将指针转为整数或整数转为指针）。

#### 14.5.7 合规解决方案（线程本地存储, Windows, Visual Studio）

类似于前一个解决方案，该解决方案结合线程同步并使用线程本地存储以确保子线程来访问一个合法的对象。该方案使用 `Visual Studio`相关的 `__declspec(thread)` 语言扩展来提供线程本地存储，使用 `WaitForSingleObject()` API来提供同步。

```cpp
#include <Windows.h>
#include <stdio.h>
 
DWORD WINAPI child_thread(LPVOID v) {
  int *result = (int *)v;
  printf("Result: %d\n", *result);  /* Correctly prints 1 */
  return NULL;
}
 
int create_thread(HANDLE *tid) {
  /* Declare val as a thread-local value */
  __declspec(thread) int val = 1;
  *tid = create_thread(NULL, 0, child_thread, &val, 0, NULL);
  return *tid == NULL;
}
 
int main(void) {
  HANDLE tid;
 
  if (create_thread(&tid)) {
    /* Handle error */
  }
 
  if (WAIT_OBJECT_0 != WaitForSingleObject(tid, INFINITE)) {
    /* Handle error */
  }
  CloseHandle(tid);
 
  return 0;
}
```

#### 14.5.8 不合规代码示例（OpenMP, parallel）

非常重要一点是，当使用别的线程接口时其他线程可安全使用该线程的本地数据，因此程序员在线程共享数据时不需要总是将数据拷贝至非本地内存。
例如，在The OpenMP® API Specification for Parallel Programming [OpenMP]中 `shared` 关键字可与OpenMP线程接口结合起来使用，以便共享本地内存而不需要担心本地自动变量是否合法。在该示例代码中，变量 `j` 在`parallel#pragma`外部声明而不是一个私有变量。在OpenMP中，`parallel #pragma`外部变量是共享的，除非指定为`private`。

```cpp
#include <omp.h>
#include <stdio.h>
 
int main(void) {
  int j = 0;
  #pragma omp parallel
  {
    int t = omp_get_thread_num();
    printf("Running thread - %d\n", t);
    for (int i = 0; i < 5050; i++) {
    j++; /* j not private; could be a race condition */
    }
    printf("Just ran thread - %d\n", t);
    printf("loop count %d\n", j);
  }
return 0;
}
```

#### 14.5.9 合规解决方案（OpenMP, parallel, private ）
在该解决方法中，变量`j`在`parallel#pragma`外部定义，但被显式指定为`private`：

```cpp
#include <omp.h>
#include <stdio.h>
 
int main(void) {
  int j = 0;
  #pragma omp parallel private(j)
  {
    int t = omp_get_thread_num();
    printf("Running thread - %d\n", t);
    for (int i = 0; i < 5050; i++) {
    j++;
    }
    printf("Just ran thread - %d\n", t);
    printf("loop count %d\n", j);
  }
return 0;
}
```

#### 14.5.10 风险评估

引用其他线程栈的线程可能会覆盖栈上重要信息，比如函数指针和返回地址。如果程序员允许一个线程访问另一个线程本地变量，编译器不一定提示告警信息，因此，程序员无法在编译时捕捉到潜在的错误。分析工具很难诊断出并发和竞争条件的问题，因此该错误补救代价是很高的。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON34-C | 中 | 很可能 | 高 | P4 | L3 |

#### 14.5.11 相关指南

|文献|条款|
|--|--|
|CERT C Secure Coding Standard|    DCL30-C. Declare objects with appropriate storage durations|

#### 14.5.12 参考文献

|文献|条款|
|--|--|
|[ISO/IEC 9899:2011]|    6.2.4, "Storage Durations of Objects"|
|[OpenMP]|    The OpenMP® API Specification for Parallel Programming|


### 14.6 CON35-C 以预定义顺序加锁以避免死锁

互斥体用于阻止多线程同时访问共享资源而导致数据冲突。有时候，多线程都在获取锁，而且线程之间持有彼此所需要的锁，然后进程就会死锁。死锁的产生依赖于四个条件：

- 互斥
- 持有和等待
- 无抢占
- 循环等待

死锁需要同时满足这四个条件，因此阻止死锁只要阻止四个条件中任何一个即可。一个简单解决方法就是以预定义顺序锁住互斥体，这样避免循环等待。

#### 14.6.1 不合规代码示例

该示例代码行为依赖于运行时环境和平台调度。如果线程 `thr1` 试图锁住 `ba2` 的互斥体，与此同时线程 `thr2` 在`deposit()` 函数中试图锁住 `ba1` 互斥体，那么该程序很可能会死锁。

```cpp
#include <stdlib.h>
#include <threads.h>
 
typedef struct {
  int balance;
  mtx_t balance_mutex;
} bank_account;
 
typedef struct {
  bank_account *from;
  bank_account *to;
  int amount;
} transaction;
 
void create_bank_account(bank_account **ba,
                         int initial_amount) {
  bank_account *nba = (bank_account *)malloc(
    sizeof(bank_account)
  );
  if (nba == NULL) {
    /* Handle error */
  }
 
  nba->balance = initial_amount;
  if (thrd_success
      != mtx_init(&nba->balance_mutex, mtx_plain)) {
    /* Handle error */
  }
 
  *ba = nba;
}
 
int deposit(void *ptr) {
  transaction *args = (transaction *)ptr;
 
  if (thrd_success != mtx_lock(&args->from->balance_mutex)) {
    /* Handle error */
  }
 
  /* Not enough balance to transfer */
  if (args->from->balance < args->amount) {
    if (thrd_success
        != mtx_unlock(&args->from->balance_mutex)) {
      /* Handle error */
    }
    return -1; /* Indicate error */
  }
  if (thrd_success != mtx_lock(&args->to->balance_mutex)) {
    /* Handle error */
  }
 
  args->from->balance -= args->amount;
  args->to->balance += args->amount;
 
  if (thrd_success
      != mtx_unlock(&args->from->balance_mutex)) {
    /* Handle error */
  }
 
  if (thrd_success
      != mtx_unlock(&args->to->balance_mutex)) {
    /* Handle error */
  }
 
  free(ptr);
  return 0;
}
 
int main(void) {
  thrd_t thr1, thr2;
  transaction *arg1;
  transaction *arg2;
  bank_account *ba1;
  bank_account *ba2;
 
  create_bank_account(&ba1, 1000);
  create_bank_account(&ba2, 1000);
 
  arg1 = (transaction *)malloc(sizeof(transaction));
  if (arg1 == NULL) {
    /* Handle error */
  }
  arg2 = (transaction *)malloc(sizeof(transaction));
  if (arg2 == NULL) {
    /* Handle error */
  }
  arg1->from = ba1;
  arg1->to = ba2;
  arg1->amount = 100;
 
  arg2->from = ba2;
  arg2->to = ba1;
  arg2->amount = 100;
 
  /* Perform the deposits */
  if (thrd_success
     != thrd_create(&thr1, deposit, (void *)arg1)) {
    /* Handle error */
  }
  if (thrd_success
      != thrd_create(&thr2, deposit, (void *)arg2)) {
    /* Handle error */
  }
  return 0;
} 
```

#### 14.6.2 合规解决方案

该解决方案通过在`deposit()`函数中以建立预定义顺序加锁的方式来消除循环等待条件。每个线程基于 `bank_account ID`来加锁，该ID在`bank_account struct`初始化时设置。

```cpp
#include <stdlib.h>
#include <threads.h>
 
typedef struct {
  int balance;
  mtx_t balance_mutex;
 
  /* Should not change after initialization */
  unsigned int id;
} bank_account;
 
typedef struct {
  bank_account *from;
  bank_account *to;
  int amount;
} transaction;
 
unsigned int global_id = 1;
 
void create_bank_account(bank_account **ba,
                         int initial_amount) {
  bank_account *nba = (bank_account *)malloc(
    sizeof(bank_account)
  );
  if (nba == NULL) {
    /* Handle error */
  }
 
  nba->balance = initial_amount;
  if (thrd_success
      != mtx_init(&nba->balance_mutex, mtx_plain)) {
    /* Handle error */
  }
 
  nba->id = global_id++;
  *ba = nba;
}
 
int deposit(void *ptr) {
  transaction *args = (transaction *)ptr;
  int result = -1;
  mtx_t *first;
  mtx_t *second;
 
  if (args->from->id == args->to->id) {
    return -1; /* Indicate error */
  }
 
  /* Ensure proper ordering for locking */
  if (args->from->id < args->to->id) {
    first = &args->from->balance_mutex;
    second = &args->to->balance_mutex;
  } else {
    first = &args->to->balance_mutex;
    second = &args->from->balance_mutex;
  }
  if (thrd_success != mtx_lock(first)) {
    /* Handle error */
  }
  if (thrd_success != mtx_lock(second)) {
    /* Handle error */
  }
 
  /* Not enough balance to transfer */
  if (args->from->balance >= args->amount) {
    args->from->balance -= args->amount;
    args->to->balance += args->amount;
    result = 0;
  }
 
  if (thrd_success != mtx_unlock(second)) {
    /* Handle error */
  }
  if (thrd_success != mtx_unlock(first)) {
    /* Handle error */
  }
  free(ptr);
  return result;
} 
```

#### 14.6.3 风险评估

死锁会阻止多线程运行、进程停止执行。如果攻击者制造死锁条件，可能会导致拒绝服务攻击。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON35-C | 低 | 很可能 | 中 | P4 | L3 |

#### 14.6.4 相关指南

| 文献 | 条款 |
| -- | -- | 
|CERT Oracle Secure Coding Standard for Java|    LCK07-J. Avoid deadlock by requesting and releasing locks in the same order|
|MITRE CWE|    CWE-764, Multiple Locks of a Critical Resource|

### 14.7 CON36-C 将意外唤醒的函数封装在循环中

函数 `cnd_wait()` 和 `cnd_timedwait()` 会临时地放弃拥有一个互斥体，因此其他正在请求该互斥体的线程会继续执行。这些函数必须在一个互斥体保护的代码中调用。这些等待线程只能在被通知后继续执行，该通知通常是由其他线程调用 `cnd_signal()` 或 `cnd_broadcast()` 函数来触发。`cnd_wait()`函数必须是在循环中调用，该循环检查是否持有条件谓词。条件谓词是一个由函数变量组成的表达式，当该表达式必须是真时，则线程允许继续执行。当线程由 `cnd_wait()`, `cnd_timedwait()`或其他机制停止执行，若条件谓词为真且被通知之后，则该线程继续执行。

```cpp
#include <threads.h>
#include <stdbool.h>
  
extern bool until_finish(void);
extern mtx_t lock;
extern cnd_t condition;
  
void func(void) {
  if (thrd_success != mtx_lock(&lock)) {
    /* Handle error */
  }
 
  while (until_finish()) {  /* Predicate does not hold */
    if (thrd_success != cnd_wait(&condition, &lock)) {
      /* Handle error */
    }
  }
  
  /* Resume when condition holds */
 
  if (thrd_success != mtx_unlock(&lock)) {
    /* Handle error */
  }
}
```

通知机制通知等待线程，允许等待线程去检查条件谓词。一个线程调用 `cnd_broadcast()` 并不能准确地确定哪个等待线程会被恢复执行。条件谓词声明允许被通知线程决定它们在接收该通知是否继续执行。

#### 14.7.1 不合规代码示例

该示例代码监控一个链表，当该链表非空时，则将其分配给线程使用。该线程使用 `cnd_wait()`暂停执行；当被通知后，若链表有元素可用时则继续执行。即使链表是空的，线程也是可能被通知的，可能是因为通知线程使用`cnd_broadcast()`函数，该函数可通知所有线程。使用`cnd_broadcast()` 通知经常是优于使用`cnd_signal()`。（参考CON38-C. 使用条件变量时确保线程安全和存活以获取更多信息）。

通常情况下在循环中通常情况下条件谓词是条件表达式的否定值。在该不合规示例代码中，从链表中删除一个元素的条件谓词是 `(list->next != NULL)`，然而在while循环条件中条件表达式是 `(list->next == NULL)`.

该示例代码中在`if`代码块中嵌套`cnd_wait()`函数，因此在接收到通知之后检查条件谓词失败。如果该通知是伪造的或者恶意的，该线程就会过早地被唤醒。

```cpp
#include <stddef.h>
#include <threads.h>
 
struct node_t {
  void *node;
  struct node_t *next;
};
  
struct node_t list;
static mtx_t lock;
static cnd_t condition;
  
void consume_list_element(void) {
  if (thrd_success != mtx_lock(&lock)) {
    /* Handle error */
  }
  
  if (list.next == NULL) {
    if (thrd_success != cnd_wait(&condition, &lock)) {
      /* Handle error */
    }
  }
 
  /* Proceed when condition holds */
 
  if (thrd_success != mtx_unlock(&lock)) {
    /* Handle error */
  }
}
```

#### 14.7.2 合规解决方案
该解决方法在`while`循环中调用`cnd_wait()`函数以便能够在`cnd_wait()`调用之前和之后检查该条件。

```cpp
#include <stddef.h>
#include <threads.h>
 
struct node_t {
  void *node;
  struct node_t *next;
};
  
struct node_t list;
static mtx_t lock;
static cnd_t condition;
  
void consume_list_element(void) {
  if (thrd_success != mtx_lock(&lock)) {
    /* Handle error */
  }
  
  while (list.next == NULL) {
    if (thrd_success != cnd_wait(&condition, &lock)) {
      /* Handle error */
    }
  }
 
  /* Proceed when condition holds */
 
  if (thrd_success != mtx_unlock(&lock)) {
    /* Handle error */
  }
}
```

#### 14.7.3 风险评估

在`while`循环中对`cnd_wait()`或`cnd_timedwait()`函数调用封装失效会导致无限阻塞和拒绝服务攻击。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON36-C | 低 | 不太可能 | 中 | P2 | L3 |

#### 14.7.4 相关指南

| 文献 | 条款 |
| -- | -- | 
|CERT Oracle Secure Coding Standard for Java|    THI03-J. Always invoke wait() and await() methods inside a loop|

#### 14.7.5 参考文献

| 文献 | 条款 |
| -- | -- | 
|[ISO/IEC 9899:2011]|    7.17.7.4, "The atomic_compare_exchange Generic Functions"|
|[Lea 2000]|1.3.2, "Liveness" <br>3.2.2, "Monitor Mechanics"|

### 14.8 CON37-C 多线程程序禁止调用`signal()`

在多线程程序中调用`signal()`函数的行为是未知的。（参考未定义行为135）

#### 14.8.1 不合规代码示例

该示例代码在多线程程序中调用`signal()`函数。

```cpp
#include <signal.h>
#include <stddef.h>
#include <threads.h>
 
volatile sig_atomic_t flag = 0;
 
void handler(int signum) {
  flag = 1;
}
 
/* Runs until user sends SIGUSR1 */
int func(void *data) {
  while (!flag) {
    /* ... */
  }
  return 0;
}
 
int main(void) {
  signal(SIGUSR1, handler); /* Undefined behavior */
  thrd_t tid;
   
  if (thrd_success != thrd_create(&tid, func, NULL)) {
    /* Handle error */
  }
  /* ... */
  return 0;
}
```

提示：SIGUSR1 信号值在C标准中是未定义的；因此这不是一个遵守 C 标准的代码。

#### 14.8.2 合规解决方案

该解决方案使用 `atomic_bool` 类型对象来表明子线程应结束其循环的时间点。

```cpp
#include <stdatomic.h>
#include <stdbool.h>
#include <stddef.h>
#include <threads.h>
 
atomic_bool flag = ATOMIC_VAR_INIT(false);
 
int func(void *data) {
  while (!flag) {
    /* ... */
  }
  return 0;
}
 
int main(void) {
  thrd_t tid;
   
  if (thrd_success != thrd_create(&tid, func, NULL)) {
    /* Handle error */
  }
  /* ... */
  /* Set flag when done */
  flag = true;
 
  return 0;
}
```

#### 14.8.3 例外

**CON37-C-EX1**: 对多线程程序使用用户定义的信号处理函数提供已定义行为的实现，如 POSIX 被该规则排除在外。[[IEEE Std 1003.1-2013][]].

#### 14.8.4 风险评估

混合信号和多线程引起不确定行为。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON37-C | 低 | 很可能 | 低 | P6 | L2 |

#### 14.8.5 参考文献
| 文献 | 条款 |
| -- | -- | 
|[IEEE Std 1003.1-2013]|    XSH 2.9.1, "Thread Safety"|

### 14.9 CON38-C 使用条件变量时确保线程安全和存活

当使用条件变量时，需要同时关注其线程安全性和存活性。线程安全属性要求所有对象在多线程环境中保持一致的状态[[Lea 2000][]]。存活属性要求无中断地执行完成每个操作或函数调用，比如无死锁。

条件变量必须在 while循环中使用 (参考CON36-C. 将异常唤醒的函数封装在循环中获取更多信息)。为了保证变量存活性，程序在调用`cnd_wait()` 函数前必须要检测 `while` 循环条件。该早期检测检查其它线程是否已经满足条件谓词和发送通知。在已经发送通知之后调用 `cnd_wait()` 函数会导致无限阻塞。

为了保证线程安全，程序必须在从 `cnd_wait()` 函数返回之后检查 `while`循环条件。当一个给定线程调用`cnd_wait()`函数时，该线程尝试进入阻塞直到其条件变量由调用`cnd_broadcast()`或`cnd_signal()`函数通知。

每次`cnd_signal()`函数调用仅唤醒因特定条件变量而阻塞的多个线程之一。如果多个线程在等待相同条件变量，那么调度器选择其中任何之一来唤醒（假设所有线程具有相同优先级）。每次`cnd_broadcast()`函数调用唤醒因特定条件变量而阻塞所有线程。由`cnd_broadcast()`函数调用而唤醒多个线程的执行顺序是不确定的。因此，即使一个不相干的线程本该处于休眠状态，但当发现其条件谓词已经满足，就开始继续执行。由于这些原因，线程在`cnd_wait()`函数返回之后必须检查其条件谓词。在调用`cnd_wait()`之前和之后检查条件谓词的最好选择就是While循环。

如果每个线程使用唯一条件变量，那么`cnd_signal()`使用是安全的。如果多个线程共享同一个条件变量，只有满足如下条件`cnd_signal()`使用才能是安全的：

- 所有线程在唤醒之后执行相同操作，这意味着每次`cnd_signal()`调用任何线程都可被选择唤醒执行。
- 在接收到信号之后仅有一个线程被要求唤醒。

如果`cnd_signal()`使用是不安全的，那么`cnd_broadcast()`函数可用来唤醒因等待同一个条件变量所有线程。. 

#### 14.9.1 不合规代码示例（cnd_signal()）

该示例代码使用5个线程，它们要求根据创建时所分配的步骤水平（step level）序列化地执行。`current_step`变量保存当前步骤水平，当对应线程执行完毕则增加该值。最终，另外线程被发送信号以便下一步骤能够执行。每个线程都在等待直到其步骤水平就绪，而且`cnd_wait()`调用被封装在`while`循环中，以便遵守CON36-C. 将异常唤醒的函数封装在循环中。

```cpp
#include <stdio.h>
#include <threads.h>
 
enum { NTHREADS = 5 };
 
mtx_t mutex;
cnd_t cond;
 
int run_step(void *t) {
  static size_t current_step = 0;
  size_t my_step = *(size_t *)t;
 
  if (thrd_success != mtx_lock(&mutex)) {
    /* Handle error */
  }
 
  printf("Thread %zu has the lock\n", my_step);
  while (current_step != my_step) {
    printf("Thread %zu is sleeping...\n", my_step);
 
    if (thrd_success != cnd_wait(&cond, &mutex)) {
      /* Handle error */
    }
 
    printf("Thread %zu woke up\n", my_step);
  }
  /* Do processing ... */
  printf("Thread %zu is processing...\n", my_step);
  current_step++;
 
  /* Signal awaiting task */
  if (thrd_success != cnd_signal(&cond)) {
    /* Handle error */
  }
 
  printf("Thread %zu is exiting...\n", my_step);
 
  if (thrd_success != mtx_unlock(&mutex)) {
    /* Handle error */
  }
  return 0;
}
int main(void) {
  thrd_t threads[NTHREADS];
  size_t step[NTHREADS];
 
  if (thrd_success != mtx_init(&mutex, mtx_plain)) {
    /* Handle error */
  }
 
  if (thrd_success != cnd_init(&cond)) {
    /* Handle error */
  }
 
  /* Create threads */
  for (size_t i = 0; i < NTHREADS; ++i) {
    step[i] = i;
 
    if (thrd_success != thrd_create(&threads[i], run_step,
                                    &step[i])) {
      /* Handle error */
    }
  }
 
  /* Wait for all threads to complete */
  for (size_t i = NTHREADS; i != 0; --i) {
    if (thrd_success != thrd_join(threads[i-1], NULL)) {
      /* Handle error */
    }
  }
 
  mtx_destroy(&mutex);
  cnd_destroy(&cond);
  return 0;
} 
```

在该示例中，所有线程共享同一个条件变量。每个线程在执行前都需要`current_step`保存一个不同的值，因此每个线程拥有自己独自的条件谓词。当该条件变量被信号通知时，任意等待线程都可以被唤醒。

下表展示一种违反存活属性的可能场景。偶然地，如果被通知线程并不是具有下一个步骤值的线程，那么该线程将继续等待。如果没有额外通知会触发，最终可用线程池将被消耗殆尽。

死锁：步骤值乱序

| Time | Thread #<br>(my_step) | current_step | Action |
| -- | -- | -- | -- | 
|0    |3|    0|    线程3第一次执行：条件谓词false -> wait()|
|1  |2|    0|  线程2第一次执行：条件谓词false -> wait()|
|2    |4|    0|    线程4第一次执行：条件谓词false -> wait()|
|3    |0|    0|    线程0第一次执行：条件谓词TRUE -> current_step++; cnd_signal()|
|4    |1|    1|    线程1第一次执行：条件谓词TRUE -> current_step++; cnd_signal()|
|5    |3|    2|    线程3唤醒（调度器选择）：条件谓词false -> wait()|
|6    |—|    —|    **线程耗尽**。没有线程能够运行，而且需要一个条件变量信号来唤醒其他线程。|
该示例代码违反存活性。

#### 14.9.2 合规解决方案（cnd_broadcast()）

该解决方法使用 `cnd_broadcast()` 函数来信号通知所有等待线程而不是某个随机线程。与不合规示例代码相比，只有 `run_step()`线程代码被修改，如下：

```cpp
#include <stdio.h>
#include <threads.h>
 
mtx_t mutex;
cnd_t cond;
int run_step(void *t) {
  static size_t current_step = 0;
  size_t my_step = *(size_t *)t;
 
  if (thrd_success != mtx_lock(&mutex)) {
    /* Handle error */
  }
 
  printf("Thread %zu has the lock\n", my_step);
 
  while (current_step != my_step) {
    printf("Thread %zu is sleeping...\n", my_step);
 
    if (thrd_success != cnd_wait(&cond, &mutex)) {
      /* Handle error */
    }
 
  printf("Thread %zu woke up\n", my_step);
  }
 
  /* Do processing ... */
  printf("Thread %zu is processing...\n", my_step);
 
  current_step++;
 
  /* Signal ALL waiting tasks */
  if (thrd_success != cnd_broadcast(&cond)) {
    /* Handle error */
  }
 
  printf("Thread %zu is exiting...\n", my_step);
 
  if (thrd_success != mtx_unlock(&mutex)) {
    /* Handle error */
  }
  return 0;
}
```

唤醒所有线程保证存活性，因为每个线程都会执行其条件谓词，而且恰好有一个会成功而继续执行。

#### 14.9.3 合规解决方案（在每个线程拥有唯一条件变量中使用`cnd_signal()`）

另一个解决方案是每个线程使用唯一条件变量（所有线程使用相同互斥体）。在这种情况下，`cnd_signal()`函数仅唤醒等待的线程。这种解决方案比使用`cnd_broadcast()` 更加高效，因为仅有一个要求的线程被唤醒。
每个被信号通知线程的条件谓词必须是真，否则会导致死锁发生。

```cpp
#include <stdio.h>
#include <threads.h>
 
enum { NTHREADS = 5 };
 
mtx_t mutex;
cnd_t cond[NTHREADS];
 
int run_step(void *t) {
  static size_t current_step = 0;
  size_t my_step = *(size_t *)t;
 
  if (thrd_success != mtx_lock(&mutex)) {
    /* Handle error */
  }
 
  printf("Thread %zu has the lock\n", my_step);
 
  while (current_step != my_step) {
    printf("Thread %zu is sleeping...\n", my_step);
 
    if (thrd_success != cnd_wait(&cond[my_step], &mutex)) {
      /* Handle error */
    }
 
    printf("Thread %zu woke up\n", my_step);
  }
 
  /* Do processing ... */
  printf("Thread %zu is processing...\n", my_step);
 
  current_step++;
 
  /* Signal next step thread */
  if ((my_step + 1) < NTHREADS) {
    if (thrd_success != cnd_signal(&cond[my_step + 1])) {
      /* Handle error */
    }
  }
 
  printf("Thread %zu is exiting...\n", my_step);
 
  if (thrd_success != mtx_unlock(&mutex)) {
    /* Handle error */
  }
  return 0;
}
 
int main(void) {
  thrd_t threads[NTHREADS];
  size_t step[NTHREADS];
 
  if (thrd_success != mtx_init(&mutex, mtx_plain)) {
    /* Handle error */
  }
 
  for (size_t i = 0; i< NTHREADS; ++i) {
    if (thrd_success != cnd_init(&cond[i])) {
      /* Handle error */
    }
  }
 
  /* Create threads */
  for (size_t i = 0; i < NTHREADS; ++i) {
    step[i] = i;
    if (thrd_success != thrd_create(&threads[i], run_step,
                                    &step[i])) {
      /* Handle error */
    }
  }
 
  /* Wait for all threads to complete */
  for (size_t i = NTHREADS; i != 0; --i) {
    if (thrd_success != thrd_join(threads[i-1], NULL)) {
      /* Handle error */
    }
  }
 
  mtx_destroy(&mutex);
 
  for (size_t i = 0; i < NTHREADS; ++i) {
    cnd_destroy(&cond[i]);
  }
  return 0;
}
```

#### 14.9.4 合规解决方案(Windows，条件变量) 
该解决方案使用`CONDITION_VARIABL`E对象，在Microsoft Windows (Vista以及之后)可用。

```cpp
#include <Windows.h>
#include <stdio.h>
  
CRITICAL_SECTION lock;
CONDITION_VARIABLE cond;
  
DWORD WINAPI run_step(LPVOID t) {
  static size_t current_step = 0;
  size_t my_step = (size_t)t;
 
  EnterCriticalSection(&lock); 
  printf("Thread %zu has the lock\n", my_step);
 
  while (current_step != my_step) {
    printf("Thread %zu is sleeping...\n", my_step);
  
    if (!SleepConditionVariableCS(&cond, &lock, INFINITE)) {
      /* Handle error */
    }
 
    printf("Thread %zu woke up\n", my_step);
  }
 
  /* Do processing ... */
  printf("Thread %zu is processing...\n", my_step);
 
  current_step++;
  
  LeaveCriticalSection(&lock);
  
  /* Signal ALL waiting tasks */
  WakeAllConditionVariable(&cond);
  
  printf("Thread %zu is exiting...\n", my_step);
  return 0;
}
  
enum { NTHREADS = 5 };
  
int main(void) {
  HANDLE threads[NTHREADS];
   
  InitializeCriticalSection(&lock);
  InitializeConditionVariable(&cond);
  
  /* Create threads */
  for (size_t i = 0; i < NTHREADS; ++i) {
    threads[i] = CreateThread(NULL, 0, run_step, (LPVOID)i, 0, NULL);
  }
  
  /* Wait for all threads to complete */
  WaitForMultipleObjects(NTHREADS, threads, TRUE, INFINITE);
  
  DeleteCriticalSection(&lock);
  
  return 0;
}
```

#### 14.9.5 风险评估

使用条件变量时无法保证线程安全和存活性会导致程序无限阻塞和拒绝服务。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON38-C | 低 | 不太可能 | 中 | P2 | L3 |

#### 14.9.6 相关指南

| 文献 | 条款 |
| -- | -- | 
|CERT Oracle Secure Coding Standard for Java|    THI02-J. Notify all waiting threads rather than a single thread|

#### 14.9.7 参考文献

| 文献 | 条款 |
| -- | -- | 
|[IEEE Std 1003.1:2013]|    XSH, System Interfaces, pthread_cond_broadcast<br>XSH, System Interfaces, pthread_cond_signal|
|[Lea 2000]    ||


### 14.10 CON39-C 禁止将曾经joined或detached的线程再次join或detach
C标准7.26.5.6[[ISO/IEC 9899:2011][]]条款描述一个曾经已经加入或分离的线程不能再次被加入。类似地，7.26.5.3条款中描述一个曾经已经加入或分离的线程不能再次被分离。违反任何一个条款或导致未知行为。

#### 14.10.1 不合规代码示例
该示例代码分离一个线程，该线程后来又加入了。

```cpp
#include <stddef.h>
#include <threads.h>
 
int thread_func(void *arg) {
  /* Do work */
  thrd_detach(thrd_current());
  return 0;
}
 
int main(void) {
  thrd_t t;
 
  if (thrd_success != thrd_create(&t, thread_func, NULL)) {
    /* Handle error */
    return 0;
  }
 
  if (thrd_success != thrd_join(t, 0)) {
    /* Handle error */
    return 0;
  }
  return 0;
}
```

#### 14.10.2 合规解决方案

该解决方法不分离线程。在成功加入主线程时，该线程相关资源都会被释放。

```cpp
#include <stddef.h>
#include <threads.h>
  
int thread_func(void *arg) {
  /* Do work */
  return 0;
}
 
int main(void) {
  thrd_t t;
 
  if (thrd_success != thrd_create(&t, thread_func, NULL)) {
    /* Handle error */
    return 0;
  }
 
  if (thrd_success != thrd_join(t, 0)) {
    /* Handle error */
    return 0;
  }
  return 0;
} 
```

#### 14.10.3 风险评估

加入或分离曾经已经加入或分离的线程是一个未知行为。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON39-C | 低 | 可能 | 中 | P6 | L2 |

#### 14.10.4 参考文献

| 文献 | 条款 |
| -- | -- | 
|[ISO/IEC 9899:2011]|Subclause 7.26.5.3, "The thrd_detach Function"<br>Subclause 7.26.5.6, "The thrd_join Function"|

### 14.11 CON40-C 在一个表达式中禁止引用一个原子变量两次

锁一致策略保证多线程不能同时访问或修改共享数据。对原子变量执行特定操作时保证线程安全，因此原子变量消除锁需求。在C标准7.17.7和7.17.8条款[[ISO/IEC 9899:2011][]]中定义了在原子变量上所执行的线程安全操作。每个原子操作能提供的线程安全性，多个原子操作的组合却无法提供。

在每次原子变量作为赋值操作的左值出现时，包括复合赋值操作，比如*=，原子变量会执行原子写操作。原子变量的加（++）或减（--）操作包括一个原子的读-写操作，因此是线程安全的。其他任何地方引用一个原子变量都意味着是一个原子读操作。

如果在一个表达式中，相同原子变量出现两次，那就需要两次原子读操作或一个原子读和一个原子写操作。这样原子操作组合不能保证线程安全，因为在两次操作之间其他线程可能会修改该原子变量。因此在同一个表达式中，一个原子变量不能被引用两次。

#### 14.11.1 不合规代码示例（atomic_bool ）

该示例代码声明一个共享`atomic_boolflag`变量，而且提供一个`toggle_flag()`方法来取反`flag`当前值。

```cpp
#include <stdatomic.h>
#include <stdbool.h>
   
static atomic_bool flag = ATOMIC_VAR_INIT(false);
   
void init_flag(void) {
  atomic_init(&flag, false);
}
   
void toggle_flag(void) {
  bool temp_flag = atomic_load(&flag);
  temp_flag = !temp_flag;
  atomic_store(&flag, temp_flag);
}
     
bool get_flag(void) {
  return atomic_load(&flag);
}
```

`flag`值被读、取反和写回，因此执行该代码可能会导致数据冲突。即使读写操作均是原子操作，数据冲突仍可能会发生。例如，考虑两个线程调用`toggle_flag()`。翻转`flag`两次预的期结果是存储原始值。但是下表场景中使`flag`处于错误状态。
`toggle_flag()` 并未**比较-交换**

| Time | flag | Thread | Action | 
| -- | -- | -- | -- | 
|1    |true|    t1|    读取flag，true当前值至缓存|
|2    |true|    t2|    读取flag，（仍然）true当前值至另外不同的缓存|
|3    |true|    t1|    将缓存中临时变量翻转至false|
|4    |true|    t2|    将另外不同缓存中临时变量翻转至false|
|5    |false|    t1|    将缓存变量值写至flag|
|6    |false|    t2|    将不同缓存中变量值写至flag|

因此，`t2`调用结果并没有反应在`flag`中；程序行为就像`toggle_flag()`仅调用一次，而不是两次。

#### 14.11.2 合规解决方案（`atomic_compare_exchange_weak()`）

该解决方案使用比较—交换来保证正确值存储在 `flag`中。所有更新对所有其他线程都是可见的。在循环中调用`atomic_compare_exchange_weak()`函数以便遵守CON41-C 将意外失败函数封装在循环中。

```cpp
#include <stdatomic.h>
#include <stdbool.h>
  
static atomic_bool flag = ATOMIC_VAR_INIT(false);
  
void init_flag(void) {
  atomic_init(&flag, false);
}
 
void toggle_flag(void) {
  bool old_flag = atomic_load(&flag);
  bool new_flag;
  do {
    new_flag = !old_flag;
  } while (!atomic_compare_exchange_weak(&flag, &old_flag, new_flag));
}
    
bool get_flag(void) {
  return atomic_load(&flag);
}
```

另一个解决方案是使用`atomic_flag`数据类型来原子化管理布尔类型值。但是`atomic_flag`不支持翻转操作。

#### 14.11.3 合规解决方案（复合赋值）

该解决方案使用^=赋值操作来翻转flag。根据C标准, 6.5.16.2,第3节，该操作是保证原子的。该操作在参数上执行按位异或操作，但是对于布尔参数，这等同于取反。

```cpp
#include <stdatomic.h>
#include <stdbool.h>
   
static atomic_bool flag = ATOMIC_VAR_INIT(false);
   
void toggle_flag(void) {
  flag ^= 1;
}
     
bool get_flag(void) {
  return flag;
}
```

另一个解决方法是使用互斥体来保护该原子操作，但是该方法失去原子操作性能优势。

#### 14.11.4 不合规代码示例

该示例代码取一个全局原子变量n，然后使用公式`n * (n + 1) / 2`来计算`n + (n - 1) + (n - 2) + ... + 1`。

```cpp
#include <stdatomic.h>
 
atomic_int n = ATOMIC_VAR_INIT(0);
   
int compute_sum(void) {
  return n * (n + 1) / 2;
}
```

表达式中在两次原子读操作中n值可能会变化，这会导致错误结果。

#### 14.11.5 合规解决方案（复合赋值）

该解决方法传递原子变量作为函数参数，强制变量被拷贝而且保证正确结果。

```cpp
#include <stdatomic.h>
  
int compute_sum(int n) {
  return n * (n + 1) / 2;
}
```

#### 14.11.6 风险评估

原子变量多个操作被假定是原子化的，但实际上不是原子化的，这可能会发生奇怪的数据冲突，这会导致数据破坏和非法控制流。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON40-C | 中 | 很可能 | 中 | P8 | L2 |

#### 14.11.7 相关指南

| 文献 | 条款 |
| -- | -- | 
|MITRE CWE|CWE-366, Race Condition within a Thread <br>CWE-413, Improper Resource Locking <br>CWE-567, Unsynchronized Access to Shared Data in a Multithreaded Context <br>CWE-667, Improper Locking|

#### 14.11.8 参考文献

| 文献 | 条款 |
| -- | -- | 
|[ISO/IEC 9899:2011]|6.5.16.2, "Compound Assignment" <br>7.17, "Atomics" |


### 14.12 CON41-C 将意外失败函数封装在循环中

异常失败的函数应该被封装在一个循环中。`atomic_compare_exchange_weak()`和`atomic_compare_exchange_weak_explicit()` 函数尝试设置原子变量一个新值，当且仅当原子变量拥有一个已知的旧值。与`atomic_compare_exchange_strong()`和`atomic_compare_ex-change_strong_explicit()`相关函数不同，前两个函数允许异常失败。这使得这些函数在某些平台上执行地更快——比如，在使用加载链接/条件存储指令来实现比较-交换功能的架构，如Alpha, ARM, MIPS和PowerPC。在C标准 [[ISO/IEC 9899:2011][]] 7.17.7.4条款第4节描述这种行为如下：

>一个弱的比较-交换操作可能会异常失败。也就是说，即使期望引用的内存内容和对象均相等，弱比较-交换操作可能返回零，将原始值存储在期望内存中。

#### 14.12.1 不合规代码示例

该示例代码中，`reorganize_data_structure()`作为`thrd_create()`参数。在重组后，该函数尝试替换头指针以便指向新的版本。如果头指针在其加载之后没有被其他线程修改，那么`reorganize_data_structure()`退出该线程并返回`true`，这意味着成功。否则会丢弃本次重组尝试而且线程退出返回`false`。但是，即使头指针没有被修改`atomic_compare_exchange_weak()`函数也可能会失败。因此`reorganize_data_structure()`也许会先执行工作，然后再不必要地丢弃它。

```cpp
#include <stdatomic.h>
#include <stdbool.h>
 
struct data {
  struct data *next;
  /* ... */
};
 
extern void cleanup_data_structure(struct data *head);
 
int reorganize_data_structure(void *thread_arg) {
  struct data *_Atomic *ptr_to_head = thread_arg;
  struct data *old_head = atomic_load(ptr_to_head);
  struct data *new_head;
  bool success;
 
  /* ... Reorganize the data structure ... */
 
  success = atomic_compare_exchange_weak(ptr_to_head,
                                         &old_head, new_head);
  if (!success) {
    cleanup_data_structure(new_head);
  }
  return success; /* Exit the thread */
}
```

#### 14.12.2 合规解决方案（`atomic_compare_exchange_weak()`）

为了从异常失败中恢复，必须使用循环。`atomic_compare_exchange_weak()`会因为头指针改变而失败，或者因异常而失败。不管哪种情况，线程必须重复执行操作直到比较-交换成功，如解决方案中所示：

```cpp
#include <stdatomic.h>
#include <stdbool.h>
#include <stddef.h>
 
struct data {
  struct data *next;
  /* ... */
};
 
extern void cleanup_data_structure(struct data *head);
 
int reorganize_data_structure(void *thread_arg) {
  struct data *_Atomic *ptr_to_head = thread_arg;
  struct data *old_head = atomic_load(ptr_to_head);
  struct data *new_head = NULL;
  struct data *saved_old_head;
  bool success;
 
  do {
    if (new_head != NULL) {
      cleanup_data_structure(new_head);
    }
    saved_old_head = old_head;
 
  /* ... Reorganize the data structure ... */
 
  } while (!(success = atomic_compare_exchange_weak(
               ptr_to_head, &old_head, new_head
             )) && old_head == saved_old_head);
  return success; /* Exit the thread */
}
```

该循环也可能是较大控制流的一部分；比如，不合规代码示例中线程在返回false
之后会重试。

#### 14.12.3 合规解决方案（`atomic_compare_exchange_strong()`）

弱**比较—交换**需要一个循环，而强**比较—交换**是不需要的。优先选择强**比较—交换**，如该解决方案所示：

```cpp
#include <stdatomic.h>
#include <stdbool.h>
 
struct data {
  struct data *next;
  /* ... */
};
 
extern void cleanup_data_structure(struct data *head);
 
int reorganize_data_structure(void *thread_arg) {
  struct data *_Atomic *ptr_to_head = thread_arg;
  struct data *old_head = atomic_load(ptr_to_head);
  struct data *new_head;
  bool success;
 
  /* ... Reorganize the data structure ... */
 
  success = atomic_compare_exchange_strong(
    ptr_to_head, &old_head, new_head
  );
  if (!success) {
    cleanup_data_structure(new_head);
  }
  return success; /* Exit the thread */
}
```

#### 14.12.4 风险评估

不在循环中封装`atomic_compare_exchange_weak()`和`atomic_compare_exchange_weak_explicit()`会导致错误值或者错误控制流。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON41-C | 低 | 不太可能 | 中 | P2 | L3 |

#### 14.12.5 相关指南

| 文献 | 条款 |
| -- | -- | 
| CERT Oracle Secure Coding Standard for Java|    THI03-J. Always invoke wait() and await() methods inside a loop|

#### 14.12.6 参考文献

| 文献 | 条款 |
| -- | -- | 
|[ISO/IEC 9899:2011]|    7.17.7.4, "The atomic_compare_exchange Generic Functions"|
|[Lea 2000]|1.3.2, "Liveness" <br>3.2.2, "Monitor Mechanics"|

### 14.13 CON43-C 多线程代码中不允许数据竞争

当多个线程能够读取或修改相同数据时，请使用同步机制以避免能够导致安全漏洞的软件缺陷。数据竞争经常导致异常终止或拒绝服务，但也能够导致更严重的漏洞。C标准[[ISO/IEC 9899:2011][]],5.1.2.4节25段说：

>如果一个程序在两个线程中包含两个冲突的行为，至少一个行为是非原子化的，那么该程序的执行过程就包含一个数据冲突，或者两个都不会在另一个之前发生。任何这样数据冲突都会导致未定义行为。

#### 14.13.1 不合规代码示例

假设该简化代码是一个多线程银行家系统的一部分。当在一个账户中存钱和取钱时，线程调用 `credit()` 和 `debit()` 函数。因为加法操作和减法操作不是原子化的，两个操作可能同时发生，但是只能有一个结果被保存——虽然声明 `account_balance` 是 `volatile` 类型。例如，一个攻击者向一个账户存些钱，同时借大量次数的小额贷款。由于数据竞争，一些贷款没有影响账户余额，所以事实上攻击者可以获取好多钱。

```cpp
static volatile int account_balance;
 
void debit(int amount) {
  account_balance -= amount;
}
 
void credit(int amount) {
  account_balance += amount;
}
```

#### 14.13.2 合规解决方案（互斥）

该解决方案使用一个互斥体来保证存款和借贷成为原子操作。所有存款和借贷都会影响账户余额，因此攻击者不能利用数据竞争来从银行偷钱。该互斥体在 `mtx_init()` 函数中初始化，因此没有必要声明 `account_balance` 为 `volatile` 类型。

```cpp
#include <threads.h>
 
static int account_balance;
static mtx_t account_lock;
 
int debit(int amount) {
  if (mtx_lock(&account_lock) == thrd_error) {
    return -1;   /* Indicate error to caller */
  }
  account_balance -= amount;
  if (mtx_unlock(&account_lock) == thrd_error) {
    return -1;   /* Indicate error to caller */
  }
  return 0;   /* Indicate success */
}
 
int credit(int amount) {
  if (mtx_lock(&account_lock) == thrd_error) {
    return -1;   /* Indicate error to caller */
  }
  account_balance += amount;
  if (mtx_unlock(&account_lock) == thrd_error) {
    return -1;   /* Indicate error to caller */
  }
  return 0;   /* Indicate success */
}
 
int main(void) {
  if(mtx_init(&account_lock, mtx_plain) == thrd_error) {
    /* Handle error */
  }
  /* ... */
}
```

#### 14.13.3 合规解决方案（原子化）

该解决方案使用一个原子变量来同步存款和借贷操作。所有存款和阶段都会影响账户余额，因此攻击者不能利用数据竞争来从银行偷钱。该原子整数变量不需要初始化，因此静态或者线程本地存储的原子对象的默认初始化（0）保证产生一个合法状态。原子变量的+=和-=操作行为是原子化的。

```cpp
#include <stdatomic.h>
 
atomic_int account_balance;
 
void debit(int amount) {
  account_balance -= amount;
}
 
void credit(int amount) {
  account_balance += amount;
}
```

#### 14.13.4 不合规代码示例（Double-Fetch）

该示例代码说明Xen安全建议CVE-2015-8550 / XSA-155。在下面示例代码中，`ps` 引用的整数在两次读操作中可能会被第二个线程修改，因此存在数据竞争的漏洞。

```cpp
#include <stdio.h>
  
void doStuff(int *ps) {
  switch (*ps) {
    case 0: { printf("0"); break; }
    case 1: { printf("1"); break; }
    case 2: { printf("2"); break; }
    case 3: { printf("3"); break; }
    case 4: { printf("4"); break; }
    default: { printf("default"); break; }
  }
}
```

尽管在源代码中仅存在一个读 `*ps` 变量，但是编译器允许产生对内存位置执行多次读操作的目标代码。这由“as-if”原则所允许，在[[C99 基础理论 2003][]] 5.1 节解释：

>“as-if”原则在基础理论中被反复调用。C89委员会发现，在描述C语言、库和环境的多个方面中，依照具体模型能够更好地讨论和陈述。每次尝试都精心制作这些模型，因此实现被仅限制在必须产生相同结果范围之内，“as-if”已经实现该陈述模型；经常，最清晰的模型可能会导致最坏的实现。

#### 14.13.5 实现细节（GCC）
这段代码在X86上 GCC-4.8.4产生两次读 `*ps` 变量，在X86-64上GCC-5.3.0也是一样的（[[Compiler-Introduced Double-Fetch Vulnerabilities – Understanding XSA-155][]]）。

#### 14.13.6 不合规代码示例（Volatile）
将数据声明为 `volatile` 可以使数据竞争不生效，因为 `volatile` 关键字迫使编译器不再产生两次读操作。但是这违反CON02-C. Do not use volatile as a synchronization primitive[].

```cpp
#include <stdio.h>
  
void doStuff(volatile int *ps) {
  switch (*ps) {
    case 0: { printf("0"); break; }
    case 1: { printf("1"); break; }
    case 2: { printf("2"); break; }
    case 3: { printf("3"); break; }
    case 4: { printf("4"); break; }
    default: { printf("default"); break; }
  }
}
```

#### 14.13.7 合规解决方案（C11, 原子化）
  
  将数据声明为原子类型也会迫使编译仅产生一次读数据。
 
```cpp
#include <stdio.h>
#include <stdatomic.h>

void doStuff(atomic_int *ps) {
  switch (atomic_load(ps)) {
    case 0: { printf("0"); break; }
    case 1: { printf("1"); break; }
    case 2: { printf("2"); break; }
    case 3: { printf("3"); break; }
    case 4: { printf("4"); break; }
    default: { printf("default"); break; }
  }
}
```

#### 14.13.8 合规解决方案（C11, 栅栏）
   最终是通过设置栅栏将 `switch` 语句包围起来解决该故障。

```cpp
#include <stdio.h>
#include <stdatomic.h>
  
void doStuff(int *ps) {
  atomic_thread_fence(memory_order_acquire);
  switch (*ps) {
    case 0: { printf("0"); break; }
    case 1: { printf("1"); break; }
    case 2: { printf("2"); break; }
    case 3: { printf("3"); break; }
    case 4: { printf("4"); break; }
    default: { printf("default"); break; }
  }
  atomic_thread_fence(memory_order_release);
}
```

#### 14.13.9 风险评估

多线程同时访问和修改相同数据而导致竞争条件会导致异常终止和拒绝服务攻击或者数据完整性破坏。

| 规则 | 严重性 | 可能性 | 修补成本 | 优先级 | 等级 |
| -- | -- | -- | -- | -- | -- |
| CON43-C | 中 | 很可能 | 高 | P4 | L3 |

#### 14.13.10 相关指南

| 文献 | 条款 |
| -- | -- | 
|MITRE| CWECWE-366, Race condition within a thread|

#### 14.13.11 参考文献

| 文献 | 条款 |
| -- | -- | 
|[ISO/IEC 9899:2011]|    5.1.2.4, "Multi-threaded Executions and Data Races"7.17.2, "Initialization"|
|[C99 Rationale 2003]     ||
|[Dowd 2006]|    Chapter 13, "Synchronization and State"|
|[Plum 2012]     ||
|[Seacord 2013]|    Chapter 8, "File I/O"|
    

<!-- 链接定义 -->
[ISO/IEC 9899:2011]: https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-ISO-IEC9899-2011

[unsigned interger wrapping]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-unsignedintegerwrapping

[INT02-C]: https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=322

[ARR37-C]:  https://www.securecoding.cert.org/confluence/display/c/ARR37-C.+Do+not+add+or+subtract+an+integer+to+a+pointer+to+a+non-array+object

[ARR30-C]: https://www.securecoding.cert.org/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts

[unexpected]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-unexpectedbehavior

[vulnerability]: https://www.securecoding.cert.org/confluence/display/c/BB.+Definitions#BB.Definitions-vulnerability

[ARR36-C]: https://www.securecoding.cert.org/confluence/display/c/ARR36-C.+Do+not+subtract+or+compare+two+pointers+that+do+not+refer+to+the+same+array

[ARR37-C]: https://www.securecoding.cert.org/confluence/display/c/ARR37-C.+Do+not+add+or+subtract+an+integer+to+a+pointer+to+a+non-array+object

[ARR30-C]: https://www.securecoding.cert.org/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts

[VU#551436]: https://www.securecoding.cert.org/confluence/display/c/AA.+Bibliography#AA.Bibliography-VU551436

[INT02-C]: https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=322
